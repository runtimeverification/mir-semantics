fn sum_to_n :: .FunctionPath ( _1 : usize  , .ParameterList ) -> usize  { debug n => _1 ;  .DebugList let mut _0 : usize  ;  let mut _2 : usize  ;  let mut _4 : bool  ;  let mut _5 : usize  ;  let mut _6 : usize  ;  let mut _7 : usize  ;  .BindingList scope 1 { debug sum => _2 ;  .DebugList let mut _3 : usize  ;  .BindingList scope 2 { debug counter => _3 ;  .DebugList .BindingList .ScopeList }  .ScopeList }  .ScopeList bb0  : { _2 = const 0_usize ;  _3 = _1 ;  .Statements goto -> bb1  ; }  bb1  : { _5 = _3 ;  _4 = Gt ( move _5 , const 0_usize ) ;  .Statements switchInt ( move _4 ) -> [ 0 : bb3  , .SwitchTargets , otherwise : bb2  ] ; }  bb2  : { _6 = _3 ;  _2 = Add ( _2 , move _6 ) ;  _7 = _3 ;  _3 = Sub ( move _7 , const 1_usize ) ;  .Statements goto -> bb1  ; }  bb3  : { _0 = _2 ;  .Statements return ; }  .BasicBlockList }  fn test_sum_to_n :: .FunctionPath ( .ParameterList ) -> ( ) { .DebugList let mut _0 : ( ) ;  let  _1 : usize  ;  let mut _4 : usize  ;  let mut _5 : bool  ;  let mut _6 : ! ;  .BindingList scope 1 { debug n => _1 ;  .DebugList let  _2 : usize  ;  .BindingList scope 2 { debug golden => _2 ;  .DebugList let  _3 : bool  ;  .BindingList scope 3 { debug sucess => _3 ;  .DebugList .BindingList .ScopeList }  .ScopeList }  .ScopeList }  .ScopeList bb0  : { _1 = const 10_usize ;  _2 = const 55_usize ;  .Statements _4 = sum_to_n :: .ExpressionPathList ( _1 , .OperandList ) -> bb1  ; }  bb1  : { _3 = Eq ( move _4 , _2 ) ;  _5 = Not ( _3 ) ;  .Statements switchInt ( move _5 ) -> [ 0 : bb3  , .SwitchTargets , otherwise : bb2  ] ; }  bb2  : { .Statements _6 = core :: panicking :: panic :: .ExpressionPathList ( const "assertion failed: sucess" , .OperandList ) ; }  bb3  : { .Statements return ; }  .BasicBlockList }  fn main :: .FunctionPath ( .ParameterList ) -> ( ) { .DebugList let mut _0 : ( ) ;  let  _1 : ( ) ;  .BindingList .ScopeList bb0  : { .Statements _1 = test_sum_to_n :: .ExpressionPathList ( .OperandList ) -> bb1  ; }  bb1  : { .Statements return ; }  .BasicBlockList }  .Mir

