Conventions that MIR semantics need to follow:

1. Syntax productions intended to be detected by the parser should be labeled with a group starting with mir: [group(mir)], [group(mir-...)]

2. This explains the meaning of the group mir.

mir-int:
syntax A ::= a(Int) [group(mir-int), ...]
json: an integer value, e.g., 1

mir-string:
syntax A ::= a(String) [group(mir-string), ...]
json: a string value, e.g., "abc"

mir-bool:
syntax A ::= a(Bool) [group(mir-bool), ...]
json: a boolean value, e.g., true

mir-list:
syntax L ::= List {E, ""} [group(mir-list), ...]
json: a homogeneous list, e.g. [e1, e2, e3, ...]
Note that all elements of the json list (e1, e2, e3) should correspond to syntactic productions for the sort E.

mir-enum:
syntax MyEnum ::= myEnumField1(...) [group(mir-enum), ...]
                | myEnumField2(...) [group(mir-enum), ...]
json: a dictionary with a single key value pair. The key should correspond to one of the productions for the MyEnum Sort, and the value should be a  

mir: 

3. Syntax productions with more than one non terminals should not include sorts Int, Bool, String, but should instead use the sorts MIRInt, MIRBool, MIRString. These are intended to be semantically equivalent, i.e. mirInt(I) => I, mirBool(B) => B, mirString(S) => S.
Note: This transformation should have happened already. If a place has been missed, where a sort has not been replaced with MIRsort, this should be trasformed. Also, this should happen for any other primitive sorts.

4. There are productions that correspond to enumerations

enum MyEnum {
  Field1,
  Field2,
}

These may be of the form (a)
syntax MyEnum ::= myEnumField1
                | myEnumField2

or of the form (b)

syntax MyEnum ::= MyEnumField1
                | MyEnumField2
syntax MyEnumField1 ::= myEnumField1
syntax MyEnumField2 ::= myEnumField2

We need to always have rules of form (a). This transformation has not happened yet.

5. The symbols for the terminals should be sort::value, e.g. Mutability::Not.
6. The symbols for the terminals should also be sort::value, e.g. StatementKind::StorageLive.

Not yet handled:
Maybe...
Special parsing (maps, crate_id + unique IDs, new constant kinds)
