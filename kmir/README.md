# kmir

`kmir` is a Python package and CLI tool that leverages the [`pyk`](https://github.com/runtimeverification/pyk) library to provide a Python interface for the K semantics. While the K semantics can be also used directly, the `kmir` tool makes it more accessible for people not familiar with K. See the `kmir/README.md` for instruction on how to use `kmir` and the available CLI commands.

## Build `kmir`

Prerequsites: `python 3.8.*`, `pip >= 20.0.2`, `poetry >= 1.3.2`.

We use the `poetry` tool to manage Python virtual environments. This step will create an environment and install the `kmir` tool via `poetry`, executing

```bash
make build
```

When working on the code, we suggest calling `kmir` via Poetry's `poetry run` command. This ensures that you are calling the up-to-date `kmir` script since `poetry` will track the changes to the source code. For example:

```bash
poetry run kmir --help
```

Alternative, you can spawn a one-off shell that will allow you to interact with `kmir` directly by executing the command

```bash
poetry shell
kmir --help
```

In case you are sure you want a global installation of `kmir`, it's possible with `pip`:

```bash
make build
pip install dist/*.whl
```

## `kmir` commands

The current version of `kmir` provides two commands:
- `kmir parse` to parse a `.mir` file. This command invokes the parser generated by K and outputs a K representation of MIR abstract syntax parsed from a file.
- `kmir run` to interpret a MIR program. This command invokes the LLVM interpreter generated by K and execute the MIR code in the file.

### Examples

We assume that you've run `poetry  install && poetry shell` in the `kmir/` directory and thus the `kmir` executable is available.

At the moment, the `kmir parse` command is essentially a syntax-checker for MIR files. To parse a MIR file, for example one of the handwritten examples, run:

```bash
kmir parse --definition-dir $(kbuild which llvm) src/tests/integration/test-data/handwritten-mir/execution/assert-true.mir
```

The output of this command is going to look intimidating, but it is, in fact, just a K-friendly representation of the programs abstract-syntax tree. `kmir parse` can *unparse* this representation to make it look more like the original MIR source (note the `--output pretty` at the end):

```bash
kmir parse --definition-dir $(kbuild which llvm) src/tests/integration/test-data/handwritten-mir/execution/assert-true.mir --output pretty
```

You may wounder that `--definition-dir $(kbuild which llvm)` means. Since `kmir` is just a think Python script and does not do any heavy-lifting itself, it needs access the the K definition of MIR. The `kbuild` tool handles compiling the K code and provides a `which` command to output the path to the compiled definition, which we give to `kmir`.

## For Developers

### Using the build system

The build system is a mixture of `poetry` + `kbuild` + `make`:
* `poetry` handles Python dependencies, see [pyproject.toml](`pyproject.toml`) for Python-related configuration;
* `kbuild` handles K dependencies and build targets, see [kbuild.toml](`kbuild.toml`);
* `make` ties the two together.

### Working on the Python files

The Python source code of the `kmir` tool and library resides in [`src/`](src). The entry point to the tool is [`src/kmir/__main__.py`](src/kmir/__main__.py).

Use `make` to run common tasks (see the [Makefile](Makefile) for a complete list of available targets).

* `make build`: Build wheel
* `make check`: Check code style
* `make format`: Format code
* `make test-unit`: Run unit tests
* `make test-integration`: Run integration tests

For interactive use, spawn a shell with `poetry shell` (after `poetry install`), then run an interpreter.

### Working on the K files

The K source code of the semantics resides in [`k-src`](k-src).

Working on the semantics (targeting the LLVM backend) roughly comprises the following steps:
0. Pick a MIR/Rust program as a running example, or a several of them
1. Modify K files
2. Run `poetry run kbuild kompile llvm` to re-kompile the semantics
3. Run a concrete example with `kmir run` -> goto 1
4. Once happy with the step 3 goes, run a part of the integration tests by calling:
   ```
   TEST_ARGS=`--kbuild-dir ~/.kbuild -k test_handwritten` make test-integration-run
   ```
   Modify the command as necessary to include the tests you want. Use `TEST_ARGS='--kbuild-dir ~/.kbuild'` to use your transient `kbuild` artifacts (the kompiled definition) to avoid rebuilding from scratch.
5. Once happy with the step 4 goes, run the complete integration test suite:
   ```
   make test-integration-run
   ```
   This time, do not include the `--kbuild-dir` option to re-kompile everything in a temporary directory.

### Get MIR files from rust programs
At MIR level, it will go through multiple passes of optimization until the final file ready for code gen. The Rust compiler provides ways to output the MIR file for a rust program. 
1. The [`emit`](https://doc.rust-lang.org/rustc/command-line-arguments.html#--emit-specifies-the-types-of-output-files-to-generate) option (enabled for `stable` and `nightly` versions):
   ```
   rustc prog.rs --emit mir
   ```
> Note that even for the stable versions, the emitted MIR could be different for the same program. The optimization passes could be changed. For example, version 1.67 has `ConstProp` optimization, but version 1.70 removed it.

2. The [`dump`](https://rustc-dev-guide.rust-lang.org/mir/debugging.html) option (only enabled at `nightly` versions)
   ```
   rustc prog.rs -Zdump-mir= 'func & runtime-optimized' -Zdump-mir-dir=./ -Zmir-opt-level=0
   ```
Here a few of the `-Z` flags are used to filter the expected MIR file, e.g.,
1. `-Zdump-mir= 'func & runtime-optimized'` filters the MIR files related to function contain the name `func` and is the MIR output after `runtime-optimized` pass.
2. `-Zdump-mir-dir=./` specifies the output directory.
3. `-Zmir-opt-level=0` specifies the [optimization level](https://github.com/rust-lang/compiler-team/issues/319) where `0` applies some optimization passes, less then the `emit` option.

### Executing MIR programs with `kmir`

Use the following commands from the `kmir` directory to manually run the MIR files using the generated interpreter.
Use `--output pretty` to see the un-parsed final configuration. Run the handwritten MIR like this:
```
poetry run kmir run --definition-dir $(poetry run kbuild which llvm) --output pretty src/tests/integration/test-data/handwritten-mir/execution/arithm-simple.mir
```

Or a MIR compiled from handwritten Rust:
```
poetry run kmir run --definition-dir $(poetry run kbuild which llvm) --output pretty src/tests/integration/test-data/handwritten-rust/test-binop.mir
```

These commands are verbose. To make them a little less so, you could set an environment variable to store the definition path:
```
export KMIR_DEFINITION=$(poetry run kbuild which llvm)
poetry run kmir run --definition-dir $KMIR_DEFINITION --output pretty src/tests/integration/test-data/handwritten-rust/test-binop.mir
```


To reduce this friction a little, we provide a simple `bash` script [`doit.sh`](doit.sh) that encapsulates the common `kmir` calls.

### Proving MIR claims

Use the following commands from the `kmir` directory to manually prove `k` specification files for MIR.
```
poetry run kmir prove --definition-dir $(poetry run kbuild which llvm) --haskell-dir $(poetry run kbuild which haskell) --spec-file src/tests/proofs/simple-spec.k --output pretty
```
TODO DEVELOPMENT: Can also add flag: (see exec_prove in __main__.py)
```
--use-kprove-object
```