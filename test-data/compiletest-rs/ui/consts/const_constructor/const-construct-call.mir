// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn call_external_constructors_in_local_vars() -> AssertUnwindSafe<(Option<i32>, Result<i32, bool>)> {
    let mut _0: std::panic::AssertUnwindSafe<(std::option::Option<i32>, std::result::Result<i32, bool>)>;
    let mut _4: (std::option::Option<i32>, std::result::Result<i32, bool>);
    let mut _5: std::option::Option<i32>;
    let mut _6: std::result::Result<i32, bool>;
    scope 1 {
        debug f => Option::<i32>::Some;
        scope 2 {
            debug g => Result::<i32, bool>::Err;
            scope 3 {
                debug h => AssertUnwindSafe::<(Option<i32>, Result<i32, bool>)>;
                let _1: std::option::Option<i32>;
                scope 4 {
                    debug x => _1;
                    let _2: std::result::Result<i32, bool>;
                    scope 5 {
                        debug y => _2;
                        let _3: std::panic::AssertUnwindSafe<(std::option::Option<i32>, std::result::Result<i32, bool>)>;
                        scope 6 {
                            debug z => _3;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _1 = Option::<i32>::Some(const 5_i32) -> bb1;
    }

    bb1: {
        _2 = Result::<i32, bool>::Err(const false) -> bb2;
    }

    bb2: {
        _5 = _1;
        _6 = _2;
        _4 = (move _5, move _6);
        _3 = AssertUnwindSafe::<(Option<i32>, Result<i32, bool>)>(move _4) -> bb3;
    }

    bb3: {
        _0 = move _3;
        return;
    }
}

// MIR FOR CTFE
fn call_external_constructors_in_local_vars() -> AssertUnwindSafe<(Option<i32>, Result<i32, bool>)> {
    let mut _0: std::panic::AssertUnwindSafe<(std::option::Option<i32>, std::result::Result<i32, bool>)>;
    let _1: fn(i32) -> std::option::Option<i32> {std::option::Option::<i32>::Some};
    let mut _5: fn(i32) -> std::option::Option<i32> {std::option::Option::<i32>::Some};
    let mut _7: fn(bool) -> std::result::Result<i32, bool> {std::result::Result::<i32, bool>::Err};
    let mut _9: fn((std::option::Option<i32>, std::result::Result<i32, bool>)) -> std::panic::AssertUnwindSafe<(std::option::Option<i32>, std::result::Result<i32, bool>)> {std::panic::AssertUnwindSafe::<(std::option::Option<i32>, std::result::Result<i32, bool>)>};
    let mut _10: (std::option::Option<i32>, std::result::Result<i32, bool>);
    let mut _11: std::option::Option<i32>;
    let mut _12: std::result::Result<i32, bool>;
    scope 1 {
        debug f => _1;
        let _2: fn(bool) -> std::result::Result<i32, bool> {std::result::Result::<i32, bool>::Err};
        scope 2 {
            debug g => _2;
            let _3: fn((std::option::Option<i32>, std::result::Result<i32, bool>)) -> std::panic::AssertUnwindSafe<(std::option::Option<i32>, std::result::Result<i32, bool>)> {std::panic::AssertUnwindSafe::<(std::option::Option<i32>, std::result::Result<i32, bool>)>};
            scope 3 {
                debug h => _3;
                let _4: std::option::Option<i32>;
                scope 4 {
                    debug x => _4;
                    let _6: std::result::Result<i32, bool>;
                    scope 5 {
                        debug y => _6;
                        let _8: std::panic::AssertUnwindSafe<(std::option::Option<i32>, std::result::Result<i32, bool>)>;
                        scope 6 {
                            debug z => _8;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        StorageLive(_1);
        _1 = Option::<i32>::Some;
        StorageLive(_2);
        _2 = Result::<i32, bool>::Err;
        StorageLive(_3);
        _3 = AssertUnwindSafe::<(Option<i32>, Result<i32, bool>)>;
        StorageLive(_4);
        StorageLive(_5);
        _5 = _1;
        ConstEvalCounter;
        _4 = move _5(const 5_i32) -> bb1;
    }

    bb1: {
        StorageDead(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = _2;
        ConstEvalCounter;
        _6 = move _7(const false) -> bb2;
    }

    bb2: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = _3;
        StorageLive(_10);
        StorageLive(_11);
        _11 = _4;
        StorageLive(_12);
        _12 = _6;
        _10 = (move _11, move _12);
        StorageDead(_12);
        StorageDead(_11);
        ConstEvalCounter;
        _8 = move _9(move _10) -> bb3;
    }

    bb3: {
        StorageDead(_10);
        StorageDead(_9);
        _0 = move _8;
        StorageDead(_8);
        StorageDead(_6);
        StorageDead(_4);
        StorageDead(_3);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

const CALL_EXTERNAL_CONSTRUCTORS_IN_LOCAL_VARS: AssertUnwindSafe<(Option<i32>, Result<i32, bool>)> = {
    let mut _0: std::panic::AssertUnwindSafe<(std::option::Option<i32>, std::result::Result<i32, bool>)>;
    let _1: fn(i32) -> std::option::Option<i32> {std::option::Option::<i32>::Some};
    let mut _5: fn(i32) -> std::option::Option<i32> {std::option::Option::<i32>::Some};
    let mut _7: fn(bool) -> std::result::Result<i32, bool> {std::result::Result::<i32, bool>::Err};
    let mut _9: fn((std::option::Option<i32>, std::result::Result<i32, bool>)) -> std::panic::AssertUnwindSafe<(std::option::Option<i32>, std::result::Result<i32, bool>)> {std::panic::AssertUnwindSafe::<(std::option::Option<i32>, std::result::Result<i32, bool>)>};
    let mut _10: (std::option::Option<i32>, std::result::Result<i32, bool>);
    let mut _11: std::option::Option<i32>;
    let mut _12: std::result::Result<i32, bool>;
    scope 1 {
        debug f => _1;
        let _2: fn(bool) -> std::result::Result<i32, bool> {std::result::Result::<i32, bool>::Err};
        scope 2 {
            debug g => _2;
            let _3: fn((std::option::Option<i32>, std::result::Result<i32, bool>)) -> std::panic::AssertUnwindSafe<(std::option::Option<i32>, std::result::Result<i32, bool>)> {std::panic::AssertUnwindSafe::<(std::option::Option<i32>, std::result::Result<i32, bool>)>};
            scope 3 {
                debug h => _3;
                let _4: std::option::Option<i32>;
                scope 4 {
                    debug x => _4;
                    let _6: std::result::Result<i32, bool>;
                    scope 5 {
                        debug y => _6;
                        let _8: std::panic::AssertUnwindSafe<(std::option::Option<i32>, std::result::Result<i32, bool>)>;
                        scope 6 {
                            debug z => _8;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        StorageLive(_1);
        _1 = Option::<i32>::Some;
        StorageLive(_2);
        _2 = Result::<i32, bool>::Err;
        StorageLive(_3);
        _3 = AssertUnwindSafe::<(Option<i32>, Result<i32, bool>)>;
        StorageLive(_4);
        StorageLive(_5);
        _5 = _1;
        ConstEvalCounter;
        _4 = move _5(const 5_i32) -> bb1;
    }

    bb1: {
        StorageDead(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = _2;
        ConstEvalCounter;
        _6 = move _7(const false) -> bb2;
    }

    bb2: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = _3;
        StorageLive(_10);
        StorageLive(_11);
        _11 = _4;
        StorageLive(_12);
        _12 = _6;
        _10 = (move _11, move _12);
        StorageDead(_12);
        StorageDead(_11);
        ConstEvalCounter;
        _8 = move _9(move _10) -> bb3;
    }

    bb3: {
        StorageDead(_10);
        StorageDead(_9);
        _0 = move _8;
        StorageDead(_8);
        StorageDead(_6);
        StorageDead(_4);
        StorageDead(_3);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

fn call_external_constructors_in_temps() -> AssertUnwindSafe<(Option<i32>, Result<i32, bool>)> {
    let mut _0: std::panic::AssertUnwindSafe<(std::option::Option<i32>, std::result::Result<i32, bool>)>;
    let _1: std::option::Option<i32>;
    let _4: usize;
    let mut _5: usize;
    let mut _6: bool;
    let mut _7: (std::option::Option<i32>, std::result::Result<i32, bool>);
    let mut _8: std::option::Option<i32>;
    let mut _9: std::result::Result<i32, bool>;
    scope 1 {
        debug x => _1;
        let _2: std::result::Result<i32, bool>;
        scope 2 {
            debug y => _2;
            let _3: std::panic::AssertUnwindSafe<(std::option::Option<i32>, std::result::Result<i32, bool>)>;
            scope 3 {
                debug z => _3;
            }
        }
    }

    bb0: {
        _1 = Option::<i32>::Some(const 5_i32) -> bb1;
    }

    bb1: {
        _2 = Result::<i32, bool>::Err(const false) -> bb2;
    }

    bb2: {
        _4 = const 0_usize;
        _5 = const 1_usize;
        _6 = Lt(_4, _5);
        assert(move _6, "index out of bounds: the length is {} but the index is {}", move _5, _4) -> bb3;
    }

    bb3: {
        _8 = _1;
        _9 = _2;
        _7 = (move _8, move _9);
        _3 = AssertUnwindSafe::<(Option<i32>, Result<i32, bool>)>(move _7) -> bb4;
    }

    bb4: {
        _0 = move _3;
        return;
    }
}

// MIR FOR CTFE
fn call_external_constructors_in_temps() -> AssertUnwindSafe<(Option<i32>, Result<i32, bool>)> {
    let mut _0: std::panic::AssertUnwindSafe<(std::option::Option<i32>, std::result::Result<i32, bool>)>;
    let _1: std::option::Option<i32>;
    let mut _2: fn(i32) -> std::option::Option<i32> {std::option::Option::<i32>::Some};
    let mut _4: fn(bool) -> std::result::Result<i32, bool> {std::result::Result::<i32, bool>::Err};
    let mut _5: &fn(bool) -> std::result::Result<i32, bool> {std::result::Result::<i32, bool>::Err};
    let _6: fn(bool) -> std::result::Result<i32, bool> {std::result::Result::<i32, bool>::Err};
    let mut _8: fn((std::option::Option<i32>, std::result::Result<i32, bool>)) -> std::panic::AssertUnwindSafe<(std::option::Option<i32>, std::result::Result<i32, bool>)> {std::panic::AssertUnwindSafe::<(std::option::Option<i32>, std::result::Result<i32, bool>)>};
    let mut _9: [fn((std::option::Option<i32>, std::result::Result<i32, bool>)) -> std::panic::AssertUnwindSafe<(std::option::Option<i32>, std::result::Result<i32, bool>)> {std::panic::AssertUnwindSafe::<(std::option::Option<i32>, std::result::Result<i32, bool>)>}; 1];
    let _10: usize;
    let mut _11: usize;
    let mut _12: bool;
    let mut _13: (std::option::Option<i32>, std::result::Result<i32, bool>);
    let mut _14: std::option::Option<i32>;
    let mut _15: std::result::Result<i32, bool>;
    scope 1 {
        debug x => _1;
        let _3: std::result::Result<i32, bool>;
        scope 2 {
            debug y => _3;
            let _7: std::panic::AssertUnwindSafe<(std::option::Option<i32>, std::result::Result<i32, bool>)>;
            scope 3 {
                debug z => _7;
            }
        }
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _2 = Option::<i32>::Some;
        ConstEvalCounter;
        _1 = move _2(const 5_i32) -> bb1;
    }

    bb1: {
        StorageDead(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        _6 = Result::<i32, bool>::Err;
        _5 = &_6;
        _4 = (*_5);
        ConstEvalCounter;
        _3 = move _4(const false) -> bb2;
    }

    bb2: {
        StorageDead(_4);
        StorageDead(_6);
        StorageDead(_5);
        StorageLive(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = [AssertUnwindSafe::<(Option<i32>, Result<i32, bool>)>];
        StorageLive(_10);
        _10 = const 0_usize;
        _11 = Len(_9);
        _12 = Lt(_10, _11);
        assert(move _12, "index out of bounds: the length is {} but the index is {}", move _11, _10) -> bb3;
    }

    bb3: {
        _8 = _9[_10];
        StorageLive(_13);
        StorageLive(_14);
        _14 = _1;
        StorageLive(_15);
        _15 = _3;
        _13 = (move _14, move _15);
        StorageDead(_15);
        StorageDead(_14);
        ConstEvalCounter;
        _7 = move _8(move _13) -> bb4;
    }

    bb4: {
        StorageDead(_13);
        StorageDead(_8);
        StorageDead(_10);
        StorageDead(_9);
        _0 = move _7;
        StorageDead(_7);
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

const CALL_EXTERNAL_CONSTRUCTORS_IN_TEMPS: AssertUnwindSafe<(Option<i32>, Result<i32, bool>)> = {
    let mut _0: std::panic::AssertUnwindSafe<(std::option::Option<i32>, std::result::Result<i32, bool>)>;
    let _1: std::option::Option<i32>;
    let mut _2: fn(i32) -> std::option::Option<i32> {std::option::Option::<i32>::Some};
    let mut _4: fn(bool) -> std::result::Result<i32, bool> {std::result::Result::<i32, bool>::Err};
    let mut _5: &fn(bool) -> std::result::Result<i32, bool> {std::result::Result::<i32, bool>::Err};
    let _6: fn(bool) -> std::result::Result<i32, bool> {std::result::Result::<i32, bool>::Err};
    let mut _8: fn((std::option::Option<i32>, std::result::Result<i32, bool>)) -> std::panic::AssertUnwindSafe<(std::option::Option<i32>, std::result::Result<i32, bool>)> {std::panic::AssertUnwindSafe::<(std::option::Option<i32>, std::result::Result<i32, bool>)>};
    let mut _9: [fn((std::option::Option<i32>, std::result::Result<i32, bool>)) -> std::panic::AssertUnwindSafe<(std::option::Option<i32>, std::result::Result<i32, bool>)> {std::panic::AssertUnwindSafe::<(std::option::Option<i32>, std::result::Result<i32, bool>)>}; 1];
    let _10: usize;
    let mut _11: usize;
    let mut _12: bool;
    let mut _13: (std::option::Option<i32>, std::result::Result<i32, bool>);
    let mut _14: std::option::Option<i32>;
    let mut _15: std::result::Result<i32, bool>;
    scope 1 {
        debug x => _1;
        let _3: std::result::Result<i32, bool>;
        scope 2 {
            debug y => _3;
            let _7: std::panic::AssertUnwindSafe<(std::option::Option<i32>, std::result::Result<i32, bool>)>;
            scope 3 {
                debug z => _7;
            }
        }
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _2 = Option::<i32>::Some;
        ConstEvalCounter;
        _1 = move _2(const 5_i32) -> bb1;
    }

    bb1: {
        StorageDead(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        _6 = Result::<i32, bool>::Err;
        _5 = &_6;
        _4 = (*_5);
        ConstEvalCounter;
        _3 = move _4(const false) -> bb2;
    }

    bb2: {
        StorageDead(_4);
        StorageDead(_6);
        StorageDead(_5);
        StorageLive(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = [AssertUnwindSafe::<(Option<i32>, Result<i32, bool>)>];
        StorageLive(_10);
        _10 = const 0_usize;
        _11 = Len(_9);
        _12 = Lt(_10, _11);
        assert(move _12, "index out of bounds: the length is {} but the index is {}", move _11, _10) -> bb3;
    }

    bb3: {
        _8 = _9[_10];
        StorageLive(_13);
        StorageLive(_14);
        _14 = _1;
        StorageLive(_15);
        _15 = _3;
        _13 = (move _14, move _15);
        StorageDead(_15);
        StorageDead(_14);
        ConstEvalCounter;
        _7 = move _8(move _13) -> bb4;
    }

    bb4: {
        StorageDead(_13);
        StorageDead(_8);
        StorageDead(_10);
        StorageDead(_9);
        _0 = move _7;
        StorageDead(_7);
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

fn <impl at ui/consts/const_constructor/const-construct-call.rs:44:10: 44:15>::fmt(_1: &LocalOption<T>, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: isize;
    let _4: &T;
    let _5: &str;
    let mut _6: &dyn std::fmt::Debug;
    let _7: &&T;
    let _8: &str;
    scope 1 {
        debug __self_0 => _4;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _8 = const "_None";
        _0 = Formatter::<'_>::write_str(_2, _8) -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = &(((*_1) as Some).0: T);
        _5 = const "Some";
        _7 = &_4;
        _6 = _7 as &dyn std::fmt::Debug (Pointer(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _5, move _6) -> bb4;
    }

    bb4: {
        return;
    }
}

fn <impl at ui/consts/const_constructor/const-construct-call.rs:44:17: 44:26>::eq(_1: &LocalOption<T>, _2: &LocalOption<T>) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    let mut _5: bool;
    let mut _6: bool;
    let mut _7: (&LocalOption<T>, &LocalOption<T>);
    let mut _8: isize;
    let mut _9: isize;
    let mut _12: &LocalOption<T>;
    let mut _13: &LocalOption<T>;
    let mut _14: &LocalOption<T>;
    let mut _15: &LocalOption<T>;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
            let _10: &T;
            let _11: &T;
            scope 3 {
                debug __self_0 => _10;
                debug __arg1_0 => _11;
            }
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _5 = Eq(_3, _4);
        switchInt(move _5) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = const false;
        goto -> bb3;
    }

    bb2: {
        _7 = (_1, _2);
        _12 = deref_copy (_7.0: &LocalOption<T>);
        _9 = discriminant((*_12));
        switchInt(move _9) -> [0: bb4, otherwise: bb5];
    }

    bb3: {
        return;
    }

    bb4: {
        _13 = deref_copy (_7.1: &LocalOption<T>);
        _8 = discriminant((*_13));
        switchInt(move _8) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _6 = const true;
        goto -> bb7;
    }

    bb6: {
        _14 = deref_copy (_7.0: &LocalOption<T>);
        _10 = &(((*_14) as Some).0: T);
        _15 = deref_copy (_7.1: &LocalOption<T>);
        _11 = &(((*_15) as Some).0: T);
        _6 = <T as PartialEq>::eq(_10, _11) -> bb7;
    }

    bb7: {
        _0 = move _6;
        goto -> bb3;
    }
}

fn <impl at ui/consts/const_constructor/const-construct-call.rs:50:10: 50:15>::fmt(_1: &LocalResult<T, E>, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: isize;
    let _4: &T;
    let _5: &str;
    let mut _6: &dyn std::fmt::Debug;
    let _7: &&T;
    let _8: &E;
    let _9: &str;
    let mut _10: &dyn std::fmt::Debug;
    let _11: &&E;
    scope 1 {
        debug __self_0 => _4;
    }
    scope 2 {
        debug __self_0 => _8;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _8 = &(((*_1) as Err).0: E);
        _9 = const "Err";
        _11 = &_8;
        _10 = _11 as &dyn std::fmt::Debug (Pointer(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _9, move _10) -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = &(((*_1) as _Ok).0: T);
        _5 = const "_Ok";
        _7 = &_4;
        _6 = _7 as &dyn std::fmt::Debug (Pointer(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _5, move _6) -> bb4;
    }

    bb4: {
        return;
    }
}

fn <impl at ui/consts/const_constructor/const-construct-call.rs:50:17: 50:26>::eq(_1: &LocalResult<T, E>, _2: &LocalResult<T, E>) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    let mut _5: bool;
    let mut _6: bool;
    let mut _7: (&LocalResult<T, E>, &LocalResult<T, E>);
    let mut _8: isize;
    let mut _9: isize;
    let mut _10: isize;
    let mut _15: &LocalResult<T, E>;
    let mut _16: &LocalResult<T, E>;
    let mut _17: &LocalResult<T, E>;
    let mut _18: &LocalResult<T, E>;
    let mut _19: &LocalResult<T, E>;
    let mut _20: &LocalResult<T, E>;
    let mut _21: &LocalResult<T, E>;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
            let _11: &T;
            let _12: &T;
            let _13: &E;
            let _14: &E;
            scope 3 {
                debug __self_0 => _11;
                debug __arg1_0 => _12;
            }
            scope 4 {
                debug __self_0 => _13;
                debug __arg1_0 => _14;
            }
            scope 5 {
            }
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _5 = Eq(_3, _4);
        switchInt(move _5) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = const false;
        goto -> bb3;
    }

    bb2: {
        _7 = (_1, _2);
        _15 = deref_copy (_7.0: &LocalResult<T, E>);
        _10 = discriminant((*_15));
        switchInt(move _10) -> [0: bb4, 1: bb6, otherwise: bb5];
    }

    bb3: {
        return;
    }

    bb4: {
        _16 = deref_copy (_7.1: &LocalResult<T, E>);
        _8 = discriminant((*_16));
        switchInt(move _8) -> [0: bb7, otherwise: bb5];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _17 = deref_copy (_7.1: &LocalResult<T, E>);
        _9 = discriminant((*_17));
        switchInt(move _9) -> [1: bb8, otherwise: bb5];
    }

    bb7: {
        _18 = deref_copy (_7.0: &LocalResult<T, E>);
        _11 = &(((*_18) as _Ok).0: T);
        _19 = deref_copy (_7.1: &LocalResult<T, E>);
        _12 = &(((*_19) as _Ok).0: T);
        _6 = <T as PartialEq>::eq(_11, _12) -> bb9;
    }

    bb8: {
        _20 = deref_copy (_7.0: &LocalResult<T, E>);
        _13 = &(((*_20) as Err).0: E);
        _21 = deref_copy (_7.1: &LocalResult<T, E>);
        _14 = &(((*_21) as Err).0: E);
        _6 = <E as PartialEq>::eq(_13, _14) -> bb9;
    }

    bb9: {
        _0 = move _6;
        goto -> bb3;
    }
}

fn <impl at ui/consts/const_constructor/const-construct-call.rs:56:10: 56:15>::fmt(_1: &LocalAssertUnwindSafe<T>, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn std::fmt::Debug;
    let _5: &&T;
    let _6: &T;

    bb0: {
        _3 = const "LocalAssertUnwindSafe";
        _6 = &((*_1).0: T);
        _5 = &_6;
        _4 = _5 as &dyn std::fmt::Debug (Pointer(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/consts/const_constructor/const-construct-call.rs:56:17: 56:26>::eq(_1: &LocalAssertUnwindSafe<T>, _2: &LocalAssertUnwindSafe<T>) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &T;
    let mut _4: &T;

    bb0: {
        _3 = &((*_1).0: T);
        _4 = &((*_2).0: T);
        _0 = <T as PartialEq>::eq(move _3, move _4) -> bb1;
    }

    bb1: {
        return;
    }
}

fn call_local_constructors_in_local_vars() -> LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)> {
    let mut _0: LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>;
    let mut _4: (LocalOption<i32>, LocalResult<i32, bool>);
    let mut _5: LocalOption<i32>;
    let mut _6: LocalResult<i32, bool>;
    scope 1 {
        debug f => LocalOption::<i32>::Some;
        scope 2 {
            debug g => LocalResult::<i32, bool>::Err;
            scope 3 {
                debug h => LocalAssertUnwindSafe::<(LocalOption<i32>, LocalResult<i32, bool>)>;
                let _1: LocalOption<i32>;
                scope 4 {
                    debug x => _1;
                    let _2: LocalResult<i32, bool>;
                    scope 5 {
                        debug y => _2;
                        let _3: LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>;
                        scope 6 {
                            debug z => _3;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _1 = LocalOption::<i32>::Some(const 5_i32) -> bb1;
    }

    bb1: {
        _2 = LocalResult::<i32, bool>::Err(const false) -> bb2;
    }

    bb2: {
        _5 = move _1;
        _6 = move _2;
        _4 = (move _5, move _6);
        _3 = LocalAssertUnwindSafe::<(LocalOption<i32>, LocalResult<i32, bool>)>(move _4) -> bb3;
    }

    bb3: {
        _0 = move _3;
        return;
    }
}

// MIR FOR CTFE
fn call_local_constructors_in_local_vars() -> LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)> {
    let mut _0: LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>;
    let _1: fn(i32) -> LocalOption<i32> {LocalOption::<i32>::Some};
    let mut _5: fn(i32) -> LocalOption<i32> {LocalOption::<i32>::Some};
    let mut _7: fn(bool) -> LocalResult<i32, bool> {LocalResult::<i32, bool>::Err};
    let mut _9: fn((LocalOption<i32>, LocalResult<i32, bool>)) -> LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)> {LocalAssertUnwindSafe::<(LocalOption<i32>, LocalResult<i32, bool>)>};
    let mut _10: (LocalOption<i32>, LocalResult<i32, bool>);
    let mut _11: LocalOption<i32>;
    let mut _12: LocalResult<i32, bool>;
    scope 1 {
        debug f => _1;
        let _2: fn(bool) -> LocalResult<i32, bool> {LocalResult::<i32, bool>::Err};
        scope 2 {
            debug g => _2;
            let _3: fn((LocalOption<i32>, LocalResult<i32, bool>)) -> LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)> {LocalAssertUnwindSafe::<(LocalOption<i32>, LocalResult<i32, bool>)>};
            scope 3 {
                debug h => _3;
                let _4: LocalOption<i32>;
                scope 4 {
                    debug x => _4;
                    let _6: LocalResult<i32, bool>;
                    scope 5 {
                        debug y => _6;
                        let _8: LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>;
                        scope 6 {
                            debug z => _8;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        StorageLive(_1);
        _1 = LocalOption::<i32>::Some;
        StorageLive(_2);
        _2 = LocalResult::<i32, bool>::Err;
        StorageLive(_3);
        _3 = LocalAssertUnwindSafe::<(LocalOption<i32>, LocalResult<i32, bool>)>;
        StorageLive(_4);
        StorageLive(_5);
        _5 = _1;
        ConstEvalCounter;
        _4 = move _5(const 5_i32) -> bb1;
    }

    bb1: {
        StorageDead(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = _2;
        ConstEvalCounter;
        _6 = move _7(const false) -> bb2;
    }

    bb2: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = _3;
        StorageLive(_10);
        StorageLive(_11);
        _11 = move _4;
        StorageLive(_12);
        _12 = move _6;
        _10 = (move _11, move _12);
        StorageDead(_12);
        StorageDead(_11);
        ConstEvalCounter;
        _8 = move _9(move _10) -> bb3;
    }

    bb3: {
        StorageDead(_10);
        StorageDead(_9);
        _0 = move _8;
        StorageDead(_8);
        StorageDead(_6);
        StorageDead(_4);
        StorageDead(_3);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

const CALL_LOCAL_CONSTRUCTORS_IN_LOCAL_VARS: LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)> = {
    let mut _0: LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>;
    let _1: fn(i32) -> LocalOption<i32> {LocalOption::<i32>::Some};
    let mut _5: fn(i32) -> LocalOption<i32> {LocalOption::<i32>::Some};
    let mut _7: fn(bool) -> LocalResult<i32, bool> {LocalResult::<i32, bool>::Err};
    let mut _9: fn((LocalOption<i32>, LocalResult<i32, bool>)) -> LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)> {LocalAssertUnwindSafe::<(LocalOption<i32>, LocalResult<i32, bool>)>};
    let mut _10: (LocalOption<i32>, LocalResult<i32, bool>);
    let mut _11: LocalOption<i32>;
    let mut _12: LocalResult<i32, bool>;
    scope 1 {
        debug f => _1;
        let _2: fn(bool) -> LocalResult<i32, bool> {LocalResult::<i32, bool>::Err};
        scope 2 {
            debug g => _2;
            let _3: fn((LocalOption<i32>, LocalResult<i32, bool>)) -> LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)> {LocalAssertUnwindSafe::<(LocalOption<i32>, LocalResult<i32, bool>)>};
            scope 3 {
                debug h => _3;
                let _4: LocalOption<i32>;
                scope 4 {
                    debug x => _4;
                    let _6: LocalResult<i32, bool>;
                    scope 5 {
                        debug y => _6;
                        let _8: LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>;
                        scope 6 {
                            debug z => _8;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        StorageLive(_1);
        _1 = LocalOption::<i32>::Some;
        StorageLive(_2);
        _2 = LocalResult::<i32, bool>::Err;
        StorageLive(_3);
        _3 = LocalAssertUnwindSafe::<(LocalOption<i32>, LocalResult<i32, bool>)>;
        StorageLive(_4);
        StorageLive(_5);
        _5 = _1;
        ConstEvalCounter;
        _4 = move _5(const 5_i32) -> bb1;
    }

    bb1: {
        StorageDead(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = _2;
        ConstEvalCounter;
        _6 = move _7(const false) -> bb2;
    }

    bb2: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = _3;
        StorageLive(_10);
        StorageLive(_11);
        _11 = move _4;
        StorageLive(_12);
        _12 = move _6;
        _10 = (move _11, move _12);
        StorageDead(_12);
        StorageDead(_11);
        ConstEvalCounter;
        _8 = move _9(move _10) -> bb3;
    }

    bb3: {
        StorageDead(_10);
        StorageDead(_9);
        _0 = move _8;
        StorageDead(_8);
        StorageDead(_6);
        StorageDead(_4);
        StorageDead(_3);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

fn call_local_constructors_in_temps() -> LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)> {
    let mut _0: LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>;
    let _1: LocalOption<i32>;
    let _4: usize;
    let mut _5: usize;
    let mut _6: bool;
    let mut _7: (LocalOption<i32>, LocalResult<i32, bool>);
    let mut _8: LocalOption<i32>;
    let mut _9: LocalResult<i32, bool>;
    scope 1 {
        debug x => _1;
        let _2: LocalResult<i32, bool>;
        scope 2 {
            debug y => _2;
            let _3: LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>;
            scope 3 {
                debug z => _3;
            }
        }
    }

    bb0: {
        _1 = LocalOption::<i32>::Some(const 5_i32) -> bb1;
    }

    bb1: {
        _2 = LocalResult::<i32, bool>::Err(const false) -> bb2;
    }

    bb2: {
        _4 = const 0_usize;
        _5 = const 1_usize;
        _6 = Lt(_4, _5);
        assert(move _6, "index out of bounds: the length is {} but the index is {}", move _5, _4) -> bb3;
    }

    bb3: {
        _8 = move _1;
        _9 = move _2;
        _7 = (move _8, move _9);
        _3 = LocalAssertUnwindSafe::<(LocalOption<i32>, LocalResult<i32, bool>)>(move _7) -> bb4;
    }

    bb4: {
        _0 = move _3;
        return;
    }
}

// MIR FOR CTFE
fn call_local_constructors_in_temps() -> LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)> {
    let mut _0: LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>;
    let _1: LocalOption<i32>;
    let mut _2: fn(i32) -> LocalOption<i32> {LocalOption::<i32>::Some};
    let mut _4: fn(bool) -> LocalResult<i32, bool> {LocalResult::<i32, bool>::Err};
    let mut _5: &fn(bool) -> LocalResult<i32, bool> {LocalResult::<i32, bool>::Err};
    let _6: fn(bool) -> LocalResult<i32, bool> {LocalResult::<i32, bool>::Err};
    let mut _8: fn((LocalOption<i32>, LocalResult<i32, bool>)) -> LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)> {LocalAssertUnwindSafe::<(LocalOption<i32>, LocalResult<i32, bool>)>};
    let mut _9: [fn((LocalOption<i32>, LocalResult<i32, bool>)) -> LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)> {LocalAssertUnwindSafe::<(LocalOption<i32>, LocalResult<i32, bool>)>}; 1];
    let _10: usize;
    let mut _11: usize;
    let mut _12: bool;
    let mut _13: (LocalOption<i32>, LocalResult<i32, bool>);
    let mut _14: LocalOption<i32>;
    let mut _15: LocalResult<i32, bool>;
    scope 1 {
        debug x => _1;
        let _3: LocalResult<i32, bool>;
        scope 2 {
            debug y => _3;
            let _7: LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>;
            scope 3 {
                debug z => _7;
            }
        }
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _2 = LocalOption::<i32>::Some;
        ConstEvalCounter;
        _1 = move _2(const 5_i32) -> bb1;
    }

    bb1: {
        StorageDead(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        _6 = LocalResult::<i32, bool>::Err;
        _5 = &_6;
        _4 = (*_5);
        ConstEvalCounter;
        _3 = move _4(const false) -> bb2;
    }

    bb2: {
        StorageDead(_4);
        StorageDead(_6);
        StorageDead(_5);
        StorageLive(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = [LocalAssertUnwindSafe::<(LocalOption<i32>, LocalResult<i32, bool>)>];
        StorageLive(_10);
        _10 = const 0_usize;
        _11 = Len(_9);
        _12 = Lt(_10, _11);
        assert(move _12, "index out of bounds: the length is {} but the index is {}", move _11, _10) -> bb3;
    }

    bb3: {
        _8 = _9[_10];
        StorageLive(_13);
        StorageLive(_14);
        _14 = move _1;
        StorageLive(_15);
        _15 = move _3;
        _13 = (move _14, move _15);
        StorageDead(_15);
        StorageDead(_14);
        ConstEvalCounter;
        _7 = move _8(move _13) -> bb4;
    }

    bb4: {
        StorageDead(_13);
        StorageDead(_8);
        StorageDead(_10);
        StorageDead(_9);
        _0 = move _7;
        StorageDead(_7);
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

const CALL_LOCAL_CONSTRUCTORS_IN_TEMPS: LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)> = {
    let mut _0: LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>;
    let _1: LocalOption<i32>;
    let mut _2: fn(i32) -> LocalOption<i32> {LocalOption::<i32>::Some};
    let mut _4: fn(bool) -> LocalResult<i32, bool> {LocalResult::<i32, bool>::Err};
    let mut _5: &fn(bool) -> LocalResult<i32, bool> {LocalResult::<i32, bool>::Err};
    let _6: fn(bool) -> LocalResult<i32, bool> {LocalResult::<i32, bool>::Err};
    let mut _8: fn((LocalOption<i32>, LocalResult<i32, bool>)) -> LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)> {LocalAssertUnwindSafe::<(LocalOption<i32>, LocalResult<i32, bool>)>};
    let mut _9: [fn((LocalOption<i32>, LocalResult<i32, bool>)) -> LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)> {LocalAssertUnwindSafe::<(LocalOption<i32>, LocalResult<i32, bool>)>}; 1];
    let _10: usize;
    let mut _11: usize;
    let mut _12: bool;
    let mut _13: (LocalOption<i32>, LocalResult<i32, bool>);
    let mut _14: LocalOption<i32>;
    let mut _15: LocalResult<i32, bool>;
    scope 1 {
        debug x => _1;
        let _3: LocalResult<i32, bool>;
        scope 2 {
            debug y => _3;
            let _7: LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>;
            scope 3 {
                debug z => _7;
            }
        }
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _2 = LocalOption::<i32>::Some;
        ConstEvalCounter;
        _1 = move _2(const 5_i32) -> bb1;
    }

    bb1: {
        StorageDead(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        _6 = LocalResult::<i32, bool>::Err;
        _5 = &_6;
        _4 = (*_5);
        ConstEvalCounter;
        _3 = move _4(const false) -> bb2;
    }

    bb2: {
        StorageDead(_4);
        StorageDead(_6);
        StorageDead(_5);
        StorageLive(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = [LocalAssertUnwindSafe::<(LocalOption<i32>, LocalResult<i32, bool>)>];
        StorageLive(_10);
        _10 = const 0_usize;
        _11 = Len(_9);
        _12 = Lt(_10, _11);
        assert(move _12, "index out of bounds: the length is {} but the index is {}", move _11, _10) -> bb3;
    }

    bb3: {
        _8 = _9[_10];
        StorageLive(_13);
        StorageLive(_14);
        _14 = move _1;
        StorageLive(_15);
        _15 = move _3;
        _13 = (move _14, move _15);
        StorageDead(_15);
        StorageDead(_14);
        ConstEvalCounter;
        _7 = move _8(move _13) -> bb4;
    }

    bb4: {
        StorageDead(_13);
        StorageDead(_8);
        StorageDead(_10);
        StorageDead(_9);
        _0 = move _7;
        StorageDead(_7);
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let mut _1: (&((std::option::Option<i32>, std::result::Result<i32, bool>), (std::option::Option<i32>, std::result::Result<i32, bool>), LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>, LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>), &((std::option::Option<i32>, std::result::Result<i32, bool>), (std::option::Option<i32>, std::result::Result<i32, bool>), LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>, LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>));
    let mut _2: &((std::option::Option<i32>, std::result::Result<i32, bool>), (std::option::Option<i32>, std::result::Result<i32, bool>), LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>, LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>);
    let _3: ((std::option::Option<i32>, std::result::Result<i32, bool>), (std::option::Option<i32>, std::result::Result<i32, bool>), LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>, LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>);
    let mut _4: (std::option::Option<i32>, std::result::Result<i32, bool>);
    let mut _5: std::panic::AssertUnwindSafe<(std::option::Option<i32>, std::result::Result<i32, bool>)>;
    let mut _6: (std::option::Option<i32>, std::result::Result<i32, bool>);
    let mut _7: std::panic::AssertUnwindSafe<(std::option::Option<i32>, std::result::Result<i32, bool>)>;
    let mut _8: LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>;
    let mut _9: LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>;
    let mut _10: &((std::option::Option<i32>, std::result::Result<i32, bool>), (std::option::Option<i32>, std::result::Result<i32, bool>), LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>, LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>);
    let _11: ((std::option::Option<i32>, std::result::Result<i32, bool>), (std::option::Option<i32>, std::result::Result<i32, bool>), LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>, LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>);
    let mut _12: (std::option::Option<i32>, std::result::Result<i32, bool>);
    let mut _13: std::panic::AssertUnwindSafe<(std::option::Option<i32>, std::result::Result<i32, bool>)>;
    let mut _14: (std::option::Option<i32>, std::result::Result<i32, bool>);
    let mut _15: std::panic::AssertUnwindSafe<(std::option::Option<i32>, std::result::Result<i32, bool>)>;
    let _16: &((std::option::Option<i32>, std::result::Result<i32, bool>), (std::option::Option<i32>, std::result::Result<i32, bool>), LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>, LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>);
    let _17: &((std::option::Option<i32>, std::result::Result<i32, bool>), (std::option::Option<i32>, std::result::Result<i32, bool>), LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>, LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>);
    let mut _18: bool;
    let mut _19: bool;
    let _21: !;
    let mut _22: std::option::Option<std::fmt::Arguments<'_>>;
    scope 1 {
        debug left_val => _16;
        debug right_val => _17;
        let _20: core::panicking::AssertKind;
        scope 2 {
            debug kind => _20;
        }
    }

    bb0: {
        _5 = call_external_constructors_in_local_vars() -> bb1;
    }

    bb1: {
        _4 = (_5.0: (std::option::Option<i32>, std::result::Result<i32, bool>));
        _7 = call_external_constructors_in_temps() -> bb2;
    }

    bb2: {
        _6 = (_7.0: (std::option::Option<i32>, std::result::Result<i32, bool>));
        _8 = call_local_constructors_in_local_vars() -> bb3;
    }

    bb3: {
        _9 = call_local_constructors_in_temps() -> bb4;
    }

    bb4: {
        _3 = (move _4, move _6, move _8, move _9);
        _2 = &_3;
        _13 = const _;
        _12 = (_13.0: (std::option::Option<i32>, std::result::Result<i32, bool>));
        _15 = const _;
        _14 = (_15.0: (std::option::Option<i32>, std::result::Result<i32, bool>));
        _11 = (move _12, move _14, const _, const _);
        _10 = &_11;
        _1 = (move _2, move _10);
        _16 = (_1.0: &((std::option::Option<i32>, std::result::Result<i32, bool>), (std::option::Option<i32>, std::result::Result<i32, bool>), LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>, LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>));
        _17 = (_1.1: &((std::option::Option<i32>, std::result::Result<i32, bool>), (std::option::Option<i32>, std::result::Result<i32, bool>), LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>, LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>));
        _19 = <((Option<i32>, Result<i32, bool>), (Option<i32>, Result<i32, bool>), LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>, LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>) as PartialEq>::eq(_16, _17) -> bb5;
    }

    bb5: {
        _18 = Not(move _19);
        switchInt(move _18) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _20 = core::panicking::AssertKind::Eq;
        _22 = Option::<Arguments<'_>>::None;
        _21 = core::panicking::assert_failed::<((Option<i32>, Result<i32, bool>), (Option<i32>, Result<i32, bool>), LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>, LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>), ((Option<i32>, Result<i32, bool>), (Option<i32>, Result<i32, bool>), LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>, LocalAssertUnwindSafe<(LocalOption<i32>, LocalResult<i32, bool>)>)>(move _20, _16, _17, move _22);
    }

    bb7: {
        return;
    }
}

fn LocalOption::Some(_1: T) -> LocalOption<T> {
    let mut _0: LocalOption<T>;

    bb0: {
        _0 = LocalOption::<T>::Some(move _1);
        return;
    }
}

// MIR FOR CTFE
fn LocalOption::Some(_1: T) -> LocalOption<T> {
    let mut _0: LocalOption<T>;

    bb0: {
        _0 = LocalOption::<T>::Some(move _1);
        return;
    }
}

fn LocalResult::_Ok(_1: T) -> LocalResult<T, E> {
    let mut _0: LocalResult<T, E>;

    bb0: {
        _0 = LocalResult::<T, E>::_Ok(move _1);
        return;
    }
}

// MIR FOR CTFE
fn LocalResult::_Ok(_1: T) -> LocalResult<T, E> {
    let mut _0: LocalResult<T, E>;

    bb0: {
        _0 = LocalResult::<T, E>::_Ok(move _1);
        return;
    }
}

fn LocalResult::Err(_1: E) -> LocalResult<T, E> {
    let mut _0: LocalResult<T, E>;

    bb0: {
        _0 = LocalResult::<T, E>::Err(move _1);
        return;
    }
}

// MIR FOR CTFE
fn LocalResult::Err(_1: E) -> LocalResult<T, E> {
    let mut _0: LocalResult<T, E>;

    bb0: {
        _0 = LocalResult::<T, E>::Err(move _1);
        return;
    }
}

fn LocalAssertUnwindSafe(_1: T) -> LocalAssertUnwindSafe<T> {
    let mut _0: LocalAssertUnwindSafe<T>;

    bb0: {
        _0 = LocalAssertUnwindSafe::<T>(move _1);
        return;
    }
}

// MIR FOR CTFE
fn LocalAssertUnwindSafe(_1: T) -> LocalAssertUnwindSafe<T> {
    let mut _0: LocalAssertUnwindSafe<T>;

    bb0: {
        _0 = LocalAssertUnwindSafe::<T>(move _1);
        return;
    }
}
