// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn basics(_1: (u32,)) -> u32 {
    let mut _0: u32;
    let _2: u32;
    let mut _6: u32;
    let _8: usize;
    let mut _9: usize;
    let mut _10: bool;
    let mut _11: u32;
    let mut _12: u32;
    let _13: usize;
    let mut _14: usize;
    let mut _15: bool;
    let mut _18: u32;
    let mut _19: u32;
    let mut _20: u32;
    let mut _21: u32;
    let mut _23: Foo<u32>;
    let _24: usize;
    let mut _25: usize;
    let mut _26: bool;
    let mut _27: u32;
    let mut _28: u32;
    let _29: usize;
    let mut _30: usize;
    let mut _31: bool;
    let mut _33: Bar<u32>;
    let _34: usize;
    let mut _35: usize;
    let mut _36: bool;
    let mut _37: u32;
    let mut _38: u32;
    let _39: usize;
    let mut _40: usize;
    let mut _41: bool;
    let mut _43: [u32; 1];
    let _44: usize;
    let mut _45: usize;
    let mut _46: bool;
    let mut _47: u32;
    let mut _48: u32;
    let _49: usize;
    let mut _50: usize;
    let mut _51: bool;
    let mut _53: [u32; 1];
    let _54: usize;
    let mut _55: usize;
    let mut _56: bool;
    let mut _57: u32;
    let mut _58: u32;
    let _59: usize;
    let mut _60: usize;
    let mut _61: bool;
    scope 1 {
        debug a => _2;
        let _3: u32;
        scope 2 {
            debug b => _3;
            let _4: u32;
            scope 3 {
                debug c => _4;
                let mut _5: u32;
                scope 4 {
                    debug d => _5;
                    let mut _7: [u32; 1];
                    scope 5 {
                        debug arr => _7;
                        let mut _16: Foo<u32>;
                        scope 6 {
                            debug foo => _16;
                            let mut _17: Bar<u32>;
                            scope 7 {
                                debug bar => _17;
                                let mut _22: [Foo<u32>; 1];
                                scope 8 {
                                    debug arr => _22;
                                    let mut _32: [Bar<u32>; 1];
                                    scope 9 {
                                        debug arr => _32;
                                        let mut _42: Foo<[u32; 1]>;
                                        scope 10 {
                                            debug arr => _42;
                                            let mut _52: Bar<[u32; 1]>;
                                            scope 11 {
                                                debug arr => _52;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = (_1.0: u32);
        _3 = Add(_2, const 1_u32);
        _4 = Add(_3, const 1_u32);
        _5 = Add(_4, const 1_u32);
        _6 = _5;
        _5 = Add(move _6, const 1_u32);
        _7 = [const 0_u32];
        _8 = const 0_usize;
        _9 = const 1_usize;
        _10 = Lt(_8, _9);
        assert(move _10, "index out of bounds: the length is {} but the index is {}", move _9, _8) -> bb1;
    }

    bb1: {
        _7[_8] = const 1_u32;
        _11 = _5;
        _13 = const 0_usize;
        _14 = const 1_usize;
        _15 = Lt(_13, _14);
        assert(move _15, "index out of bounds: the length is {} but the index is {}", move _14, _13) -> bb2;
    }

    bb2: {
        _12 = _7[_13];
        _5 = Add(move _11, move _12);
        _16 = Foo::<u32>(const 0_u32);
        _17 = Bar::<u32> { x: const 0_u32 };
        (_16.0: u32) = const 1_u32;
        (_17.0: u32) = const 1_u32;
        _19 = _5;
        _20 = (_16.0: u32);
        _18 = Add(move _19, move _20);
        _21 = (_17.0: u32);
        _5 = Add(move _18, move _21);
        _23 = Foo::<u32>(const 0_u32);
        _22 = [move _23];
        _24 = const 0_usize;
        _25 = const 1_usize;
        _26 = Lt(_24, _25);
        assert(move _26, "index out of bounds: the length is {} but the index is {}", move _25, _24) -> bb3;
    }

    bb3: {
        (_22[_24].0: u32) = const 1_u32;
        _27 = _5;
        _29 = const 0_usize;
        _30 = const 1_usize;
        _31 = Lt(_29, _30);
        assert(move _31, "index out of bounds: the length is {} but the index is {}", move _30, _29) -> bb4;
    }

    bb4: {
        _28 = (_22[_29].0: u32);
        _5 = Add(move _27, move _28);
        _33 = Bar::<u32> { x: const 0_u32 };
        _32 = [move _33];
        _34 = const 0_usize;
        _35 = const 1_usize;
        _36 = Lt(_34, _35);
        assert(move _36, "index out of bounds: the length is {} but the index is {}", move _35, _34) -> bb5;
    }

    bb5: {
        (_32[_34].0: u32) = const 1_u32;
        _37 = _5;
        _39 = const 0_usize;
        _40 = const 1_usize;
        _41 = Lt(_39, _40);
        assert(move _41, "index out of bounds: the length is {} but the index is {}", move _40, _39) -> bb6;
    }

    bb6: {
        _38 = (_32[_39].0: u32);
        _5 = Add(move _37, move _38);
        _43 = [const 0_u32];
        _42 = Foo::<[u32; 1]>(move _43);
        _44 = const 0_usize;
        _45 = const 1_usize;
        _46 = Lt(_44, _45);
        assert(move _46, "index out of bounds: the length is {} but the index is {}", move _45, _44) -> bb7;
    }

    bb7: {
        (_42.0: [u32; 1])[_44] = const 1_u32;
        _47 = _5;
        _49 = const 0_usize;
        _50 = const 1_usize;
        _51 = Lt(_49, _50);
        assert(move _51, "index out of bounds: the length is {} but the index is {}", move _50, _49) -> bb8;
    }

    bb8: {
        _48 = (_42.0: [u32; 1])[_49];
        _5 = Add(move _47, move _48);
        _53 = [const 0_u32];
        _52 = Bar::<[u32; 1]> { x: move _53 };
        _54 = const 0_usize;
        _55 = const 1_usize;
        _56 = Lt(_54, _55);
        assert(move _56, "index out of bounds: the length is {} but the index is {}", move _55, _54) -> bb9;
    }

    bb9: {
        (_52.0: [u32; 1])[_54] = const 1_u32;
        _57 = _5;
        _59 = const 0_usize;
        _60 = const 1_usize;
        _61 = Lt(_59, _60);
        assert(move _61, "index out of bounds: the length is {} but the index is {}", move _60, _59) -> bb10;
    }

    bb10: {
        _58 = (_52.0: [u32; 1])[_59];
        _5 = Add(move _57, move _58);
        _0 = _5;
        return;
    }
}

// MIR FOR CTFE
fn basics(_1: (u32,)) -> u32 {
    let mut _0: u32;
    let _2: u32;
    let mut _4: u32;
    let mut _6: u32;
    let mut _8: u32;
    let mut _9: u32;
    let _10: i32;
    let _12: usize;
    let mut _13: usize;
    let mut _14: bool;
    let mut _15: u32;
    let mut _16: u32;
    let _17: usize;
    let mut _18: usize;
    let mut _19: bool;
    let mut _22: u32;
    let mut _23: u32;
    let mut _24: u32;
    let mut _25: u32;
    let mut _27: Foo<u32>;
    let _28: usize;
    let mut _29: usize;
    let mut _30: bool;
    let mut _31: u32;
    let mut _32: u32;
    let _33: usize;
    let mut _34: usize;
    let mut _35: bool;
    let mut _37: Bar<u32>;
    let _38: usize;
    let mut _39: usize;
    let mut _40: bool;
    let mut _41: u32;
    let mut _42: u32;
    let _43: usize;
    let mut _44: usize;
    let mut _45: bool;
    let mut _47: [u32; 1];
    let _48: usize;
    let mut _49: usize;
    let mut _50: bool;
    let mut _51: u32;
    let mut _52: u32;
    let _53: usize;
    let mut _54: usize;
    let mut _55: bool;
    let mut _57: [u32; 1];
    let _58: usize;
    let mut _59: usize;
    let mut _60: bool;
    let mut _61: u32;
    let mut _62: u32;
    let _63: usize;
    let mut _64: usize;
    let mut _65: bool;
    scope 1 {
        debug a => _2;
        let _3: u32;
        scope 2 {
            debug b => _3;
            let _5: u32;
            scope 3 {
                debug c => _5;
                let mut _7: u32;
                scope 4 {
                    debug d => _7;
                    let mut _11: [u32; 1];
                    scope 5 {
                        debug arr => _11;
                        let mut _20: Foo<u32>;
                        scope 6 {
                            debug foo => _20;
                            let mut _21: Bar<u32>;
                            scope 7 {
                                debug bar => _21;
                                let mut _26: [Foo<u32>; 1];
                                scope 8 {
                                    debug arr => _26;
                                    let mut _36: [Bar<u32>; 1];
                                    scope 9 {
                                        debug arr => _36;
                                        let mut _46: Foo<[u32; 1]>;
                                        scope 10 {
                                            debug arr => _46;
                                            let mut _56: Bar<[u32; 1]>;
                                            scope 11 {
                                                debug arr => _56;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        StorageLive(_2);
        _2 = (_1.0: u32);
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        _3 = Add(move _4, const 1_u32);
        StorageDead(_4);
        StorageLive(_5);
        StorageLive(_6);
        _6 = _3;
        _5 = Add(move _6, const 1_u32);
        StorageDead(_6);
        StorageLive(_7);
        StorageLive(_8);
        _8 = _5;
        _7 = Add(move _8, const 1_u32);
        StorageDead(_8);
        StorageLive(_9);
        _9 = _7;
        _7 = Add(move _9, const 1_u32);
        StorageDead(_9);
        StorageLive(_10);
        _10 = const 1_i32;
        StorageDead(_10);
        StorageLive(_11);
        _11 = [const 0_u32];
        StorageLive(_12);
        _12 = const 0_usize;
        _13 = Len(_11);
        _14 = Lt(_12, _13);
        assert(move _14, "index out of bounds: the length is {} but the index is {}", move _13, _12) -> bb1;
    }

    bb1: {
        _11[_12] = const 1_u32;
        StorageDead(_12);
        StorageLive(_15);
        _15 = _7;
        StorageLive(_16);
        StorageLive(_17);
        _17 = const 0_usize;
        _18 = Len(_11);
        _19 = Lt(_17, _18);
        assert(move _19, "index out of bounds: the length is {} but the index is {}", move _18, _17) -> bb2;
    }

    bb2: {
        _16 = _11[_17];
        _7 = Add(move _15, move _16);
        StorageDead(_16);
        StorageDead(_15);
        StorageDead(_17);
        StorageLive(_20);
        _20 = Foo::<u32>(const 0_u32);
        StorageLive(_21);
        _21 = Bar::<u32> { x: const 0_u32 };
        (_20.0: u32) = const 1_u32;
        (_21.0: u32) = const 1_u32;
        StorageLive(_22);
        StorageLive(_23);
        _23 = _7;
        StorageLive(_24);
        _24 = (_20.0: u32);
        _22 = Add(move _23, move _24);
        StorageDead(_24);
        StorageDead(_23);
        StorageLive(_25);
        _25 = (_21.0: u32);
        _7 = Add(move _22, move _25);
        StorageDead(_25);
        StorageDead(_22);
        StorageLive(_26);
        StorageLive(_27);
        _27 = Foo::<u32>(const 0_u32);
        _26 = [move _27];
        StorageDead(_27);
        StorageLive(_28);
        _28 = const 0_usize;
        _29 = Len(_26);
        _30 = Lt(_28, _29);
        assert(move _30, "index out of bounds: the length is {} but the index is {}", move _29, _28) -> bb3;
    }

    bb3: {
        (_26[_28].0: u32) = const 1_u32;
        StorageDead(_28);
        StorageLive(_31);
        _31 = _7;
        StorageLive(_32);
        StorageLive(_33);
        _33 = const 0_usize;
        _34 = Len(_26);
        _35 = Lt(_33, _34);
        assert(move _35, "index out of bounds: the length is {} but the index is {}", move _34, _33) -> bb4;
    }

    bb4: {
        _32 = (_26[_33].0: u32);
        _7 = Add(move _31, move _32);
        StorageDead(_32);
        StorageDead(_31);
        StorageDead(_33);
        StorageLive(_36);
        StorageLive(_37);
        _37 = Bar::<u32> { x: const 0_u32 };
        _36 = [move _37];
        StorageDead(_37);
        StorageLive(_38);
        _38 = const 0_usize;
        _39 = Len(_36);
        _40 = Lt(_38, _39);
        assert(move _40, "index out of bounds: the length is {} but the index is {}", move _39, _38) -> bb5;
    }

    bb5: {
        (_36[_38].0: u32) = const 1_u32;
        StorageDead(_38);
        StorageLive(_41);
        _41 = _7;
        StorageLive(_42);
        StorageLive(_43);
        _43 = const 0_usize;
        _44 = Len(_36);
        _45 = Lt(_43, _44);
        assert(move _45, "index out of bounds: the length is {} but the index is {}", move _44, _43) -> bb6;
    }

    bb6: {
        _42 = (_36[_43].0: u32);
        _7 = Add(move _41, move _42);
        StorageDead(_42);
        StorageDead(_41);
        StorageDead(_43);
        StorageLive(_46);
        StorageLive(_47);
        _47 = [const 0_u32];
        _46 = Foo::<[u32; 1]>(move _47);
        StorageDead(_47);
        StorageLive(_48);
        _48 = const 0_usize;
        _49 = Len((_46.0: [u32; 1]));
        _50 = Lt(_48, _49);
        assert(move _50, "index out of bounds: the length is {} but the index is {}", move _49, _48) -> bb7;
    }

    bb7: {
        (_46.0: [u32; 1])[_48] = const 1_u32;
        StorageDead(_48);
        StorageLive(_51);
        _51 = _7;
        StorageLive(_52);
        StorageLive(_53);
        _53 = const 0_usize;
        _54 = Len((_46.0: [u32; 1]));
        _55 = Lt(_53, _54);
        assert(move _55, "index out of bounds: the length is {} but the index is {}", move _54, _53) -> bb8;
    }

    bb8: {
        _52 = (_46.0: [u32; 1])[_53];
        _7 = Add(move _51, move _52);
        StorageDead(_52);
        StorageDead(_51);
        StorageDead(_53);
        StorageLive(_56);
        StorageLive(_57);
        _57 = [const 0_u32];
        _56 = Bar::<[u32; 1]> { x: move _57 };
        StorageDead(_57);
        StorageLive(_58);
        _58 = const 0_usize;
        _59 = Len((_56.0: [u32; 1]));
        _60 = Lt(_58, _59);
        assert(move _60, "index out of bounds: the length is {} but the index is {}", move _59, _58) -> bb9;
    }

    bb9: {
        (_56.0: [u32; 1])[_58] = const 1_u32;
        StorageDead(_58);
        StorageLive(_61);
        _61 = _7;
        StorageLive(_62);
        StorageLive(_63);
        _63 = const 0_usize;
        _64 = Len((_56.0: [u32; 1]));
        _65 = Lt(_63, _64);
        assert(move _65, "index out of bounds: the length is {} but the index is {}", move _64, _63) -> bb10;
    }

    bb10: {
        _62 = (_56.0: [u32; 1])[_63];
        _7 = Add(move _61, move _62);
        StorageDead(_62);
        StorageDead(_61);
        StorageDead(_63);
        _0 = _7;
        StorageDead(_56);
        StorageDead(_46);
        StorageDead(_36);
        StorageDead(_26);
        StorageDead(_21);
        StorageDead(_20);
        StorageDead(_11);
        StorageDead(_7);
        StorageDead(_5);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

basics::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

basics::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

basics::{constant#2}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

basics::{constant#3}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

basics::{constant#4}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

fn add_assign(_1: W) -> u32 {
    let mut _0: u32;
    let _2: u32;
    let _5: usize;
    let mut _6: usize;
    let mut _7: bool;
    let mut _8: u32;
    let _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _14: u32;
    let mut _15: u32;
    let mut _16: u32;
    let mut _18: Foo<u32>;
    let _19: usize;
    let mut _20: usize;
    let mut _21: bool;
    let mut _22: u32;
    let _23: usize;
    let mut _24: usize;
    let mut _25: bool;
    let mut _27: Bar<u32>;
    let _28: usize;
    let mut _29: usize;
    let mut _30: bool;
    let mut _31: u32;
    let _32: usize;
    let mut _33: usize;
    let mut _34: bool;
    let mut _36: [u32; 1];
    let _37: usize;
    let mut _38: usize;
    let mut _39: bool;
    let mut _40: u32;
    let _41: usize;
    let mut _42: usize;
    let mut _43: bool;
    let mut _45: [u32; 1];
    let _46: usize;
    let mut _47: usize;
    let mut _48: bool;
    let mut _49: u32;
    let _50: usize;
    let mut _51: usize;
    let mut _52: bool;
    scope 1 {
        debug a => _2;
        let mut _3: u32;
        scope 2 {
            debug d => _3;
            let mut _4: [u32; 1];
            scope 3 {
                debug arr => _4;
                let mut _12: Foo<u32>;
                scope 4 {
                    debug foo => _12;
                    let mut _13: Bar<u32>;
                    scope 5 {
                        debug bar => _13;
                        let mut _17: [Foo<u32>; 1];
                        scope 6 {
                            debug arr => _17;
                            let mut _26: [Bar<u32>; 1];
                            scope 7 {
                                debug arr => _26;
                                let mut _35: Foo<[u32; 1]>;
                                scope 8 {
                                    debug arr => _35;
                                    let mut _44: Bar<[u32; 1]>;
                                    scope 9 {
                                        debug arr => _44;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = (_1.0: u32);
        _3 = Add(_2, const 1_u32);
        _3 = Add(_3, const 1_u32);
        _4 = [const 0_u32];
        _5 = const 0_usize;
        _6 = const 1_usize;
        _7 = Lt(_5, _6);
        assert(move _7, "index out of bounds: the length is {} but the index is {}", move _6, _5) -> bb1;
    }

    bb1: {
        _4[_5] = Add(_4[_5], const 1_u32);
        _9 = const 0_usize;
        _10 = const 1_usize;
        _11 = Lt(_9, _10);
        assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _9) -> bb2;
    }

    bb2: {
        _8 = _4[_9];
        _3 = Add(_3, move _8);
        _12 = Foo::<u32>(const 0_u32);
        _13 = Bar::<u32> { x: const 0_u32 };
        (_12.0: u32) = Add((_12.0: u32), const 1_u32);
        (_13.0: u32) = Add((_13.0: u32), const 1_u32);
        _15 = (_12.0: u32);
        _16 = (_13.0: u32);
        _14 = Add(move _15, move _16);
        _3 = Add(_3, move _14);
        _18 = Foo::<u32>(const 0_u32);
        _17 = [move _18];
        _19 = const 0_usize;
        _20 = const 1_usize;
        _21 = Lt(_19, _20);
        assert(move _21, "index out of bounds: the length is {} but the index is {}", move _20, _19) -> bb3;
    }

    bb3: {
        (_17[_19].0: u32) = Add((_17[_19].0: u32), const 1_u32);
        _23 = const 0_usize;
        _24 = const 1_usize;
        _25 = Lt(_23, _24);
        assert(move _25, "index out of bounds: the length is {} but the index is {}", move _24, _23) -> bb4;
    }

    bb4: {
        _22 = (_17[_23].0: u32);
        _3 = Add(_3, move _22);
        _27 = Bar::<u32> { x: const 0_u32 };
        _26 = [move _27];
        _28 = const 0_usize;
        _29 = const 1_usize;
        _30 = Lt(_28, _29);
        assert(move _30, "index out of bounds: the length is {} but the index is {}", move _29, _28) -> bb5;
    }

    bb5: {
        (_26[_28].0: u32) = Add((_26[_28].0: u32), const 1_u32);
        _32 = const 0_usize;
        _33 = const 1_usize;
        _34 = Lt(_32, _33);
        assert(move _34, "index out of bounds: the length is {} but the index is {}", move _33, _32) -> bb6;
    }

    bb6: {
        _31 = (_26[_32].0: u32);
        _3 = Add(_3, move _31);
        _36 = [const 0_u32];
        _35 = Foo::<[u32; 1]>(move _36);
        _37 = const 0_usize;
        _38 = const 1_usize;
        _39 = Lt(_37, _38);
        assert(move _39, "index out of bounds: the length is {} but the index is {}", move _38, _37) -> bb7;
    }

    bb7: {
        (_35.0: [u32; 1])[_37] = Add((_35.0: [u32; 1])[_37], const 1_u32);
        _41 = const 0_usize;
        _42 = const 1_usize;
        _43 = Lt(_41, _42);
        assert(move _43, "index out of bounds: the length is {} but the index is {}", move _42, _41) -> bb8;
    }

    bb8: {
        _40 = (_35.0: [u32; 1])[_41];
        _3 = Add(_3, move _40);
        _45 = [const 0_u32];
        _44 = Bar::<[u32; 1]> { x: move _45 };
        _46 = const 0_usize;
        _47 = const 1_usize;
        _48 = Lt(_46, _47);
        assert(move _48, "index out of bounds: the length is {} but the index is {}", move _47, _46) -> bb9;
    }

    bb9: {
        (_44.0: [u32; 1])[_46] = Add((_44.0: [u32; 1])[_46], const 1_u32);
        _50 = const 0_usize;
        _51 = const 1_usize;
        _52 = Lt(_50, _51);
        assert(move _52, "index out of bounds: the length is {} but the index is {}", move _51, _50) -> bb10;
    }

    bb10: {
        _49 = (_44.0: [u32; 1])[_50];
        _3 = Add(_3, move _49);
        _0 = _3;
        return;
    }
}

// MIR FOR CTFE
fn add_assign(_1: W) -> u32 {
    let mut _0: u32;
    let _2: u32;
    let mut _4: u32;
    let _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let mut _9: u32;
    let _10: usize;
    let mut _11: usize;
    let mut _12: bool;
    let mut _15: u32;
    let mut _16: u32;
    let mut _17: u32;
    let mut _19: Foo<u32>;
    let _20: usize;
    let mut _21: usize;
    let mut _22: bool;
    let mut _23: u32;
    let _24: usize;
    let mut _25: usize;
    let mut _26: bool;
    let mut _28: Bar<u32>;
    let _29: usize;
    let mut _30: usize;
    let mut _31: bool;
    let mut _32: u32;
    let _33: usize;
    let mut _34: usize;
    let mut _35: bool;
    let mut _37: [u32; 1];
    let _38: usize;
    let mut _39: usize;
    let mut _40: bool;
    let mut _41: u32;
    let _42: usize;
    let mut _43: usize;
    let mut _44: bool;
    let mut _46: [u32; 1];
    let _47: usize;
    let mut _48: usize;
    let mut _49: bool;
    let mut _50: u32;
    let _51: usize;
    let mut _52: usize;
    let mut _53: bool;
    scope 1 {
        debug a => _2;
        let mut _3: u32;
        scope 2 {
            debug d => _3;
            let mut _5: [u32; 1];
            scope 3 {
                debug arr => _5;
                let mut _13: Foo<u32>;
                scope 4 {
                    debug foo => _13;
                    let mut _14: Bar<u32>;
                    scope 5 {
                        debug bar => _14;
                        let mut _18: [Foo<u32>; 1];
                        scope 6 {
                            debug arr => _18;
                            let mut _27: [Bar<u32>; 1];
                            scope 7 {
                                debug arr => _27;
                                let mut _36: Foo<[u32; 1]>;
                                scope 8 {
                                    debug arr => _36;
                                    let mut _45: Bar<[u32; 1]>;
                                    scope 9 {
                                        debug arr => _45;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        StorageLive(_2);
        _2 = (_1.0: u32);
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        _3 = Add(move _4, const 1_u32);
        StorageDead(_4);
        _3 = Add(_3, const 1_u32);
        StorageLive(_5);
        _5 = [const 0_u32];
        StorageLive(_6);
        _6 = const 0_usize;
        _7 = Len(_5);
        _8 = Lt(_6, _7);
        assert(move _8, "index out of bounds: the length is {} but the index is {}", move _7, _6) -> bb1;
    }

    bb1: {
        _5[_6] = Add(_5[_6], const 1_u32);
        StorageDead(_6);
        StorageLive(_9);
        StorageLive(_10);
        _10 = const 0_usize;
        _11 = Len(_5);
        _12 = Lt(_10, _11);
        assert(move _12, "index out of bounds: the length is {} but the index is {}", move _11, _10) -> bb2;
    }

    bb2: {
        _9 = _5[_10];
        _3 = Add(_3, move _9);
        StorageDead(_9);
        StorageDead(_10);
        StorageLive(_13);
        _13 = Foo::<u32>(const 0_u32);
        StorageLive(_14);
        _14 = Bar::<u32> { x: const 0_u32 };
        (_13.0: u32) = Add((_13.0: u32), const 1_u32);
        (_14.0: u32) = Add((_14.0: u32), const 1_u32);
        StorageLive(_15);
        StorageLive(_16);
        _16 = (_13.0: u32);
        StorageLive(_17);
        _17 = (_14.0: u32);
        _15 = Add(move _16, move _17);
        StorageDead(_17);
        StorageDead(_16);
        _3 = Add(_3, move _15);
        StorageDead(_15);
        StorageLive(_18);
        StorageLive(_19);
        _19 = Foo::<u32>(const 0_u32);
        _18 = [move _19];
        StorageDead(_19);
        StorageLive(_20);
        _20 = const 0_usize;
        _21 = Len(_18);
        _22 = Lt(_20, _21);
        assert(move _22, "index out of bounds: the length is {} but the index is {}", move _21, _20) -> bb3;
    }

    bb3: {
        (_18[_20].0: u32) = Add((_18[_20].0: u32), const 1_u32);
        StorageDead(_20);
        StorageLive(_23);
        StorageLive(_24);
        _24 = const 0_usize;
        _25 = Len(_18);
        _26 = Lt(_24, _25);
        assert(move _26, "index out of bounds: the length is {} but the index is {}", move _25, _24) -> bb4;
    }

    bb4: {
        _23 = (_18[_24].0: u32);
        _3 = Add(_3, move _23);
        StorageDead(_23);
        StorageDead(_24);
        StorageLive(_27);
        StorageLive(_28);
        _28 = Bar::<u32> { x: const 0_u32 };
        _27 = [move _28];
        StorageDead(_28);
        StorageLive(_29);
        _29 = const 0_usize;
        _30 = Len(_27);
        _31 = Lt(_29, _30);
        assert(move _31, "index out of bounds: the length is {} but the index is {}", move _30, _29) -> bb5;
    }

    bb5: {
        (_27[_29].0: u32) = Add((_27[_29].0: u32), const 1_u32);
        StorageDead(_29);
        StorageLive(_32);
        StorageLive(_33);
        _33 = const 0_usize;
        _34 = Len(_27);
        _35 = Lt(_33, _34);
        assert(move _35, "index out of bounds: the length is {} but the index is {}", move _34, _33) -> bb6;
    }

    bb6: {
        _32 = (_27[_33].0: u32);
        _3 = Add(_3, move _32);
        StorageDead(_32);
        StorageDead(_33);
        StorageLive(_36);
        StorageLive(_37);
        _37 = [const 0_u32];
        _36 = Foo::<[u32; 1]>(move _37);
        StorageDead(_37);
        StorageLive(_38);
        _38 = const 0_usize;
        _39 = Len((_36.0: [u32; 1]));
        _40 = Lt(_38, _39);
        assert(move _40, "index out of bounds: the length is {} but the index is {}", move _39, _38) -> bb7;
    }

    bb7: {
        (_36.0: [u32; 1])[_38] = Add((_36.0: [u32; 1])[_38], const 1_u32);
        StorageDead(_38);
        StorageLive(_41);
        StorageLive(_42);
        _42 = const 0_usize;
        _43 = Len((_36.0: [u32; 1]));
        _44 = Lt(_42, _43);
        assert(move _44, "index out of bounds: the length is {} but the index is {}", move _43, _42) -> bb8;
    }

    bb8: {
        _41 = (_36.0: [u32; 1])[_42];
        _3 = Add(_3, move _41);
        StorageDead(_41);
        StorageDead(_42);
        StorageLive(_45);
        StorageLive(_46);
        _46 = [const 0_u32];
        _45 = Bar::<[u32; 1]> { x: move _46 };
        StorageDead(_46);
        StorageLive(_47);
        _47 = const 0_usize;
        _48 = Len((_45.0: [u32; 1]));
        _49 = Lt(_47, _48);
        assert(move _49, "index out of bounds: the length is {} but the index is {}", move _48, _47) -> bb9;
    }

    bb9: {
        (_45.0: [u32; 1])[_47] = Add((_45.0: [u32; 1])[_47], const 1_u32);
        StorageDead(_47);
        StorageLive(_50);
        StorageLive(_51);
        _51 = const 0_usize;
        _52 = Len((_45.0: [u32; 1]));
        _53 = Lt(_51, _52);
        assert(move _53, "index out of bounds: the length is {} but the index is {}", move _52, _51) -> bb10;
    }

    bb10: {
        _50 = (_45.0: [u32; 1])[_51];
        _3 = Add(_3, move _50);
        StorageDead(_50);
        StorageDead(_51);
        _0 = _3;
        StorageDead(_45);
        StorageDead(_36);
        StorageDead(_27);
        StorageDead(_18);
        StorageDead(_14);
        StorageDead(_13);
        StorageDead(_5);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

add_assign::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

add_assign::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

add_assign::{constant#2}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

add_assign::{constant#3}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

add_assign::{constant#4}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

fn mul_assign(_1: A) -> u32 {
    let mut _0: u32;
    let _2: u32;
    let _5: usize;
    let mut _6: usize;
    let mut _7: bool;
    let mut _8: u32;
    let _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _14: u32;
    let mut _15: u32;
    let mut _16: u32;
    let mut _18: Foo<u32>;
    let _19: usize;
    let mut _20: usize;
    let mut _21: bool;
    let mut _22: u32;
    let _23: usize;
    let mut _24: usize;
    let mut _25: bool;
    let mut _27: Bar<u32>;
    let _28: usize;
    let mut _29: usize;
    let mut _30: bool;
    let mut _31: u32;
    let _32: usize;
    let mut _33: usize;
    let mut _34: bool;
    let mut _36: [u32; 1];
    let _37: usize;
    let mut _38: usize;
    let mut _39: bool;
    let mut _40: u32;
    let _41: usize;
    let mut _42: usize;
    let mut _43: bool;
    let mut _45: [u32; 1];
    let _46: usize;
    let mut _47: usize;
    let mut _48: bool;
    let mut _49: u32;
    let _50: usize;
    let mut _51: usize;
    let mut _52: bool;
    scope 1 {
        debug a => _2;
        let mut _3: u32;
        scope 2 {
            debug d => _3;
            let mut _4: [u32; 1];
            scope 3 {
                debug arr => _4;
                let mut _12: Foo<u32>;
                scope 4 {
                    debug foo => _12;
                    let mut _13: Bar<u32>;
                    scope 5 {
                        debug bar => _13;
                        let mut _17: [Foo<u32>; 1];
                        scope 6 {
                            debug arr => _17;
                            let mut _26: [Bar<u32>; 1];
                            scope 7 {
                                debug arr => _26;
                                let mut _35: Foo<[u32; 1]>;
                                scope 8 {
                                    debug arr => _35;
                                    let mut _44: Bar<[u32; 1]>;
                                    scope 9 {
                                        debug arr => _44;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = (_1.0: u32);
        _3 = Add(_2, const 1_u32);
        _3 = Mul(_3, const 2_u32);
        _4 = [const 1_u32];
        _5 = const 0_usize;
        _6 = const 1_usize;
        _7 = Lt(_5, _6);
        assert(move _7, "index out of bounds: the length is {} but the index is {}", move _6, _5) -> bb1;
    }

    bb1: {
        _4[_5] = Mul(_4[_5], const 2_u32);
        _9 = const 0_usize;
        _10 = const 1_usize;
        _11 = Lt(_9, _10);
        assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _9) -> bb2;
    }

    bb2: {
        _8 = _4[_9];
        _3 = Mul(_3, move _8);
        _12 = Foo::<u32>(const 1_u32);
        _13 = Bar::<u32> { x: const 1_u32 };
        (_12.0: u32) = Mul((_12.0: u32), const 2_u32);
        (_13.0: u32) = Mul((_13.0: u32), const 2_u32);
        _15 = (_12.0: u32);
        _16 = (_13.0: u32);
        _14 = Add(move _15, move _16);
        _3 = Mul(_3, move _14);
        _18 = Foo::<u32>(const 1_u32);
        _17 = [move _18];
        _19 = const 0_usize;
        _20 = const 1_usize;
        _21 = Lt(_19, _20);
        assert(move _21, "index out of bounds: the length is {} but the index is {}", move _20, _19) -> bb3;
    }

    bb3: {
        (_17[_19].0: u32) = Mul((_17[_19].0: u32), const 2_u32);
        _23 = const 0_usize;
        _24 = const 1_usize;
        _25 = Lt(_23, _24);
        assert(move _25, "index out of bounds: the length is {} but the index is {}", move _24, _23) -> bb4;
    }

    bb4: {
        _22 = (_17[_23].0: u32);
        _3 = Mul(_3, move _22);
        _27 = Bar::<u32> { x: const 1_u32 };
        _26 = [move _27];
        _28 = const 0_usize;
        _29 = const 1_usize;
        _30 = Lt(_28, _29);
        assert(move _30, "index out of bounds: the length is {} but the index is {}", move _29, _28) -> bb5;
    }

    bb5: {
        (_26[_28].0: u32) = Mul((_26[_28].0: u32), const 2_u32);
        _32 = const 0_usize;
        _33 = const 1_usize;
        _34 = Lt(_32, _33);
        assert(move _34, "index out of bounds: the length is {} but the index is {}", move _33, _32) -> bb6;
    }

    bb6: {
        _31 = (_26[_32].0: u32);
        _3 = Mul(_3, move _31);
        _36 = [const 1_u32];
        _35 = Foo::<[u32; 1]>(move _36);
        _37 = const 0_usize;
        _38 = const 1_usize;
        _39 = Lt(_37, _38);
        assert(move _39, "index out of bounds: the length is {} but the index is {}", move _38, _37) -> bb7;
    }

    bb7: {
        (_35.0: [u32; 1])[_37] = Mul((_35.0: [u32; 1])[_37], const 2_u32);
        _41 = const 0_usize;
        _42 = const 1_usize;
        _43 = Lt(_41, _42);
        assert(move _43, "index out of bounds: the length is {} but the index is {}", move _42, _41) -> bb8;
    }

    bb8: {
        _40 = (_35.0: [u32; 1])[_41];
        _3 = Mul(_3, move _40);
        _45 = [const 1_u32];
        _44 = Bar::<[u32; 1]> { x: move _45 };
        _46 = const 0_usize;
        _47 = const 1_usize;
        _48 = Lt(_46, _47);
        assert(move _48, "index out of bounds: the length is {} but the index is {}", move _47, _46) -> bb9;
    }

    bb9: {
        (_44.0: [u32; 1])[_46] = Mul((_44.0: [u32; 1])[_46], const 2_u32);
        _50 = const 0_usize;
        _51 = const 1_usize;
        _52 = Lt(_50, _51);
        assert(move _52, "index out of bounds: the length is {} but the index is {}", move _51, _50) -> bb10;
    }

    bb10: {
        _49 = (_44.0: [u32; 1])[_50];
        _3 = Mul(_3, move _49);
        _0 = _3;
        return;
    }
}

// MIR FOR CTFE
fn mul_assign(_1: A) -> u32 {
    let mut _0: u32;
    let _2: u32;
    let mut _4: u32;
    let _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let mut _9: u32;
    let _10: usize;
    let mut _11: usize;
    let mut _12: bool;
    let mut _15: u32;
    let mut _16: u32;
    let mut _17: u32;
    let mut _19: Foo<u32>;
    let _20: usize;
    let mut _21: usize;
    let mut _22: bool;
    let mut _23: u32;
    let _24: usize;
    let mut _25: usize;
    let mut _26: bool;
    let mut _28: Bar<u32>;
    let _29: usize;
    let mut _30: usize;
    let mut _31: bool;
    let mut _32: u32;
    let _33: usize;
    let mut _34: usize;
    let mut _35: bool;
    let mut _37: [u32; 1];
    let _38: usize;
    let mut _39: usize;
    let mut _40: bool;
    let mut _41: u32;
    let _42: usize;
    let mut _43: usize;
    let mut _44: bool;
    let mut _46: [u32; 1];
    let _47: usize;
    let mut _48: usize;
    let mut _49: bool;
    let mut _50: u32;
    let _51: usize;
    let mut _52: usize;
    let mut _53: bool;
    scope 1 {
        debug a => _2;
        let mut _3: u32;
        scope 2 {
            debug d => _3;
            let mut _5: [u32; 1];
            scope 3 {
                debug arr => _5;
                let mut _13: Foo<u32>;
                scope 4 {
                    debug foo => _13;
                    let mut _14: Bar<u32>;
                    scope 5 {
                        debug bar => _14;
                        let mut _18: [Foo<u32>; 1];
                        scope 6 {
                            debug arr => _18;
                            let mut _27: [Bar<u32>; 1];
                            scope 7 {
                                debug arr => _27;
                                let mut _36: Foo<[u32; 1]>;
                                scope 8 {
                                    debug arr => _36;
                                    let mut _45: Bar<[u32; 1]>;
                                    scope 9 {
                                        debug arr => _45;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        StorageLive(_2);
        _2 = (_1.0: u32);
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        _3 = Add(move _4, const 1_u32);
        StorageDead(_4);
        _3 = Mul(_3, const 2_u32);
        StorageLive(_5);
        _5 = [const 1_u32];
        StorageLive(_6);
        _6 = const 0_usize;
        _7 = Len(_5);
        _8 = Lt(_6, _7);
        assert(move _8, "index out of bounds: the length is {} but the index is {}", move _7, _6) -> bb1;
    }

    bb1: {
        _5[_6] = Mul(_5[_6], const 2_u32);
        StorageDead(_6);
        StorageLive(_9);
        StorageLive(_10);
        _10 = const 0_usize;
        _11 = Len(_5);
        _12 = Lt(_10, _11);
        assert(move _12, "index out of bounds: the length is {} but the index is {}", move _11, _10) -> bb2;
    }

    bb2: {
        _9 = _5[_10];
        _3 = Mul(_3, move _9);
        StorageDead(_9);
        StorageDead(_10);
        StorageLive(_13);
        _13 = Foo::<u32>(const 1_u32);
        StorageLive(_14);
        _14 = Bar::<u32> { x: const 1_u32 };
        (_13.0: u32) = Mul((_13.0: u32), const 2_u32);
        (_14.0: u32) = Mul((_14.0: u32), const 2_u32);
        StorageLive(_15);
        StorageLive(_16);
        _16 = (_13.0: u32);
        StorageLive(_17);
        _17 = (_14.0: u32);
        _15 = Add(move _16, move _17);
        StorageDead(_17);
        StorageDead(_16);
        _3 = Mul(_3, move _15);
        StorageDead(_15);
        StorageLive(_18);
        StorageLive(_19);
        _19 = Foo::<u32>(const 1_u32);
        _18 = [move _19];
        StorageDead(_19);
        StorageLive(_20);
        _20 = const 0_usize;
        _21 = Len(_18);
        _22 = Lt(_20, _21);
        assert(move _22, "index out of bounds: the length is {} but the index is {}", move _21, _20) -> bb3;
    }

    bb3: {
        (_18[_20].0: u32) = Mul((_18[_20].0: u32), const 2_u32);
        StorageDead(_20);
        StorageLive(_23);
        StorageLive(_24);
        _24 = const 0_usize;
        _25 = Len(_18);
        _26 = Lt(_24, _25);
        assert(move _26, "index out of bounds: the length is {} but the index is {}", move _25, _24) -> bb4;
    }

    bb4: {
        _23 = (_18[_24].0: u32);
        _3 = Mul(_3, move _23);
        StorageDead(_23);
        StorageDead(_24);
        StorageLive(_27);
        StorageLive(_28);
        _28 = Bar::<u32> { x: const 1_u32 };
        _27 = [move _28];
        StorageDead(_28);
        StorageLive(_29);
        _29 = const 0_usize;
        _30 = Len(_27);
        _31 = Lt(_29, _30);
        assert(move _31, "index out of bounds: the length is {} but the index is {}", move _30, _29) -> bb5;
    }

    bb5: {
        (_27[_29].0: u32) = Mul((_27[_29].0: u32), const 2_u32);
        StorageDead(_29);
        StorageLive(_32);
        StorageLive(_33);
        _33 = const 0_usize;
        _34 = Len(_27);
        _35 = Lt(_33, _34);
        assert(move _35, "index out of bounds: the length is {} but the index is {}", move _34, _33) -> bb6;
    }

    bb6: {
        _32 = (_27[_33].0: u32);
        _3 = Mul(_3, move _32);
        StorageDead(_32);
        StorageDead(_33);
        StorageLive(_36);
        StorageLive(_37);
        _37 = [const 1_u32];
        _36 = Foo::<[u32; 1]>(move _37);
        StorageDead(_37);
        StorageLive(_38);
        _38 = const 0_usize;
        _39 = Len((_36.0: [u32; 1]));
        _40 = Lt(_38, _39);
        assert(move _40, "index out of bounds: the length is {} but the index is {}", move _39, _38) -> bb7;
    }

    bb7: {
        (_36.0: [u32; 1])[_38] = Mul((_36.0: [u32; 1])[_38], const 2_u32);
        StorageDead(_38);
        StorageLive(_41);
        StorageLive(_42);
        _42 = const 0_usize;
        _43 = Len((_36.0: [u32; 1]));
        _44 = Lt(_42, _43);
        assert(move _44, "index out of bounds: the length is {} but the index is {}", move _43, _42) -> bb8;
    }

    bb8: {
        _41 = (_36.0: [u32; 1])[_42];
        _3 = Mul(_3, move _41);
        StorageDead(_41);
        StorageDead(_42);
        StorageLive(_45);
        StorageLive(_46);
        _46 = [const 1_u32];
        _45 = Bar::<[u32; 1]> { x: move _46 };
        StorageDead(_46);
        StorageLive(_47);
        _47 = const 0_usize;
        _48 = Len((_45.0: [u32; 1]));
        _49 = Lt(_47, _48);
        assert(move _49, "index out of bounds: the length is {} but the index is {}", move _48, _47) -> bb9;
    }

    bb9: {
        (_45.0: [u32; 1])[_47] = Mul((_45.0: [u32; 1])[_47], const 2_u32);
        StorageDead(_47);
        StorageLive(_50);
        StorageLive(_51);
        _51 = const 0_usize;
        _52 = Len((_45.0: [u32; 1]));
        _53 = Lt(_51, _52);
        assert(move _53, "index out of bounds: the length is {} but the index is {}", move _52, _51) -> bb10;
    }

    bb10: {
        _50 = (_45.0: [u32; 1])[_51];
        _3 = Mul(_3, move _50);
        StorageDead(_50);
        StorageDead(_51);
        _0 = _3;
        StorageDead(_45);
        StorageDead(_36);
        StorageDead(_27);
        StorageDead(_18);
        StorageDead(_14);
        StorageDead(_13);
        StorageDead(_5);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

mul_assign::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

mul_assign::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

mul_assign::{constant#2}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

mul_assign::{constant#3}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

mul_assign::{constant#4}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

fn div_assign(_1: [u32; 1]) -> u32 {
    debug a => _1;
    let mut _0: u32;
    let _2: u32;
    let _3: usize;
    let mut _4: usize;
    let mut _5: bool;
    let mut _7: bool;
    let _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _12: bool;
    let mut _13: u32;
    let _14: usize;
    let mut _15: usize;
    let mut _16: bool;
    let mut _17: bool;
    let mut _20: bool;
    let mut _21: bool;
    let mut _22: u32;
    let mut _23: bool;
    let mut _24: u32;
    let mut _25: bool;
    let mut _27: Foo<u32>;
    let _28: usize;
    let mut _29: usize;
    let mut _30: bool;
    let mut _31: bool;
    let mut _32: u32;
    let _33: usize;
    let mut _34: usize;
    let mut _35: bool;
    let mut _36: bool;
    let mut _38: Bar<u32>;
    let _39: usize;
    let mut _40: usize;
    let mut _41: bool;
    let mut _42: bool;
    let mut _43: u32;
    let _44: usize;
    let mut _45: usize;
    let mut _46: bool;
    let mut _47: bool;
    let mut _49: [u32; 1];
    let _50: usize;
    let mut _51: usize;
    let mut _52: bool;
    let mut _53: bool;
    let mut _54: u32;
    let _55: usize;
    let mut _56: usize;
    let mut _57: bool;
    let mut _58: bool;
    let mut _60: [u32; 1];
    let _61: usize;
    let mut _62: usize;
    let mut _63: bool;
    let mut _64: bool;
    let mut _65: u32;
    let _66: usize;
    let mut _67: usize;
    let mut _68: bool;
    let mut _69: bool;
    scope 1 {
        debug a => _2;
        let mut _6: u32;
        scope 2 {
            debug d => _6;
            let mut _8: [u32; 1];
            scope 3 {
                debug arr => _8;
                let mut _18: Foo<u32>;
                scope 4 {
                    debug foo => _18;
                    let mut _19: Bar<u32>;
                    scope 5 {
                        debug bar => _19;
                        let mut _26: [Foo<u32>; 1];
                        scope 6 {
                            debug arr => _26;
                            let mut _37: [Bar<u32>; 1];
                            scope 7 {
                                debug arr => _37;
                                let mut _48: Foo<[u32; 1]>;
                                scope 8 {
                                    debug arr => _48;
                                    let mut _59: Bar<[u32; 1]>;
                                    scope 9 {
                                        debug arr => _59;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _3 = const 0_usize;
        _4 = const 1_usize;
        _5 = Lt(_3, _4);
        assert(move _5, "index out of bounds: the length is {} but the index is {}", move _4, _3) -> bb1;
    }

    bb1: {
        _2 = _1[_3];
        _6 = Mul(const 1024_u32, _2);
        _7 = Eq(const 2_u32, const 0_u32);
        assert(!move _7, "attempt to divide `{}` by zero", _6) -> bb2;
    }

    bb2: {
        _6 = Div(_6, const 2_u32);
        _8 = [const 4_u32];
        _9 = const 0_usize;
        _10 = const 1_usize;
        _11 = Lt(_9, _10);
        assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _9) -> bb3;
    }

    bb3: {
        _12 = Eq(const 2_u32, const 0_u32);
        assert(!move _12, "attempt to divide `{}` by zero", _8[_9]) -> bb4;
    }

    bb4: {
        _8[_9] = Div(_8[_9], const 2_u32);
        _14 = const 0_usize;
        _15 = const 1_usize;
        _16 = Lt(_14, _15);
        assert(move _16, "index out of bounds: the length is {} but the index is {}", move _15, _14) -> bb5;
    }

    bb5: {
        _13 = _8[_14];
        _17 = Eq(_13, const 0_u32);
        assert(!move _17, "attempt to divide `{}` by zero", _6) -> bb6;
    }

    bb6: {
        _6 = Div(_6, move _13);
        _18 = Foo::<u32>(const 4_u32);
        _19 = Bar::<u32> { x: const 4_u32 };
        _20 = Eq(const 2_u32, const 0_u32);
        assert(!move _20, "attempt to divide `{}` by zero", (_18.0: u32)) -> bb7;
    }

    bb7: {
        (_18.0: u32) = Div((_18.0: u32), const 2_u32);
        _21 = Eq(const 2_u32, const 0_u32);
        assert(!move _21, "attempt to divide `{}` by zero", (_19.0: u32)) -> bb8;
    }

    bb8: {
        (_19.0: u32) = Div((_19.0: u32), const 2_u32);
        _22 = (_18.0: u32);
        _23 = Eq(_22, const 0_u32);
        assert(!move _23, "attempt to divide `{}` by zero", _6) -> bb9;
    }

    bb9: {
        _6 = Div(_6, move _22);
        _24 = (_19.0: u32);
        _25 = Eq(_24, const 0_u32);
        assert(!move _25, "attempt to divide `{}` by zero", _6) -> bb10;
    }

    bb10: {
        _6 = Div(_6, move _24);
        _27 = Foo::<u32>(const 4_u32);
        _26 = [move _27];
        _28 = const 0_usize;
        _29 = const 1_usize;
        _30 = Lt(_28, _29);
        assert(move _30, "index out of bounds: the length is {} but the index is {}", move _29, _28) -> bb11;
    }

    bb11: {
        _31 = Eq(const 2_u32, const 0_u32);
        assert(!move _31, "attempt to divide `{}` by zero", (_26[_28].0: u32)) -> bb12;
    }

    bb12: {
        (_26[_28].0: u32) = Div((_26[_28].0: u32), const 2_u32);
        _33 = const 0_usize;
        _34 = const 1_usize;
        _35 = Lt(_33, _34);
        assert(move _35, "index out of bounds: the length is {} but the index is {}", move _34, _33) -> bb13;
    }

    bb13: {
        _32 = (_26[_33].0: u32);
        _36 = Eq(_32, const 0_u32);
        assert(!move _36, "attempt to divide `{}` by zero", _6) -> bb14;
    }

    bb14: {
        _6 = Div(_6, move _32);
        _38 = Bar::<u32> { x: const 4_u32 };
        _37 = [move _38];
        _39 = const 0_usize;
        _40 = const 1_usize;
        _41 = Lt(_39, _40);
        assert(move _41, "index out of bounds: the length is {} but the index is {}", move _40, _39) -> bb15;
    }

    bb15: {
        _42 = Eq(const 2_u32, const 0_u32);
        assert(!move _42, "attempt to divide `{}` by zero", (_37[_39].0: u32)) -> bb16;
    }

    bb16: {
        (_37[_39].0: u32) = Div((_37[_39].0: u32), const 2_u32);
        _44 = const 0_usize;
        _45 = const 1_usize;
        _46 = Lt(_44, _45);
        assert(move _46, "index out of bounds: the length is {} but the index is {}", move _45, _44) -> bb17;
    }

    bb17: {
        _43 = (_37[_44].0: u32);
        _47 = Eq(_43, const 0_u32);
        assert(!move _47, "attempt to divide `{}` by zero", _6) -> bb18;
    }

    bb18: {
        _6 = Div(_6, move _43);
        _49 = [const 4_u32];
        _48 = Foo::<[u32; 1]>(move _49);
        _50 = const 0_usize;
        _51 = const 1_usize;
        _52 = Lt(_50, _51);
        assert(move _52, "index out of bounds: the length is {} but the index is {}", move _51, _50) -> bb19;
    }

    bb19: {
        _53 = Eq(const 2_u32, const 0_u32);
        assert(!move _53, "attempt to divide `{}` by zero", (_48.0: [u32; 1])[_50]) -> bb20;
    }

    bb20: {
        (_48.0: [u32; 1])[_50] = Div((_48.0: [u32; 1])[_50], const 2_u32);
        _55 = const 0_usize;
        _56 = const 1_usize;
        _57 = Lt(_55, _56);
        assert(move _57, "index out of bounds: the length is {} but the index is {}", move _56, _55) -> bb21;
    }

    bb21: {
        _54 = (_48.0: [u32; 1])[_55];
        _58 = Eq(_54, const 0_u32);
        assert(!move _58, "attempt to divide `{}` by zero", _6) -> bb22;
    }

    bb22: {
        _6 = Div(_6, move _54);
        _60 = [const 4_u32];
        _59 = Bar::<[u32; 1]> { x: move _60 };
        _61 = const 0_usize;
        _62 = const 1_usize;
        _63 = Lt(_61, _62);
        assert(move _63, "index out of bounds: the length is {} but the index is {}", move _62, _61) -> bb23;
    }

    bb23: {
        _64 = Eq(const 2_u32, const 0_u32);
        assert(!move _64, "attempt to divide `{}` by zero", (_59.0: [u32; 1])[_61]) -> bb24;
    }

    bb24: {
        (_59.0: [u32; 1])[_61] = Div((_59.0: [u32; 1])[_61], const 2_u32);
        _66 = const 0_usize;
        _67 = const 1_usize;
        _68 = Lt(_66, _67);
        assert(move _68, "index out of bounds: the length is {} but the index is {}", move _67, _66) -> bb25;
    }

    bb25: {
        _65 = (_59.0: [u32; 1])[_66];
        _69 = Eq(_65, const 0_u32);
        assert(!move _69, "attempt to divide `{}` by zero", _6) -> bb26;
    }

    bb26: {
        _6 = Div(_6, move _65);
        _0 = _6;
        return;
    }
}

// MIR FOR CTFE
fn div_assign(_1: [u32; 1]) -> u32 {
    debug a => _1;
    let mut _0: u32;
    let _2: u32;
    let _3: usize;
    let mut _4: usize;
    let mut _5: bool;
    let mut _7: u32;
    let mut _8: bool;
    let _10: usize;
    let mut _11: usize;
    let mut _12: bool;
    let mut _13: bool;
    let mut _14: u32;
    let _15: usize;
    let mut _16: usize;
    let mut _17: bool;
    let mut _18: bool;
    let mut _21: bool;
    let mut _22: bool;
    let mut _23: u32;
    let mut _24: bool;
    let mut _25: u32;
    let mut _26: bool;
    let mut _28: Foo<u32>;
    let _29: usize;
    let mut _30: usize;
    let mut _31: bool;
    let mut _32: bool;
    let mut _33: u32;
    let _34: usize;
    let mut _35: usize;
    let mut _36: bool;
    let mut _37: bool;
    let mut _39: Bar<u32>;
    let _40: usize;
    let mut _41: usize;
    let mut _42: bool;
    let mut _43: bool;
    let mut _44: u32;
    let _45: usize;
    let mut _46: usize;
    let mut _47: bool;
    let mut _48: bool;
    let mut _50: [u32; 1];
    let _51: usize;
    let mut _52: usize;
    let mut _53: bool;
    let mut _54: bool;
    let mut _55: u32;
    let _56: usize;
    let mut _57: usize;
    let mut _58: bool;
    let mut _59: bool;
    let mut _61: [u32; 1];
    let _62: usize;
    let mut _63: usize;
    let mut _64: bool;
    let mut _65: bool;
    let mut _66: u32;
    let _67: usize;
    let mut _68: usize;
    let mut _69: bool;
    let mut _70: bool;
    scope 1 {
        debug a => _2;
        let mut _6: u32;
        scope 2 {
            debug d => _6;
            let mut _9: [u32; 1];
            scope 3 {
                debug arr => _9;
                let mut _19: Foo<u32>;
                scope 4 {
                    debug foo => _19;
                    let mut _20: Bar<u32>;
                    scope 5 {
                        debug bar => _20;
                        let mut _27: [Foo<u32>; 1];
                        scope 6 {
                            debug arr => _27;
                            let mut _38: [Bar<u32>; 1];
                            scope 7 {
                                debug arr => _38;
                                let mut _49: Foo<[u32; 1]>;
                                scope 8 {
                                    debug arr => _49;
                                    let mut _60: Bar<[u32; 1]>;
                                    scope 9 {
                                        debug arr => _60;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = const 0_usize;
        _4 = Len(_1);
        _5 = Lt(_3, _4);
        assert(move _5, "index out of bounds: the length is {} but the index is {}", move _4, _3) -> bb1;
    }

    bb1: {
        _2 = _1[_3];
        StorageDead(_3);
        StorageLive(_6);
        StorageLive(_7);
        _7 = _2;
        _6 = Mul(const 1024_u32, move _7);
        StorageDead(_7);
        _8 = Eq(const 2_u32, const 0_u32);
        assert(!move _8, "attempt to divide `{}` by zero", _6) -> bb2;
    }

    bb2: {
        _6 = Div(_6, const 2_u32);
        StorageLive(_9);
        _9 = [const 4_u32];
        StorageLive(_10);
        _10 = const 0_usize;
        _11 = Len(_9);
        _12 = Lt(_10, _11);
        assert(move _12, "index out of bounds: the length is {} but the index is {}", move _11, _10) -> bb3;
    }

    bb3: {
        _13 = Eq(const 2_u32, const 0_u32);
        assert(!move _13, "attempt to divide `{}` by zero", _9[_10]) -> bb4;
    }

    bb4: {
        _9[_10] = Div(_9[_10], const 2_u32);
        StorageDead(_10);
        StorageLive(_14);
        StorageLive(_15);
        _15 = const 0_usize;
        _16 = Len(_9);
        _17 = Lt(_15, _16);
        assert(move _17, "index out of bounds: the length is {} but the index is {}", move _16, _15) -> bb5;
    }

    bb5: {
        _14 = _9[_15];
        _18 = Eq(_14, const 0_u32);
        assert(!move _18, "attempt to divide `{}` by zero", _6) -> bb6;
    }

    bb6: {
        _6 = Div(_6, move _14);
        StorageDead(_14);
        StorageDead(_15);
        StorageLive(_19);
        _19 = Foo::<u32>(const 4_u32);
        StorageLive(_20);
        _20 = Bar::<u32> { x: const 4_u32 };
        _21 = Eq(const 2_u32, const 0_u32);
        assert(!move _21, "attempt to divide `{}` by zero", (_19.0: u32)) -> bb7;
    }

    bb7: {
        (_19.0: u32) = Div((_19.0: u32), const 2_u32);
        _22 = Eq(const 2_u32, const 0_u32);
        assert(!move _22, "attempt to divide `{}` by zero", (_20.0: u32)) -> bb8;
    }

    bb8: {
        (_20.0: u32) = Div((_20.0: u32), const 2_u32);
        StorageLive(_23);
        _23 = (_19.0: u32);
        _24 = Eq(_23, const 0_u32);
        assert(!move _24, "attempt to divide `{}` by zero", _6) -> bb9;
    }

    bb9: {
        _6 = Div(_6, move _23);
        StorageDead(_23);
        StorageLive(_25);
        _25 = (_20.0: u32);
        _26 = Eq(_25, const 0_u32);
        assert(!move _26, "attempt to divide `{}` by zero", _6) -> bb10;
    }

    bb10: {
        _6 = Div(_6, move _25);
        StorageDead(_25);
        StorageLive(_27);
        StorageLive(_28);
        _28 = Foo::<u32>(const 4_u32);
        _27 = [move _28];
        StorageDead(_28);
        StorageLive(_29);
        _29 = const 0_usize;
        _30 = Len(_27);
        _31 = Lt(_29, _30);
        assert(move _31, "index out of bounds: the length is {} but the index is {}", move _30, _29) -> bb11;
    }

    bb11: {
        _32 = Eq(const 2_u32, const 0_u32);
        assert(!move _32, "attempt to divide `{}` by zero", (_27[_29].0: u32)) -> bb12;
    }

    bb12: {
        (_27[_29].0: u32) = Div((_27[_29].0: u32), const 2_u32);
        StorageDead(_29);
        StorageLive(_33);
        StorageLive(_34);
        _34 = const 0_usize;
        _35 = Len(_27);
        _36 = Lt(_34, _35);
        assert(move _36, "index out of bounds: the length is {} but the index is {}", move _35, _34) -> bb13;
    }

    bb13: {
        _33 = (_27[_34].0: u32);
        _37 = Eq(_33, const 0_u32);
        assert(!move _37, "attempt to divide `{}` by zero", _6) -> bb14;
    }

    bb14: {
        _6 = Div(_6, move _33);
        StorageDead(_33);
        StorageDead(_34);
        StorageLive(_38);
        StorageLive(_39);
        _39 = Bar::<u32> { x: const 4_u32 };
        _38 = [move _39];
        StorageDead(_39);
        StorageLive(_40);
        _40 = const 0_usize;
        _41 = Len(_38);
        _42 = Lt(_40, _41);
        assert(move _42, "index out of bounds: the length is {} but the index is {}", move _41, _40) -> bb15;
    }

    bb15: {
        _43 = Eq(const 2_u32, const 0_u32);
        assert(!move _43, "attempt to divide `{}` by zero", (_38[_40].0: u32)) -> bb16;
    }

    bb16: {
        (_38[_40].0: u32) = Div((_38[_40].0: u32), const 2_u32);
        StorageDead(_40);
        StorageLive(_44);
        StorageLive(_45);
        _45 = const 0_usize;
        _46 = Len(_38);
        _47 = Lt(_45, _46);
        assert(move _47, "index out of bounds: the length is {} but the index is {}", move _46, _45) -> bb17;
    }

    bb17: {
        _44 = (_38[_45].0: u32);
        _48 = Eq(_44, const 0_u32);
        assert(!move _48, "attempt to divide `{}` by zero", _6) -> bb18;
    }

    bb18: {
        _6 = Div(_6, move _44);
        StorageDead(_44);
        StorageDead(_45);
        StorageLive(_49);
        StorageLive(_50);
        _50 = [const 4_u32];
        _49 = Foo::<[u32; 1]>(move _50);
        StorageDead(_50);
        StorageLive(_51);
        _51 = const 0_usize;
        _52 = Len((_49.0: [u32; 1]));
        _53 = Lt(_51, _52);
        assert(move _53, "index out of bounds: the length is {} but the index is {}", move _52, _51) -> bb19;
    }

    bb19: {
        _54 = Eq(const 2_u32, const 0_u32);
        assert(!move _54, "attempt to divide `{}` by zero", (_49.0: [u32; 1])[_51]) -> bb20;
    }

    bb20: {
        (_49.0: [u32; 1])[_51] = Div((_49.0: [u32; 1])[_51], const 2_u32);
        StorageDead(_51);
        StorageLive(_55);
        StorageLive(_56);
        _56 = const 0_usize;
        _57 = Len((_49.0: [u32; 1]));
        _58 = Lt(_56, _57);
        assert(move _58, "index out of bounds: the length is {} but the index is {}", move _57, _56) -> bb21;
    }

    bb21: {
        _55 = (_49.0: [u32; 1])[_56];
        _59 = Eq(_55, const 0_u32);
        assert(!move _59, "attempt to divide `{}` by zero", _6) -> bb22;
    }

    bb22: {
        _6 = Div(_6, move _55);
        StorageDead(_55);
        StorageDead(_56);
        StorageLive(_60);
        StorageLive(_61);
        _61 = [const 4_u32];
        _60 = Bar::<[u32; 1]> { x: move _61 };
        StorageDead(_61);
        StorageLive(_62);
        _62 = const 0_usize;
        _63 = Len((_60.0: [u32; 1]));
        _64 = Lt(_62, _63);
        assert(move _64, "index out of bounds: the length is {} but the index is {}", move _63, _62) -> bb23;
    }

    bb23: {
        _65 = Eq(const 2_u32, const 0_u32);
        assert(!move _65, "attempt to divide `{}` by zero", (_60.0: [u32; 1])[_62]) -> bb24;
    }

    bb24: {
        (_60.0: [u32; 1])[_62] = Div((_60.0: [u32; 1])[_62], const 2_u32);
        StorageDead(_62);
        StorageLive(_66);
        StorageLive(_67);
        _67 = const 0_usize;
        _68 = Len((_60.0: [u32; 1]));
        _69 = Lt(_67, _68);
        assert(move _69, "index out of bounds: the length is {} but the index is {}", move _68, _67) -> bb25;
    }

    bb25: {
        _66 = (_60.0: [u32; 1])[_67];
        _70 = Eq(_66, const 0_u32);
        assert(!move _70, "attempt to divide `{}` by zero", _6) -> bb26;
    }

    bb26: {
        _6 = Div(_6, move _66);
        StorageDead(_66);
        StorageDead(_67);
        _0 = _6;
        StorageDead(_60);
        StorageDead(_49);
        StorageDead(_38);
        StorageDead(_27);
        StorageDead(_20);
        StorageDead(_19);
        StorageDead(_9);
        StorageDead(_6);
        StorageDead(_2);
        return;
    }
}

div_assign::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

div_assign::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

div_assign::{constant#2}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

div_assign::{constant#3}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

div_assign::{constant#4}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

div_assign::{constant#5}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

fn rem_assign(_1: W) -> u32 {
    let mut _0: u32;
    let _2: u32;
    let mut _4: bool;
    let _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let mut _9: bool;
    let mut _10: u32;
    let mut _11: u32;
    let _12: usize;
    let mut _13: usize;
    let mut _14: bool;
    let mut _15: bool;
    let mut _18: bool;
    let mut _19: bool;
    let mut _20: u32;
    let mut _21: u32;
    let mut _22: u32;
    let mut _23: u32;
    let mut _24: bool;
    let mut _26: Foo<u32>;
    let _27: usize;
    let mut _28: usize;
    let mut _29: bool;
    let mut _30: bool;
    let mut _31: u32;
    let mut _32: u32;
    let _33: usize;
    let mut _34: usize;
    let mut _35: bool;
    let mut _36: bool;
    let mut _38: Bar<u32>;
    let _39: usize;
    let mut _40: usize;
    let mut _41: bool;
    let mut _42: bool;
    let mut _43: u32;
    let mut _44: u32;
    let _45: usize;
    let mut _46: usize;
    let mut _47: bool;
    let mut _48: bool;
    let mut _50: [u32; 1];
    let _51: usize;
    let mut _52: usize;
    let mut _53: bool;
    let mut _54: bool;
    let mut _55: u32;
    let mut _56: u32;
    let _57: usize;
    let mut _58: usize;
    let mut _59: bool;
    let mut _60: bool;
    let mut _62: [u32; 1];
    let _63: usize;
    let mut _64: usize;
    let mut _65: bool;
    let mut _66: bool;
    let mut _67: u32;
    let mut _68: u32;
    let _69: usize;
    let mut _70: usize;
    let mut _71: bool;
    let mut _72: bool;
    scope 1 {
        debug a => _2;
        let mut _3: u32;
        scope 2 {
            debug d => _3;
            let mut _5: [u32; 1];
            scope 3 {
                debug arr => _5;
                let mut _16: Foo<u32>;
                scope 4 {
                    debug foo => _16;
                    let mut _17: Bar<u32>;
                    scope 5 {
                        debug bar => _17;
                        let mut _25: [Foo<u32>; 1];
                        scope 6 {
                            debug arr => _25;
                            let mut _37: [Bar<u32>; 1];
                            scope 7 {
                                debug arr => _37;
                                let mut _49: Foo<[u32; 1]>;
                                scope 8 {
                                    debug arr => _49;
                                    let mut _61: Bar<[u32; 1]>;
                                    scope 9 {
                                        debug arr => _61;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = (_1.0: u32);
        _3 = _2;
        _4 = Eq(const 10_u32, const 0_u32);
        assert(!move _4, "attempt to calculate the remainder of `{}` with a divisor of zero", _3) -> bb1;
    }

    bb1: {
        _3 = Rem(_3, const 10_u32);
        _3 = Add(_3, const 10_u32);
        _5 = [const 3_u32];
        _6 = const 0_usize;
        _7 = const 1_usize;
        _8 = Lt(_6, _7);
        assert(move _8, "index out of bounds: the length is {} but the index is {}", move _7, _6) -> bb2;
    }

    bb2: {
        _9 = Eq(const 2_u32, const 0_u32);
        assert(!move _9, "attempt to calculate the remainder of `{}` with a divisor of zero", _5[_6]) -> bb3;
    }

    bb3: {
        _5[_6] = Rem(_5[_6], const 2_u32);
        _12 = const 0_usize;
        _13 = const 1_usize;
        _14 = Lt(_12, _13);
        assert(move _14, "index out of bounds: the length is {} but the index is {}", move _13, _12) -> bb4;
    }

    bb4: {
        _11 = _5[_12];
        _10 = Add(const 9_u32, move _11);
        _15 = Eq(_10, const 0_u32);
        assert(!move _15, "attempt to calculate the remainder of `{}` with a divisor of zero", _3) -> bb5;
    }

    bb5: {
        _3 = Rem(_3, move _10);
        _3 = Add(_3, const 10_u32);
        _16 = Foo::<u32>(const 5_u32);
        _17 = Bar::<u32> { x: const 7_u32 };
        _18 = Eq(const 2_u32, const 0_u32);
        assert(!move _18, "attempt to calculate the remainder of `{}` with a divisor of zero", (_16.0: u32)) -> bb6;
    }

    bb6: {
        (_16.0: u32) = Rem((_16.0: u32), const 2_u32);
        _19 = Eq(const 2_u32, const 0_u32);
        assert(!move _19, "attempt to calculate the remainder of `{}` with a divisor of zero", (_17.0: u32)) -> bb7;
    }

    bb7: {
        (_17.0: u32) = Rem((_17.0: u32), const 2_u32);
        _22 = (_16.0: u32);
        _21 = Add(const 8_u32, move _22);
        _23 = (_17.0: u32);
        _20 = Add(move _21, move _23);
        _24 = Eq(_20, const 0_u32);
        assert(!move _24, "attempt to calculate the remainder of `{}` with a divisor of zero", _3) -> bb8;
    }

    bb8: {
        _3 = Rem(_3, move _20);
        _3 = Add(_3, const 10_u32);
        _26 = Foo::<u32>(const 4_u32);
        _25 = [move _26];
        _27 = const 0_usize;
        _28 = const 1_usize;
        _29 = Lt(_27, _28);
        assert(move _29, "index out of bounds: the length is {} but the index is {}", move _28, _27) -> bb9;
    }

    bb9: {
        _30 = Eq(const 3_u32, const 0_u32);
        assert(!move _30, "attempt to calculate the remainder of `{}` with a divisor of zero", (_25[_27].0: u32)) -> bb10;
    }

    bb10: {
        (_25[_27].0: u32) = Rem((_25[_27].0: u32), const 3_u32);
        _33 = const 0_usize;
        _34 = const 1_usize;
        _35 = Lt(_33, _34);
        assert(move _35, "index out of bounds: the length is {} but the index is {}", move _34, _33) -> bb11;
    }

    bb11: {
        _32 = (_25[_33].0: u32);
        _31 = Add(const 9_u32, move _32);
        _36 = Eq(_31, const 0_u32);
        assert(!move _36, "attempt to calculate the remainder of `{}` with a divisor of zero", _3) -> bb12;
    }

    bb12: {
        _3 = Rem(_3, move _31);
        _3 = Add(_3, const 10_u32);
        _38 = Bar::<u32> { x: const 7_u32 };
        _37 = [move _38];
        _39 = const 0_usize;
        _40 = const 1_usize;
        _41 = Lt(_39, _40);
        assert(move _41, "index out of bounds: the length is {} but the index is {}", move _40, _39) -> bb13;
    }

    bb13: {
        _42 = Eq(const 3_u32, const 0_u32);
        assert(!move _42, "attempt to calculate the remainder of `{}` with a divisor of zero", (_37[_39].0: u32)) -> bb14;
    }

    bb14: {
        (_37[_39].0: u32) = Rem((_37[_39].0: u32), const 3_u32);
        _45 = const 0_usize;
        _46 = const 1_usize;
        _47 = Lt(_45, _46);
        assert(move _47, "index out of bounds: the length is {} but the index is {}", move _46, _45) -> bb15;
    }

    bb15: {
        _44 = (_37[_45].0: u32);
        _43 = Add(const 9_u32, move _44);
        _48 = Eq(_43, const 0_u32);
        assert(!move _48, "attempt to calculate the remainder of `{}` with a divisor of zero", _3) -> bb16;
    }

    bb16: {
        _3 = Rem(_3, move _43);
        _3 = Add(_3, const 10_u32);
        _50 = [const 6_u32];
        _49 = Foo::<[u32; 1]>(move _50);
        _51 = const 0_usize;
        _52 = const 1_usize;
        _53 = Lt(_51, _52);
        assert(move _53, "index out of bounds: the length is {} but the index is {}", move _52, _51) -> bb17;
    }

    bb17: {
        _54 = Eq(const 5_u32, const 0_u32);
        assert(!move _54, "attempt to calculate the remainder of `{}` with a divisor of zero", (_49.0: [u32; 1])[_51]) -> bb18;
    }

    bb18: {
        (_49.0: [u32; 1])[_51] = Rem((_49.0: [u32; 1])[_51], const 5_u32);
        _57 = const 0_usize;
        _58 = const 1_usize;
        _59 = Lt(_57, _58);
        assert(move _59, "index out of bounds: the length is {} but the index is {}", move _58, _57) -> bb19;
    }

    bb19: {
        _56 = (_49.0: [u32; 1])[_57];
        _55 = Add(const 9_u32, move _56);
        _60 = Eq(_55, const 0_u32);
        assert(!move _60, "attempt to calculate the remainder of `{}` with a divisor of zero", _3) -> bb20;
    }

    bb20: {
        _3 = Rem(_3, move _55);
        _62 = [const 11_u32];
        _61 = Bar::<[u32; 1]> { x: move _62 };
        _63 = const 0_usize;
        _64 = const 1_usize;
        _65 = Lt(_63, _64);
        assert(move _65, "index out of bounds: the length is {} but the index is {}", move _64, _63) -> bb21;
    }

    bb21: {
        _66 = Eq(const 5_u32, const 0_u32);
        assert(!move _66, "attempt to calculate the remainder of `{}` with a divisor of zero", (_61.0: [u32; 1])[_63]) -> bb22;
    }

    bb22: {
        (_61.0: [u32; 1])[_63] = Rem((_61.0: [u32; 1])[_63], const 5_u32);
        _69 = const 0_usize;
        _70 = const 1_usize;
        _71 = Lt(_69, _70);
        assert(move _71, "index out of bounds: the length is {} but the index is {}", move _70, _69) -> bb23;
    }

    bb23: {
        _68 = (_61.0: [u32; 1])[_69];
        _67 = Add(const 9_u32, move _68);
        _72 = Eq(_67, const 0_u32);
        assert(!move _72, "attempt to calculate the remainder of `{}` with a divisor of zero", _3) -> bb24;
    }

    bb24: {
        _3 = Rem(_3, move _67);
        _0 = _3;
        return;
    }
}

// MIR FOR CTFE
fn rem_assign(_1: W) -> u32 {
    let mut _0: u32;
    let _2: u32;
    let mut _4: bool;
    let _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let mut _9: bool;
    let mut _10: u32;
    let mut _11: u32;
    let _12: usize;
    let mut _13: usize;
    let mut _14: bool;
    let mut _15: bool;
    let mut _18: bool;
    let mut _19: bool;
    let mut _20: u32;
    let mut _21: u32;
    let mut _22: u32;
    let mut _23: u32;
    let mut _24: bool;
    let mut _26: Foo<u32>;
    let _27: usize;
    let mut _28: usize;
    let mut _29: bool;
    let mut _30: bool;
    let mut _31: u32;
    let mut _32: u32;
    let _33: usize;
    let mut _34: usize;
    let mut _35: bool;
    let mut _36: bool;
    let mut _38: Bar<u32>;
    let _39: usize;
    let mut _40: usize;
    let mut _41: bool;
    let mut _42: bool;
    let mut _43: u32;
    let mut _44: u32;
    let _45: usize;
    let mut _46: usize;
    let mut _47: bool;
    let mut _48: bool;
    let mut _50: [u32; 1];
    let _51: usize;
    let mut _52: usize;
    let mut _53: bool;
    let mut _54: bool;
    let mut _55: u32;
    let mut _56: u32;
    let _57: usize;
    let mut _58: usize;
    let mut _59: bool;
    let mut _60: bool;
    let mut _62: [u32; 1];
    let _63: usize;
    let mut _64: usize;
    let mut _65: bool;
    let mut _66: bool;
    let mut _67: u32;
    let mut _68: u32;
    let _69: usize;
    let mut _70: usize;
    let mut _71: bool;
    let mut _72: bool;
    scope 1 {
        debug a => _2;
        let mut _3: u32;
        scope 2 {
            debug d => _3;
            let mut _5: [u32; 1];
            scope 3 {
                debug arr => _5;
                let mut _16: Foo<u32>;
                scope 4 {
                    debug foo => _16;
                    let mut _17: Bar<u32>;
                    scope 5 {
                        debug bar => _17;
                        let mut _25: [Foo<u32>; 1];
                        scope 6 {
                            debug arr => _25;
                            let mut _37: [Bar<u32>; 1];
                            scope 7 {
                                debug arr => _37;
                                let mut _49: Foo<[u32; 1]>;
                                scope 8 {
                                    debug arr => _49;
                                    let mut _61: Bar<[u32; 1]>;
                                    scope 9 {
                                        debug arr => _61;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        StorageLive(_2);
        _2 = (_1.0: u32);
        StorageLive(_3);
        _3 = _2;
        _4 = Eq(const 10_u32, const 0_u32);
        assert(!move _4, "attempt to calculate the remainder of `{}` with a divisor of zero", _3) -> bb1;
    }

    bb1: {
        _3 = Rem(_3, const 10_u32);
        _3 = Add(_3, const 10_u32);
        StorageLive(_5);
        _5 = [const 3_u32];
        StorageLive(_6);
        _6 = const 0_usize;
        _7 = Len(_5);
        _8 = Lt(_6, _7);
        assert(move _8, "index out of bounds: the length is {} but the index is {}", move _7, _6) -> bb2;
    }

    bb2: {
        _9 = Eq(const 2_u32, const 0_u32);
        assert(!move _9, "attempt to calculate the remainder of `{}` with a divisor of zero", _5[_6]) -> bb3;
    }

    bb3: {
        _5[_6] = Rem(_5[_6], const 2_u32);
        StorageDead(_6);
        StorageLive(_10);
        StorageLive(_11);
        StorageLive(_12);
        _12 = const 0_usize;
        _13 = Len(_5);
        _14 = Lt(_12, _13);
        assert(move _14, "index out of bounds: the length is {} but the index is {}", move _13, _12) -> bb4;
    }

    bb4: {
        _11 = _5[_12];
        _10 = Add(const 9_u32, move _11);
        StorageDead(_11);
        _15 = Eq(_10, const 0_u32);
        assert(!move _15, "attempt to calculate the remainder of `{}` with a divisor of zero", _3) -> bb5;
    }

    bb5: {
        _3 = Rem(_3, move _10);
        StorageDead(_10);
        StorageDead(_12);
        _3 = Add(_3, const 10_u32);
        StorageLive(_16);
        _16 = Foo::<u32>(const 5_u32);
        StorageLive(_17);
        _17 = Bar::<u32> { x: const 7_u32 };
        _18 = Eq(const 2_u32, const 0_u32);
        assert(!move _18, "attempt to calculate the remainder of `{}` with a divisor of zero", (_16.0: u32)) -> bb6;
    }

    bb6: {
        (_16.0: u32) = Rem((_16.0: u32), const 2_u32);
        _19 = Eq(const 2_u32, const 0_u32);
        assert(!move _19, "attempt to calculate the remainder of `{}` with a divisor of zero", (_17.0: u32)) -> bb7;
    }

    bb7: {
        (_17.0: u32) = Rem((_17.0: u32), const 2_u32);
        StorageLive(_20);
        StorageLive(_21);
        StorageLive(_22);
        _22 = (_16.0: u32);
        _21 = Add(const 8_u32, move _22);
        StorageDead(_22);
        StorageLive(_23);
        _23 = (_17.0: u32);
        _20 = Add(move _21, move _23);
        StorageDead(_23);
        StorageDead(_21);
        _24 = Eq(_20, const 0_u32);
        assert(!move _24, "attempt to calculate the remainder of `{}` with a divisor of zero", _3) -> bb8;
    }

    bb8: {
        _3 = Rem(_3, move _20);
        StorageDead(_20);
        _3 = Add(_3, const 10_u32);
        StorageLive(_25);
        StorageLive(_26);
        _26 = Foo::<u32>(const 4_u32);
        _25 = [move _26];
        StorageDead(_26);
        StorageLive(_27);
        _27 = const 0_usize;
        _28 = Len(_25);
        _29 = Lt(_27, _28);
        assert(move _29, "index out of bounds: the length is {} but the index is {}", move _28, _27) -> bb9;
    }

    bb9: {
        _30 = Eq(const 3_u32, const 0_u32);
        assert(!move _30, "attempt to calculate the remainder of `{}` with a divisor of zero", (_25[_27].0: u32)) -> bb10;
    }

    bb10: {
        (_25[_27].0: u32) = Rem((_25[_27].0: u32), const 3_u32);
        StorageDead(_27);
        StorageLive(_31);
        StorageLive(_32);
        StorageLive(_33);
        _33 = const 0_usize;
        _34 = Len(_25);
        _35 = Lt(_33, _34);
        assert(move _35, "index out of bounds: the length is {} but the index is {}", move _34, _33) -> bb11;
    }

    bb11: {
        _32 = (_25[_33].0: u32);
        _31 = Add(const 9_u32, move _32);
        StorageDead(_32);
        _36 = Eq(_31, const 0_u32);
        assert(!move _36, "attempt to calculate the remainder of `{}` with a divisor of zero", _3) -> bb12;
    }

    bb12: {
        _3 = Rem(_3, move _31);
        StorageDead(_31);
        StorageDead(_33);
        _3 = Add(_3, const 10_u32);
        StorageLive(_37);
        StorageLive(_38);
        _38 = Bar::<u32> { x: const 7_u32 };
        _37 = [move _38];
        StorageDead(_38);
        StorageLive(_39);
        _39 = const 0_usize;
        _40 = Len(_37);
        _41 = Lt(_39, _40);
        assert(move _41, "index out of bounds: the length is {} but the index is {}", move _40, _39) -> bb13;
    }

    bb13: {
        _42 = Eq(const 3_u32, const 0_u32);
        assert(!move _42, "attempt to calculate the remainder of `{}` with a divisor of zero", (_37[_39].0: u32)) -> bb14;
    }

    bb14: {
        (_37[_39].0: u32) = Rem((_37[_39].0: u32), const 3_u32);
        StorageDead(_39);
        StorageLive(_43);
        StorageLive(_44);
        StorageLive(_45);
        _45 = const 0_usize;
        _46 = Len(_37);
        _47 = Lt(_45, _46);
        assert(move _47, "index out of bounds: the length is {} but the index is {}", move _46, _45) -> bb15;
    }

    bb15: {
        _44 = (_37[_45].0: u32);
        _43 = Add(const 9_u32, move _44);
        StorageDead(_44);
        _48 = Eq(_43, const 0_u32);
        assert(!move _48, "attempt to calculate the remainder of `{}` with a divisor of zero", _3) -> bb16;
    }

    bb16: {
        _3 = Rem(_3, move _43);
        StorageDead(_43);
        StorageDead(_45);
        _3 = Add(_3, const 10_u32);
        StorageLive(_49);
        StorageLive(_50);
        _50 = [const 6_u32];
        _49 = Foo::<[u32; 1]>(move _50);
        StorageDead(_50);
        StorageLive(_51);
        _51 = const 0_usize;
        _52 = Len((_49.0: [u32; 1]));
        _53 = Lt(_51, _52);
        assert(move _53, "index out of bounds: the length is {} but the index is {}", move _52, _51) -> bb17;
    }

    bb17: {
        _54 = Eq(const 5_u32, const 0_u32);
        assert(!move _54, "attempt to calculate the remainder of `{}` with a divisor of zero", (_49.0: [u32; 1])[_51]) -> bb18;
    }

    bb18: {
        (_49.0: [u32; 1])[_51] = Rem((_49.0: [u32; 1])[_51], const 5_u32);
        StorageDead(_51);
        StorageLive(_55);
        StorageLive(_56);
        StorageLive(_57);
        _57 = const 0_usize;
        _58 = Len((_49.0: [u32; 1]));
        _59 = Lt(_57, _58);
        assert(move _59, "index out of bounds: the length is {} but the index is {}", move _58, _57) -> bb19;
    }

    bb19: {
        _56 = (_49.0: [u32; 1])[_57];
        _55 = Add(const 9_u32, move _56);
        StorageDead(_56);
        _60 = Eq(_55, const 0_u32);
        assert(!move _60, "attempt to calculate the remainder of `{}` with a divisor of zero", _3) -> bb20;
    }

    bb20: {
        _3 = Rem(_3, move _55);
        StorageDead(_55);
        StorageDead(_57);
        StorageLive(_61);
        StorageLive(_62);
        _62 = [const 11_u32];
        _61 = Bar::<[u32; 1]> { x: move _62 };
        StorageDead(_62);
        StorageLive(_63);
        _63 = const 0_usize;
        _64 = Len((_61.0: [u32; 1]));
        _65 = Lt(_63, _64);
        assert(move _65, "index out of bounds: the length is {} but the index is {}", move _64, _63) -> bb21;
    }

    bb21: {
        _66 = Eq(const 5_u32, const 0_u32);
        assert(!move _66, "attempt to calculate the remainder of `{}` with a divisor of zero", (_61.0: [u32; 1])[_63]) -> bb22;
    }

    bb22: {
        (_61.0: [u32; 1])[_63] = Rem((_61.0: [u32; 1])[_63], const 5_u32);
        StorageDead(_63);
        StorageLive(_67);
        StorageLive(_68);
        StorageLive(_69);
        _69 = const 0_usize;
        _70 = Len((_61.0: [u32; 1]));
        _71 = Lt(_69, _70);
        assert(move _71, "index out of bounds: the length is {} but the index is {}", move _70, _69) -> bb23;
    }

    bb23: {
        _68 = (_61.0: [u32; 1])[_69];
        _67 = Add(const 9_u32, move _68);
        StorageDead(_68);
        _72 = Eq(_67, const 0_u32);
        assert(!move _72, "attempt to calculate the remainder of `{}` with a divisor of zero", _3) -> bb24;
    }

    bb24: {
        _3 = Rem(_3, move _67);
        StorageDead(_67);
        StorageDead(_69);
        _0 = _3;
        StorageDead(_61);
        StorageDead(_49);
        StorageDead(_37);
        StorageDead(_25);
        StorageDead(_17);
        StorageDead(_16);
        StorageDead(_5);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

rem_assign::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

rem_assign::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

rem_assign::{constant#2}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

rem_assign::{constant#3}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

rem_assign::{constant#4}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

fn sub_assign(_1: W) -> u32 {
    let mut _0: u32;
    let _2: u32;
    let _5: usize;
    let mut _6: usize;
    let mut _7: bool;
    let mut _8: u32;
    let _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _14: u32;
    let mut _15: u32;
    let mut _16: u32;
    let mut _18: Foo<u32>;
    let _19: usize;
    let mut _20: usize;
    let mut _21: bool;
    let mut _22: u32;
    let _23: usize;
    let mut _24: usize;
    let mut _25: bool;
    let mut _27: Bar<u32>;
    let _28: usize;
    let mut _29: usize;
    let mut _30: bool;
    let mut _31: u32;
    let _32: usize;
    let mut _33: usize;
    let mut _34: bool;
    let mut _36: [u32; 1];
    let _37: usize;
    let mut _38: usize;
    let mut _39: bool;
    let mut _40: u32;
    let _41: usize;
    let mut _42: usize;
    let mut _43: bool;
    let mut _45: [u32; 1];
    let _46: usize;
    let mut _47: usize;
    let mut _48: bool;
    let mut _49: u32;
    let _50: usize;
    let mut _51: usize;
    let mut _52: bool;
    scope 1 {
        debug a => _2;
        let mut _3: u32;
        scope 2 {
            debug d => _3;
            let mut _4: [u32; 1];
            scope 3 {
                debug arr => _4;
                let mut _12: Foo<u32>;
                scope 4 {
                    debug foo => _12;
                    let mut _13: Bar<u32>;
                    scope 5 {
                        debug bar => _13;
                        let mut _17: [Foo<u32>; 1];
                        scope 6 {
                            debug arr => _17;
                            let mut _26: [Bar<u32>; 1];
                            scope 7 {
                                debug arr => _26;
                                let mut _35: Foo<[u32; 1]>;
                                scope 8 {
                                    debug arr => _35;
                                    let mut _44: Bar<[u32; 1]>;
                                    scope 9 {
                                        debug arr => _44;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = (_1.0: u32);
        _3 = _2;
        _3 = Sub(_3, const 1_u32);
        _4 = [const 2_u32];
        _5 = const 0_usize;
        _6 = const 1_usize;
        _7 = Lt(_5, _6);
        assert(move _7, "index out of bounds: the length is {} but the index is {}", move _6, _5) -> bb1;
    }

    bb1: {
        _4[_5] = Sub(_4[_5], const 1_u32);
        _9 = const 0_usize;
        _10 = const 1_usize;
        _11 = Lt(_9, _10);
        assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _9) -> bb2;
    }

    bb2: {
        _8 = _4[_9];
        _3 = Sub(_3, move _8);
        _12 = Foo::<u32>(const 2_u32);
        _13 = Bar::<u32> { x: const 2_u32 };
        (_12.0: u32) = Sub((_12.0: u32), const 1_u32);
        (_13.0: u32) = Sub((_13.0: u32), const 1_u32);
        _15 = (_12.0: u32);
        _16 = (_13.0: u32);
        _14 = Add(move _15, move _16);
        _3 = Sub(_3, move _14);
        _18 = Foo::<u32>(const 2_u32);
        _17 = [move _18];
        _19 = const 0_usize;
        _20 = const 1_usize;
        _21 = Lt(_19, _20);
        assert(move _21, "index out of bounds: the length is {} but the index is {}", move _20, _19) -> bb3;
    }

    bb3: {
        (_17[_19].0: u32) = Sub((_17[_19].0: u32), const 1_u32);
        _23 = const 0_usize;
        _24 = const 1_usize;
        _25 = Lt(_23, _24);
        assert(move _25, "index out of bounds: the length is {} but the index is {}", move _24, _23) -> bb4;
    }

    bb4: {
        _22 = (_17[_23].0: u32);
        _3 = Sub(_3, move _22);
        _27 = Bar::<u32> { x: const 2_u32 };
        _26 = [move _27];
        _28 = const 0_usize;
        _29 = const 1_usize;
        _30 = Lt(_28, _29);
        assert(move _30, "index out of bounds: the length is {} but the index is {}", move _29, _28) -> bb5;
    }

    bb5: {
        (_26[_28].0: u32) = Sub((_26[_28].0: u32), const 1_u32);
        _32 = const 0_usize;
        _33 = const 1_usize;
        _34 = Lt(_32, _33);
        assert(move _34, "index out of bounds: the length is {} but the index is {}", move _33, _32) -> bb6;
    }

    bb6: {
        _31 = (_26[_32].0: u32);
        _3 = Sub(_3, move _31);
        _36 = [const 2_u32];
        _35 = Foo::<[u32; 1]>(move _36);
        _37 = const 0_usize;
        _38 = const 1_usize;
        _39 = Lt(_37, _38);
        assert(move _39, "index out of bounds: the length is {} but the index is {}", move _38, _37) -> bb7;
    }

    bb7: {
        (_35.0: [u32; 1])[_37] = Sub((_35.0: [u32; 1])[_37], const 1_u32);
        _41 = const 0_usize;
        _42 = const 1_usize;
        _43 = Lt(_41, _42);
        assert(move _43, "index out of bounds: the length is {} but the index is {}", move _42, _41) -> bb8;
    }

    bb8: {
        _40 = (_35.0: [u32; 1])[_41];
        _3 = Sub(_3, move _40);
        _45 = [const 2_u32];
        _44 = Bar::<[u32; 1]> { x: move _45 };
        _46 = const 0_usize;
        _47 = const 1_usize;
        _48 = Lt(_46, _47);
        assert(move _48, "index out of bounds: the length is {} but the index is {}", move _47, _46) -> bb9;
    }

    bb9: {
        (_44.0: [u32; 1])[_46] = Sub((_44.0: [u32; 1])[_46], const 1_u32);
        _50 = const 0_usize;
        _51 = const 1_usize;
        _52 = Lt(_50, _51);
        assert(move _52, "index out of bounds: the length is {} but the index is {}", move _51, _50) -> bb10;
    }

    bb10: {
        _49 = (_44.0: [u32; 1])[_50];
        _3 = Sub(_3, move _49);
        _0 = _3;
        return;
    }
}

// MIR FOR CTFE
fn sub_assign(_1: W) -> u32 {
    let mut _0: u32;
    let _2: u32;
    let _5: usize;
    let mut _6: usize;
    let mut _7: bool;
    let mut _8: u32;
    let _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _14: u32;
    let mut _15: u32;
    let mut _16: u32;
    let mut _18: Foo<u32>;
    let _19: usize;
    let mut _20: usize;
    let mut _21: bool;
    let mut _22: u32;
    let _23: usize;
    let mut _24: usize;
    let mut _25: bool;
    let mut _27: Bar<u32>;
    let _28: usize;
    let mut _29: usize;
    let mut _30: bool;
    let mut _31: u32;
    let _32: usize;
    let mut _33: usize;
    let mut _34: bool;
    let mut _36: [u32; 1];
    let _37: usize;
    let mut _38: usize;
    let mut _39: bool;
    let mut _40: u32;
    let _41: usize;
    let mut _42: usize;
    let mut _43: bool;
    let mut _45: [u32; 1];
    let _46: usize;
    let mut _47: usize;
    let mut _48: bool;
    let mut _49: u32;
    let _50: usize;
    let mut _51: usize;
    let mut _52: bool;
    scope 1 {
        debug a => _2;
        let mut _3: u32;
        scope 2 {
            debug d => _3;
            let mut _4: [u32; 1];
            scope 3 {
                debug arr => _4;
                let mut _12: Foo<u32>;
                scope 4 {
                    debug foo => _12;
                    let mut _13: Bar<u32>;
                    scope 5 {
                        debug bar => _13;
                        let mut _17: [Foo<u32>; 1];
                        scope 6 {
                            debug arr => _17;
                            let mut _26: [Bar<u32>; 1];
                            scope 7 {
                                debug arr => _26;
                                let mut _35: Foo<[u32; 1]>;
                                scope 8 {
                                    debug arr => _35;
                                    let mut _44: Bar<[u32; 1]>;
                                    scope 9 {
                                        debug arr => _44;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        StorageLive(_2);
        _2 = (_1.0: u32);
        StorageLive(_3);
        _3 = _2;
        _3 = Sub(_3, const 1_u32);
        StorageLive(_4);
        _4 = [const 2_u32];
        StorageLive(_5);
        _5 = const 0_usize;
        _6 = Len(_4);
        _7 = Lt(_5, _6);
        assert(move _7, "index out of bounds: the length is {} but the index is {}", move _6, _5) -> bb1;
    }

    bb1: {
        _4[_5] = Sub(_4[_5], const 1_u32);
        StorageDead(_5);
        StorageLive(_8);
        StorageLive(_9);
        _9 = const 0_usize;
        _10 = Len(_4);
        _11 = Lt(_9, _10);
        assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _9) -> bb2;
    }

    bb2: {
        _8 = _4[_9];
        _3 = Sub(_3, move _8);
        StorageDead(_8);
        StorageDead(_9);
        StorageLive(_12);
        _12 = Foo::<u32>(const 2_u32);
        StorageLive(_13);
        _13 = Bar::<u32> { x: const 2_u32 };
        (_12.0: u32) = Sub((_12.0: u32), const 1_u32);
        (_13.0: u32) = Sub((_13.0: u32), const 1_u32);
        StorageLive(_14);
        StorageLive(_15);
        _15 = (_12.0: u32);
        StorageLive(_16);
        _16 = (_13.0: u32);
        _14 = Add(move _15, move _16);
        StorageDead(_16);
        StorageDead(_15);
        _3 = Sub(_3, move _14);
        StorageDead(_14);
        StorageLive(_17);
        StorageLive(_18);
        _18 = Foo::<u32>(const 2_u32);
        _17 = [move _18];
        StorageDead(_18);
        StorageLive(_19);
        _19 = const 0_usize;
        _20 = Len(_17);
        _21 = Lt(_19, _20);
        assert(move _21, "index out of bounds: the length is {} but the index is {}", move _20, _19) -> bb3;
    }

    bb3: {
        (_17[_19].0: u32) = Sub((_17[_19].0: u32), const 1_u32);
        StorageDead(_19);
        StorageLive(_22);
        StorageLive(_23);
        _23 = const 0_usize;
        _24 = Len(_17);
        _25 = Lt(_23, _24);
        assert(move _25, "index out of bounds: the length is {} but the index is {}", move _24, _23) -> bb4;
    }

    bb4: {
        _22 = (_17[_23].0: u32);
        _3 = Sub(_3, move _22);
        StorageDead(_22);
        StorageDead(_23);
        StorageLive(_26);
        StorageLive(_27);
        _27 = Bar::<u32> { x: const 2_u32 };
        _26 = [move _27];
        StorageDead(_27);
        StorageLive(_28);
        _28 = const 0_usize;
        _29 = Len(_26);
        _30 = Lt(_28, _29);
        assert(move _30, "index out of bounds: the length is {} but the index is {}", move _29, _28) -> bb5;
    }

    bb5: {
        (_26[_28].0: u32) = Sub((_26[_28].0: u32), const 1_u32);
        StorageDead(_28);
        StorageLive(_31);
        StorageLive(_32);
        _32 = const 0_usize;
        _33 = Len(_26);
        _34 = Lt(_32, _33);
        assert(move _34, "index out of bounds: the length is {} but the index is {}", move _33, _32) -> bb6;
    }

    bb6: {
        _31 = (_26[_32].0: u32);
        _3 = Sub(_3, move _31);
        StorageDead(_31);
        StorageDead(_32);
        StorageLive(_35);
        StorageLive(_36);
        _36 = [const 2_u32];
        _35 = Foo::<[u32; 1]>(move _36);
        StorageDead(_36);
        StorageLive(_37);
        _37 = const 0_usize;
        _38 = Len((_35.0: [u32; 1]));
        _39 = Lt(_37, _38);
        assert(move _39, "index out of bounds: the length is {} but the index is {}", move _38, _37) -> bb7;
    }

    bb7: {
        (_35.0: [u32; 1])[_37] = Sub((_35.0: [u32; 1])[_37], const 1_u32);
        StorageDead(_37);
        StorageLive(_40);
        StorageLive(_41);
        _41 = const 0_usize;
        _42 = Len((_35.0: [u32; 1]));
        _43 = Lt(_41, _42);
        assert(move _43, "index out of bounds: the length is {} but the index is {}", move _42, _41) -> bb8;
    }

    bb8: {
        _40 = (_35.0: [u32; 1])[_41];
        _3 = Sub(_3, move _40);
        StorageDead(_40);
        StorageDead(_41);
        StorageLive(_44);
        StorageLive(_45);
        _45 = [const 2_u32];
        _44 = Bar::<[u32; 1]> { x: move _45 };
        StorageDead(_45);
        StorageLive(_46);
        _46 = const 0_usize;
        _47 = Len((_44.0: [u32; 1]));
        _48 = Lt(_46, _47);
        assert(move _48, "index out of bounds: the length is {} but the index is {}", move _47, _46) -> bb9;
    }

    bb9: {
        (_44.0: [u32; 1])[_46] = Sub((_44.0: [u32; 1])[_46], const 1_u32);
        StorageDead(_46);
        StorageLive(_49);
        StorageLive(_50);
        _50 = const 0_usize;
        _51 = Len((_44.0: [u32; 1]));
        _52 = Lt(_50, _51);
        assert(move _52, "index out of bounds: the length is {} but the index is {}", move _51, _50) -> bb10;
    }

    bb10: {
        _49 = (_44.0: [u32; 1])[_50];
        _3 = Sub(_3, move _49);
        StorageDead(_49);
        StorageDead(_50);
        _0 = _3;
        StorageDead(_44);
        StorageDead(_35);
        StorageDead(_26);
        StorageDead(_17);
        StorageDead(_13);
        StorageDead(_12);
        StorageDead(_4);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

sub_assign::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

sub_assign::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

sub_assign::{constant#2}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

sub_assign::{constant#3}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

sub_assign::{constant#4}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

fn shl_assign(_1: W) -> u32 {
    let mut _0: u32;
    let _2: u32;
    let _5: usize;
    let mut _6: usize;
    let mut _7: bool;
    let mut _8: u32;
    let _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _14: u32;
    let mut _15: u32;
    let mut _16: u32;
    let mut _18: Foo<u32>;
    let _19: usize;
    let mut _20: usize;
    let mut _21: bool;
    let mut _22: u32;
    let _23: usize;
    let mut _24: usize;
    let mut _25: bool;
    let mut _27: Bar<u32>;
    let _28: usize;
    let mut _29: usize;
    let mut _30: bool;
    let mut _31: u32;
    let _32: usize;
    let mut _33: usize;
    let mut _34: bool;
    let mut _36: [u32; 1];
    let _37: usize;
    let mut _38: usize;
    let mut _39: bool;
    let mut _40: u32;
    let _41: usize;
    let mut _42: usize;
    let mut _43: bool;
    let mut _45: [u32; 1];
    let _46: usize;
    let mut _47: usize;
    let mut _48: bool;
    let mut _49: u32;
    let _50: usize;
    let mut _51: usize;
    let mut _52: bool;
    scope 1 {
        debug a => _2;
        let mut _3: u32;
        scope 2 {
            debug d => _3;
            let mut _4: [u32; 1];
            scope 3 {
                debug arr => _4;
                let mut _12: Foo<u32>;
                scope 4 {
                    debug foo => _12;
                    let mut _13: Bar<u32>;
                    scope 5 {
                        debug bar => _13;
                        let mut _17: [Foo<u32>; 1];
                        scope 6 {
                            debug arr => _17;
                            let mut _26: [Bar<u32>; 1];
                            scope 7 {
                                debug arr => _26;
                                let mut _35: Foo<[u32; 1]>;
                                scope 8 {
                                    debug arr => _35;
                                    let mut _44: Bar<[u32; 1]>;
                                    scope 9 {
                                        debug arr => _44;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = (_1.0: u32);
        _3 = _2;
        _3 = Shl(_3, const 1_i32);
        _4 = [const 1_u32];
        _5 = const 0_usize;
        _6 = const 1_usize;
        _7 = Lt(_5, _6);
        assert(move _7, "index out of bounds: the length is {} but the index is {}", move _6, _5) -> bb1;
    }

    bb1: {
        _4[_5] = Shl(_4[_5], const 1_i32);
        _9 = const 0_usize;
        _10 = const 1_usize;
        _11 = Lt(_9, _10);
        assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _9) -> bb2;
    }

    bb2: {
        _8 = _4[_9];
        _3 = Shl(_3, move _8);
        _12 = Foo::<u32>(const 1_u32);
        _13 = Bar::<u32> { x: const 1_u32 };
        (_12.0: u32) = Shl((_12.0: u32), const 1_i32);
        (_13.0: u32) = Shl((_13.0: u32), const 1_i32);
        _15 = (_12.0: u32);
        _16 = (_13.0: u32);
        _14 = Add(move _15, move _16);
        _3 = Shl(_3, move _14);
        _18 = Foo::<u32>(const 1_u32);
        _17 = [move _18];
        _19 = const 0_usize;
        _20 = const 1_usize;
        _21 = Lt(_19, _20);
        assert(move _21, "index out of bounds: the length is {} but the index is {}", move _20, _19) -> bb3;
    }

    bb3: {
        (_17[_19].0: u32) = Shl((_17[_19].0: u32), const 1_i32);
        _23 = const 0_usize;
        _24 = const 1_usize;
        _25 = Lt(_23, _24);
        assert(move _25, "index out of bounds: the length is {} but the index is {}", move _24, _23) -> bb4;
    }

    bb4: {
        _22 = (_17[_23].0: u32);
        _3 = Shl(_3, move _22);
        _27 = Bar::<u32> { x: const 1_u32 };
        _26 = [move _27];
        _28 = const 0_usize;
        _29 = const 1_usize;
        _30 = Lt(_28, _29);
        assert(move _30, "index out of bounds: the length is {} but the index is {}", move _29, _28) -> bb5;
    }

    bb5: {
        (_26[_28].0: u32) = Shl((_26[_28].0: u32), const 1_i32);
        _32 = const 0_usize;
        _33 = const 1_usize;
        _34 = Lt(_32, _33);
        assert(move _34, "index out of bounds: the length is {} but the index is {}", move _33, _32) -> bb6;
    }

    bb6: {
        _31 = (_26[_32].0: u32);
        _3 = Shl(_3, move _31);
        _36 = [const 1_u32];
        _35 = Foo::<[u32; 1]>(move _36);
        _37 = const 0_usize;
        _38 = const 1_usize;
        _39 = Lt(_37, _38);
        assert(move _39, "index out of bounds: the length is {} but the index is {}", move _38, _37) -> bb7;
    }

    bb7: {
        (_35.0: [u32; 1])[_37] = Shl((_35.0: [u32; 1])[_37], const 1_i32);
        _41 = const 0_usize;
        _42 = const 1_usize;
        _43 = Lt(_41, _42);
        assert(move _43, "index out of bounds: the length is {} but the index is {}", move _42, _41) -> bb8;
    }

    bb8: {
        _40 = (_35.0: [u32; 1])[_41];
        _3 = Shl(_3, move _40);
        _45 = [const 1_u32];
        _44 = Bar::<[u32; 1]> { x: move _45 };
        _46 = const 0_usize;
        _47 = const 1_usize;
        _48 = Lt(_46, _47);
        assert(move _48, "index out of bounds: the length is {} but the index is {}", move _47, _46) -> bb9;
    }

    bb9: {
        (_44.0: [u32; 1])[_46] = Shl((_44.0: [u32; 1])[_46], const 1_i32);
        _50 = const 0_usize;
        _51 = const 1_usize;
        _52 = Lt(_50, _51);
        assert(move _52, "index out of bounds: the length is {} but the index is {}", move _51, _50) -> bb10;
    }

    bb10: {
        _49 = (_44.0: [u32; 1])[_50];
        _3 = Shl(_3, move _49);
        _0 = _3;
        return;
    }
}

// MIR FOR CTFE
fn shl_assign(_1: W) -> u32 {
    let mut _0: u32;
    let _2: u32;
    let _5: usize;
    let mut _6: usize;
    let mut _7: bool;
    let mut _8: u32;
    let _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _14: u32;
    let mut _15: u32;
    let mut _16: u32;
    let mut _18: Foo<u32>;
    let _19: usize;
    let mut _20: usize;
    let mut _21: bool;
    let mut _22: u32;
    let _23: usize;
    let mut _24: usize;
    let mut _25: bool;
    let mut _27: Bar<u32>;
    let _28: usize;
    let mut _29: usize;
    let mut _30: bool;
    let mut _31: u32;
    let _32: usize;
    let mut _33: usize;
    let mut _34: bool;
    let mut _36: [u32; 1];
    let _37: usize;
    let mut _38: usize;
    let mut _39: bool;
    let mut _40: u32;
    let _41: usize;
    let mut _42: usize;
    let mut _43: bool;
    let mut _45: [u32; 1];
    let _46: usize;
    let mut _47: usize;
    let mut _48: bool;
    let mut _49: u32;
    let _50: usize;
    let mut _51: usize;
    let mut _52: bool;
    scope 1 {
        debug a => _2;
        let mut _3: u32;
        scope 2 {
            debug d => _3;
            let mut _4: [u32; 1];
            scope 3 {
                debug arr => _4;
                let mut _12: Foo<u32>;
                scope 4 {
                    debug foo => _12;
                    let mut _13: Bar<u32>;
                    scope 5 {
                        debug bar => _13;
                        let mut _17: [Foo<u32>; 1];
                        scope 6 {
                            debug arr => _17;
                            let mut _26: [Bar<u32>; 1];
                            scope 7 {
                                debug arr => _26;
                                let mut _35: Foo<[u32; 1]>;
                                scope 8 {
                                    debug arr => _35;
                                    let mut _44: Bar<[u32; 1]>;
                                    scope 9 {
                                        debug arr => _44;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        StorageLive(_2);
        _2 = (_1.0: u32);
        StorageLive(_3);
        _3 = _2;
        _3 = Shl(_3, const 1_i32);
        StorageLive(_4);
        _4 = [const 1_u32];
        StorageLive(_5);
        _5 = const 0_usize;
        _6 = Len(_4);
        _7 = Lt(_5, _6);
        assert(move _7, "index out of bounds: the length is {} but the index is {}", move _6, _5) -> bb1;
    }

    bb1: {
        _4[_5] = Shl(_4[_5], const 1_i32);
        StorageDead(_5);
        StorageLive(_8);
        StorageLive(_9);
        _9 = const 0_usize;
        _10 = Len(_4);
        _11 = Lt(_9, _10);
        assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _9) -> bb2;
    }

    bb2: {
        _8 = _4[_9];
        _3 = Shl(_3, move _8);
        StorageDead(_8);
        StorageDead(_9);
        StorageLive(_12);
        _12 = Foo::<u32>(const 1_u32);
        StorageLive(_13);
        _13 = Bar::<u32> { x: const 1_u32 };
        (_12.0: u32) = Shl((_12.0: u32), const 1_i32);
        (_13.0: u32) = Shl((_13.0: u32), const 1_i32);
        StorageLive(_14);
        StorageLive(_15);
        _15 = (_12.0: u32);
        StorageLive(_16);
        _16 = (_13.0: u32);
        _14 = Add(move _15, move _16);
        StorageDead(_16);
        StorageDead(_15);
        _3 = Shl(_3, move _14);
        StorageDead(_14);
        StorageLive(_17);
        StorageLive(_18);
        _18 = Foo::<u32>(const 1_u32);
        _17 = [move _18];
        StorageDead(_18);
        StorageLive(_19);
        _19 = const 0_usize;
        _20 = Len(_17);
        _21 = Lt(_19, _20);
        assert(move _21, "index out of bounds: the length is {} but the index is {}", move _20, _19) -> bb3;
    }

    bb3: {
        (_17[_19].0: u32) = Shl((_17[_19].0: u32), const 1_i32);
        StorageDead(_19);
        StorageLive(_22);
        StorageLive(_23);
        _23 = const 0_usize;
        _24 = Len(_17);
        _25 = Lt(_23, _24);
        assert(move _25, "index out of bounds: the length is {} but the index is {}", move _24, _23) -> bb4;
    }

    bb4: {
        _22 = (_17[_23].0: u32);
        _3 = Shl(_3, move _22);
        StorageDead(_22);
        StorageDead(_23);
        StorageLive(_26);
        StorageLive(_27);
        _27 = Bar::<u32> { x: const 1_u32 };
        _26 = [move _27];
        StorageDead(_27);
        StorageLive(_28);
        _28 = const 0_usize;
        _29 = Len(_26);
        _30 = Lt(_28, _29);
        assert(move _30, "index out of bounds: the length is {} but the index is {}", move _29, _28) -> bb5;
    }

    bb5: {
        (_26[_28].0: u32) = Shl((_26[_28].0: u32), const 1_i32);
        StorageDead(_28);
        StorageLive(_31);
        StorageLive(_32);
        _32 = const 0_usize;
        _33 = Len(_26);
        _34 = Lt(_32, _33);
        assert(move _34, "index out of bounds: the length is {} but the index is {}", move _33, _32) -> bb6;
    }

    bb6: {
        _31 = (_26[_32].0: u32);
        _3 = Shl(_3, move _31);
        StorageDead(_31);
        StorageDead(_32);
        StorageLive(_35);
        StorageLive(_36);
        _36 = [const 1_u32];
        _35 = Foo::<[u32; 1]>(move _36);
        StorageDead(_36);
        StorageLive(_37);
        _37 = const 0_usize;
        _38 = Len((_35.0: [u32; 1]));
        _39 = Lt(_37, _38);
        assert(move _39, "index out of bounds: the length is {} but the index is {}", move _38, _37) -> bb7;
    }

    bb7: {
        (_35.0: [u32; 1])[_37] = Shl((_35.0: [u32; 1])[_37], const 1_i32);
        StorageDead(_37);
        StorageLive(_40);
        StorageLive(_41);
        _41 = const 0_usize;
        _42 = Len((_35.0: [u32; 1]));
        _43 = Lt(_41, _42);
        assert(move _43, "index out of bounds: the length is {} but the index is {}", move _42, _41) -> bb8;
    }

    bb8: {
        _40 = (_35.0: [u32; 1])[_41];
        _3 = Shl(_3, move _40);
        StorageDead(_40);
        StorageDead(_41);
        StorageLive(_44);
        StorageLive(_45);
        _45 = [const 1_u32];
        _44 = Bar::<[u32; 1]> { x: move _45 };
        StorageDead(_45);
        StorageLive(_46);
        _46 = const 0_usize;
        _47 = Len((_44.0: [u32; 1]));
        _48 = Lt(_46, _47);
        assert(move _48, "index out of bounds: the length is {} but the index is {}", move _47, _46) -> bb9;
    }

    bb9: {
        (_44.0: [u32; 1])[_46] = Shl((_44.0: [u32; 1])[_46], const 1_i32);
        StorageDead(_46);
        StorageLive(_49);
        StorageLive(_50);
        _50 = const 0_usize;
        _51 = Len((_44.0: [u32; 1]));
        _52 = Lt(_50, _51);
        assert(move _52, "index out of bounds: the length is {} but the index is {}", move _51, _50) -> bb10;
    }

    bb10: {
        _49 = (_44.0: [u32; 1])[_50];
        _3 = Shl(_3, move _49);
        StorageDead(_49);
        StorageDead(_50);
        _0 = _3;
        StorageDead(_44);
        StorageDead(_35);
        StorageDead(_26);
        StorageDead(_17);
        StorageDead(_13);
        StorageDead(_12);
        StorageDead(_4);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

shl_assign::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

shl_assign::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

shl_assign::{constant#2}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

shl_assign::{constant#3}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

shl_assign::{constant#4}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

fn shr_assign(_1: W) -> u32 {
    let mut _0: u32;
    let _2: u32;
    let _5: usize;
    let mut _6: usize;
    let mut _7: bool;
    let mut _8: u32;
    let _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _14: u32;
    let mut _15: u32;
    let mut _16: u32;
    let mut _18: Foo<u32>;
    let _19: usize;
    let mut _20: usize;
    let mut _21: bool;
    let mut _22: u32;
    let _23: usize;
    let mut _24: usize;
    let mut _25: bool;
    let mut _27: Bar<u32>;
    let _28: usize;
    let mut _29: usize;
    let mut _30: bool;
    let mut _31: u32;
    let _32: usize;
    let mut _33: usize;
    let mut _34: bool;
    let mut _36: [u32; 1];
    let _37: usize;
    let mut _38: usize;
    let mut _39: bool;
    let mut _40: u32;
    let _41: usize;
    let mut _42: usize;
    let mut _43: bool;
    let mut _45: [u32; 1];
    let _46: usize;
    let mut _47: usize;
    let mut _48: bool;
    let mut _49: u32;
    let _50: usize;
    let mut _51: usize;
    let mut _52: bool;
    scope 1 {
        debug a => _2;
        let mut _3: u32;
        scope 2 {
            debug d => _3;
            let mut _4: [u32; 1];
            scope 3 {
                debug arr => _4;
                let mut _12: Foo<u32>;
                scope 4 {
                    debug foo => _12;
                    let mut _13: Bar<u32>;
                    scope 5 {
                        debug bar => _13;
                        let mut _17: [Foo<u32>; 1];
                        scope 6 {
                            debug arr => _17;
                            let mut _26: [Bar<u32>; 1];
                            scope 7 {
                                debug arr => _26;
                                let mut _35: Foo<[u32; 1]>;
                                scope 8 {
                                    debug arr => _35;
                                    let mut _44: Bar<[u32; 1]>;
                                    scope 9 {
                                        debug arr => _44;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = (_1.0: u32);
        _3 = _2;
        _3 = Shr(_3, const 1_i32);
        _4 = [const 2_u32];
        _5 = const 0_usize;
        _6 = const 1_usize;
        _7 = Lt(_5, _6);
        assert(move _7, "index out of bounds: the length is {} but the index is {}", move _6, _5) -> bb1;
    }

    bb1: {
        _4[_5] = Shr(_4[_5], const 1_i32);
        _9 = const 0_usize;
        _10 = const 1_usize;
        _11 = Lt(_9, _10);
        assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _9) -> bb2;
    }

    bb2: {
        _8 = _4[_9];
        _3 = Shr(_3, move _8);
        _12 = Foo::<u32>(const 2_u32);
        _13 = Bar::<u32> { x: const 2_u32 };
        (_12.0: u32) = Shr((_12.0: u32), const 1_i32);
        (_13.0: u32) = Shr((_13.0: u32), const 1_i32);
        _15 = (_12.0: u32);
        _16 = (_13.0: u32);
        _14 = Add(move _15, move _16);
        _3 = Shr(_3, move _14);
        _18 = Foo::<u32>(const 2_u32);
        _17 = [move _18];
        _19 = const 0_usize;
        _20 = const 1_usize;
        _21 = Lt(_19, _20);
        assert(move _21, "index out of bounds: the length is {} but the index is {}", move _20, _19) -> bb3;
    }

    bb3: {
        (_17[_19].0: u32) = Shr((_17[_19].0: u32), const 1_i32);
        _23 = const 0_usize;
        _24 = const 1_usize;
        _25 = Lt(_23, _24);
        assert(move _25, "index out of bounds: the length is {} but the index is {}", move _24, _23) -> bb4;
    }

    bb4: {
        _22 = (_17[_23].0: u32);
        _3 = Shr(_3, move _22);
        _27 = Bar::<u32> { x: const 2_u32 };
        _26 = [move _27];
        _28 = const 0_usize;
        _29 = const 1_usize;
        _30 = Lt(_28, _29);
        assert(move _30, "index out of bounds: the length is {} but the index is {}", move _29, _28) -> bb5;
    }

    bb5: {
        (_26[_28].0: u32) = Shr((_26[_28].0: u32), const 1_i32);
        _32 = const 0_usize;
        _33 = const 1_usize;
        _34 = Lt(_32, _33);
        assert(move _34, "index out of bounds: the length is {} but the index is {}", move _33, _32) -> bb6;
    }

    bb6: {
        _31 = (_26[_32].0: u32);
        _3 = Shr(_3, move _31);
        _36 = [const 2_u32];
        _35 = Foo::<[u32; 1]>(move _36);
        _37 = const 0_usize;
        _38 = const 1_usize;
        _39 = Lt(_37, _38);
        assert(move _39, "index out of bounds: the length is {} but the index is {}", move _38, _37) -> bb7;
    }

    bb7: {
        (_35.0: [u32; 1])[_37] = Shr((_35.0: [u32; 1])[_37], const 1_i32);
        _41 = const 0_usize;
        _42 = const 1_usize;
        _43 = Lt(_41, _42);
        assert(move _43, "index out of bounds: the length is {} but the index is {}", move _42, _41) -> bb8;
    }

    bb8: {
        _40 = (_35.0: [u32; 1])[_41];
        _3 = Shr(_3, move _40);
        _45 = [const 2_u32];
        _44 = Bar::<[u32; 1]> { x: move _45 };
        _46 = const 0_usize;
        _47 = const 1_usize;
        _48 = Lt(_46, _47);
        assert(move _48, "index out of bounds: the length is {} but the index is {}", move _47, _46) -> bb9;
    }

    bb9: {
        (_44.0: [u32; 1])[_46] = Shr((_44.0: [u32; 1])[_46], const 1_i32);
        _50 = const 0_usize;
        _51 = const 1_usize;
        _52 = Lt(_50, _51);
        assert(move _52, "index out of bounds: the length is {} but the index is {}", move _51, _50) -> bb10;
    }

    bb10: {
        _49 = (_44.0: [u32; 1])[_50];
        _3 = Shr(_3, move _49);
        _0 = _3;
        return;
    }
}

// MIR FOR CTFE
fn shr_assign(_1: W) -> u32 {
    let mut _0: u32;
    let _2: u32;
    let _5: usize;
    let mut _6: usize;
    let mut _7: bool;
    let mut _8: u32;
    let _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _14: u32;
    let mut _15: u32;
    let mut _16: u32;
    let mut _18: Foo<u32>;
    let _19: usize;
    let mut _20: usize;
    let mut _21: bool;
    let mut _22: u32;
    let _23: usize;
    let mut _24: usize;
    let mut _25: bool;
    let mut _27: Bar<u32>;
    let _28: usize;
    let mut _29: usize;
    let mut _30: bool;
    let mut _31: u32;
    let _32: usize;
    let mut _33: usize;
    let mut _34: bool;
    let mut _36: [u32; 1];
    let _37: usize;
    let mut _38: usize;
    let mut _39: bool;
    let mut _40: u32;
    let _41: usize;
    let mut _42: usize;
    let mut _43: bool;
    let mut _45: [u32; 1];
    let _46: usize;
    let mut _47: usize;
    let mut _48: bool;
    let mut _49: u32;
    let _50: usize;
    let mut _51: usize;
    let mut _52: bool;
    scope 1 {
        debug a => _2;
        let mut _3: u32;
        scope 2 {
            debug d => _3;
            let mut _4: [u32; 1];
            scope 3 {
                debug arr => _4;
                let mut _12: Foo<u32>;
                scope 4 {
                    debug foo => _12;
                    let mut _13: Bar<u32>;
                    scope 5 {
                        debug bar => _13;
                        let mut _17: [Foo<u32>; 1];
                        scope 6 {
                            debug arr => _17;
                            let mut _26: [Bar<u32>; 1];
                            scope 7 {
                                debug arr => _26;
                                let mut _35: Foo<[u32; 1]>;
                                scope 8 {
                                    debug arr => _35;
                                    let mut _44: Bar<[u32; 1]>;
                                    scope 9 {
                                        debug arr => _44;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        StorageLive(_2);
        _2 = (_1.0: u32);
        StorageLive(_3);
        _3 = _2;
        _3 = Shr(_3, const 1_i32);
        StorageLive(_4);
        _4 = [const 2_u32];
        StorageLive(_5);
        _5 = const 0_usize;
        _6 = Len(_4);
        _7 = Lt(_5, _6);
        assert(move _7, "index out of bounds: the length is {} but the index is {}", move _6, _5) -> bb1;
    }

    bb1: {
        _4[_5] = Shr(_4[_5], const 1_i32);
        StorageDead(_5);
        StorageLive(_8);
        StorageLive(_9);
        _9 = const 0_usize;
        _10 = Len(_4);
        _11 = Lt(_9, _10);
        assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _9) -> bb2;
    }

    bb2: {
        _8 = _4[_9];
        _3 = Shr(_3, move _8);
        StorageDead(_8);
        StorageDead(_9);
        StorageLive(_12);
        _12 = Foo::<u32>(const 2_u32);
        StorageLive(_13);
        _13 = Bar::<u32> { x: const 2_u32 };
        (_12.0: u32) = Shr((_12.0: u32), const 1_i32);
        (_13.0: u32) = Shr((_13.0: u32), const 1_i32);
        StorageLive(_14);
        StorageLive(_15);
        _15 = (_12.0: u32);
        StorageLive(_16);
        _16 = (_13.0: u32);
        _14 = Add(move _15, move _16);
        StorageDead(_16);
        StorageDead(_15);
        _3 = Shr(_3, move _14);
        StorageDead(_14);
        StorageLive(_17);
        StorageLive(_18);
        _18 = Foo::<u32>(const 2_u32);
        _17 = [move _18];
        StorageDead(_18);
        StorageLive(_19);
        _19 = const 0_usize;
        _20 = Len(_17);
        _21 = Lt(_19, _20);
        assert(move _21, "index out of bounds: the length is {} but the index is {}", move _20, _19) -> bb3;
    }

    bb3: {
        (_17[_19].0: u32) = Shr((_17[_19].0: u32), const 1_i32);
        StorageDead(_19);
        StorageLive(_22);
        StorageLive(_23);
        _23 = const 0_usize;
        _24 = Len(_17);
        _25 = Lt(_23, _24);
        assert(move _25, "index out of bounds: the length is {} but the index is {}", move _24, _23) -> bb4;
    }

    bb4: {
        _22 = (_17[_23].0: u32);
        _3 = Shr(_3, move _22);
        StorageDead(_22);
        StorageDead(_23);
        StorageLive(_26);
        StorageLive(_27);
        _27 = Bar::<u32> { x: const 2_u32 };
        _26 = [move _27];
        StorageDead(_27);
        StorageLive(_28);
        _28 = const 0_usize;
        _29 = Len(_26);
        _30 = Lt(_28, _29);
        assert(move _30, "index out of bounds: the length is {} but the index is {}", move _29, _28) -> bb5;
    }

    bb5: {
        (_26[_28].0: u32) = Shr((_26[_28].0: u32), const 1_i32);
        StorageDead(_28);
        StorageLive(_31);
        StorageLive(_32);
        _32 = const 0_usize;
        _33 = Len(_26);
        _34 = Lt(_32, _33);
        assert(move _34, "index out of bounds: the length is {} but the index is {}", move _33, _32) -> bb6;
    }

    bb6: {
        _31 = (_26[_32].0: u32);
        _3 = Shr(_3, move _31);
        StorageDead(_31);
        StorageDead(_32);
        StorageLive(_35);
        StorageLive(_36);
        _36 = [const 2_u32];
        _35 = Foo::<[u32; 1]>(move _36);
        StorageDead(_36);
        StorageLive(_37);
        _37 = const 0_usize;
        _38 = Len((_35.0: [u32; 1]));
        _39 = Lt(_37, _38);
        assert(move _39, "index out of bounds: the length is {} but the index is {}", move _38, _37) -> bb7;
    }

    bb7: {
        (_35.0: [u32; 1])[_37] = Shr((_35.0: [u32; 1])[_37], const 1_i32);
        StorageDead(_37);
        StorageLive(_40);
        StorageLive(_41);
        _41 = const 0_usize;
        _42 = Len((_35.0: [u32; 1]));
        _43 = Lt(_41, _42);
        assert(move _43, "index out of bounds: the length is {} but the index is {}", move _42, _41) -> bb8;
    }

    bb8: {
        _40 = (_35.0: [u32; 1])[_41];
        _3 = Shr(_3, move _40);
        StorageDead(_40);
        StorageDead(_41);
        StorageLive(_44);
        StorageLive(_45);
        _45 = [const 2_u32];
        _44 = Bar::<[u32; 1]> { x: move _45 };
        StorageDead(_45);
        StorageLive(_46);
        _46 = const 0_usize;
        _47 = Len((_44.0: [u32; 1]));
        _48 = Lt(_46, _47);
        assert(move _48, "index out of bounds: the length is {} but the index is {}", move _47, _46) -> bb9;
    }

    bb9: {
        (_44.0: [u32; 1])[_46] = Shr((_44.0: [u32; 1])[_46], const 1_i32);
        StorageDead(_46);
        StorageLive(_49);
        StorageLive(_50);
        _50 = const 0_usize;
        _51 = Len((_44.0: [u32; 1]));
        _52 = Lt(_50, _51);
        assert(move _52, "index out of bounds: the length is {} but the index is {}", move _51, _50) -> bb10;
    }

    bb10: {
        _49 = (_44.0: [u32; 1])[_50];
        _3 = Shr(_3, move _49);
        StorageDead(_49);
        StorageDead(_50);
        _0 = _3;
        StorageDead(_44);
        StorageDead(_35);
        StorageDead(_26);
        StorageDead(_17);
        StorageDead(_13);
        StorageDead(_12);
        StorageDead(_4);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

shr_assign::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

shr_assign::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

shr_assign::{constant#2}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

shr_assign::{constant#3}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

shr_assign::{constant#4}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

fn bit_and_assign(_1: W) -> u32 {
    let mut _0: u32;
    let _2: u32;
    let _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let mut _9: u32;
    let _10: usize;
    let mut _11: usize;
    let mut _12: bool;
    let mut _15: u32;
    let mut _16: u32;
    let mut _17: u32;
    let mut _19: Foo<u32>;
    let _20: usize;
    let mut _21: usize;
    let mut _22: bool;
    let mut _23: u32;
    let _24: usize;
    let mut _25: usize;
    let mut _26: bool;
    let mut _28: Bar<u32>;
    let _29: usize;
    let mut _30: usize;
    let mut _31: bool;
    let mut _32: u32;
    let _33: usize;
    let mut _34: usize;
    let mut _35: bool;
    let mut _37: [u32; 1];
    let _38: usize;
    let mut _39: usize;
    let mut _40: bool;
    let mut _41: u32;
    let _42: usize;
    let mut _43: usize;
    let mut _44: bool;
    let mut _46: [u32; 1];
    let _47: usize;
    let mut _48: usize;
    let mut _49: bool;
    let mut _50: u32;
    let _51: usize;
    let mut _52: usize;
    let mut _53: bool;
    scope 1 {
        debug a => _2;
        let _3: u32;
        scope 2 {
            debug f => _3;
            let mut _4: u32;
            scope 3 {
                debug d => _4;
                let mut _5: [u32; 1];
                scope 4 {
                    debug arr => _5;
                    let mut _13: Foo<u32>;
                    scope 5 {
                        debug foo => _13;
                        let mut _14: Bar<u32>;
                        scope 6 {
                            debug bar => _14;
                            let mut _18: [Foo<u32>; 1];
                            scope 7 {
                                debug arr => _18;
                                let mut _27: [Bar<u32>; 1];
                                scope 8 {
                                    debug arr => _27;
                                    let mut _36: Foo<[u32; 1]>;
                                    scope 9 {
                                        debug arr => _36;
                                        let mut _45: Bar<[u32; 1]>;
                                        scope 10 {
                                            debug arr => _45;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = (_1.0: u32);
        _3 = const 65535_u32;
        _4 = _2;
        _4 = BitAnd(_4, const 65534_u32);
        _5 = [_3];
        _6 = const 0_usize;
        _7 = const 1_usize;
        _8 = Lt(_6, _7);
        assert(move _8, "index out of bounds: the length is {} but the index is {}", move _7, _6) -> bb1;
    }

    bb1: {
        _5[_6] = BitAnd(_5[_6], const 65533_u32);
        _10 = const 0_usize;
        _11 = const 1_usize;
        _12 = Lt(_10, _11);
        assert(move _12, "index out of bounds: the length is {} but the index is {}", move _11, _10) -> bb2;
    }

    bb2: {
        _9 = _5[_10];
        _4 = BitAnd(_4, move _9);
        _13 = Foo::<u32>(_3);
        _14 = Bar::<u32> { x: _3 };
        (_13.0: u32) = BitAnd((_13.0: u32), const 65527_u32);
        (_14.0: u32) = BitAnd((_14.0: u32), const 65503_u32);
        _16 = (_13.0: u32);
        _17 = (_14.0: u32);
        _15 = BitAnd(move _16, move _17);
        _4 = BitAnd(_4, move _15);
        _19 = Foo::<u32>(_3);
        _18 = [move _19];
        _20 = const 0_usize;
        _21 = const 1_usize;
        _22 = Lt(_20, _21);
        assert(move _22, "index out of bounds: the length is {} but the index is {}", move _21, _20) -> bb3;
    }

    bb3: {
        (_18[_20].0: u32) = BitAnd((_18[_20].0: u32), const 65279_u32);
        _24 = const 0_usize;
        _25 = const 1_usize;
        _26 = Lt(_24, _25);
        assert(move _26, "index out of bounds: the length is {} but the index is {}", move _25, _24) -> bb4;
    }

    bb4: {
        _23 = (_18[_24].0: u32);
        _4 = BitAnd(_4, move _23);
        _28 = Bar::<u32> { x: _3 };
        _27 = [move _28];
        _29 = const 0_usize;
        _30 = const 1_usize;
        _31 = Lt(_29, _30);
        assert(move _31, "index out of bounds: the length is {} but the index is {}", move _30, _29) -> bb5;
    }

    bb5: {
        (_27[_29].0: u32) = BitAnd((_27[_29].0: u32), const 65023_u32);
        _33 = const 0_usize;
        _34 = const 1_usize;
        _35 = Lt(_33, _34);
        assert(move _35, "index out of bounds: the length is {} but the index is {}", move _34, _33) -> bb6;
    }

    bb6: {
        _32 = (_27[_33].0: u32);
        _4 = BitAnd(_4, move _32);
        _37 = [_3];
        _36 = Foo::<[u32; 1]>(move _37);
        _38 = const 0_usize;
        _39 = const 1_usize;
        _40 = Lt(_38, _39);
        assert(move _40, "index out of bounds: the length is {} but the index is {}", move _39, _38) -> bb7;
    }

    bb7: {
        (_36.0: [u32; 1])[_38] = BitAnd((_36.0: [u32; 1])[_38], const 49151_u32);
        _42 = const 0_usize;
        _43 = const 1_usize;
        _44 = Lt(_42, _43);
        assert(move _44, "index out of bounds: the length is {} but the index is {}", move _43, _42) -> bb8;
    }

    bb8: {
        _41 = (_36.0: [u32; 1])[_42];
        _4 = BitAnd(_4, move _41);
        _46 = [_3];
        _45 = Bar::<[u32; 1]> { x: move _46 };
        _47 = const 0_usize;
        _48 = const 1_usize;
        _49 = Lt(_47, _48);
        assert(move _49, "index out of bounds: the length is {} but the index is {}", move _48, _47) -> bb9;
    }

    bb9: {
        (_45.0: [u32; 1])[_47] = BitAnd((_45.0: [u32; 1])[_47], const 32767_u32);
        _51 = const 0_usize;
        _52 = const 1_usize;
        _53 = Lt(_51, _52);
        assert(move _53, "index out of bounds: the length is {} but the index is {}", move _52, _51) -> bb10;
    }

    bb10: {
        _50 = (_45.0: [u32; 1])[_51];
        _4 = BitAnd(_4, move _50);
        _0 = _4;
        return;
    }
}

// MIR FOR CTFE
fn bit_and_assign(_1: W) -> u32 {
    let mut _0: u32;
    let _2: u32;
    let mut _6: u32;
    let _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let mut _10: u32;
    let _11: usize;
    let mut _12: usize;
    let mut _13: bool;
    let mut _15: u32;
    let mut _17: u32;
    let mut _18: u32;
    let mut _19: u32;
    let mut _20: u32;
    let mut _22: Foo<u32>;
    let mut _23: u32;
    let _24: usize;
    let mut _25: usize;
    let mut _26: bool;
    let mut _27: u32;
    let _28: usize;
    let mut _29: usize;
    let mut _30: bool;
    let mut _32: Bar<u32>;
    let mut _33: u32;
    let _34: usize;
    let mut _35: usize;
    let mut _36: bool;
    let mut _37: u32;
    let _38: usize;
    let mut _39: usize;
    let mut _40: bool;
    let mut _42: [u32; 1];
    let mut _43: u32;
    let _44: usize;
    let mut _45: usize;
    let mut _46: bool;
    let mut _47: u32;
    let _48: usize;
    let mut _49: usize;
    let mut _50: bool;
    let mut _52: [u32; 1];
    let mut _53: u32;
    let _54: usize;
    let mut _55: usize;
    let mut _56: bool;
    let mut _57: u32;
    let _58: usize;
    let mut _59: usize;
    let mut _60: bool;
    scope 1 {
        debug a => _2;
        let _3: u32;
        scope 2 {
            debug f => _3;
            let mut _4: u32;
            scope 3 {
                debug d => _4;
                let mut _5: [u32; 1];
                scope 4 {
                    debug arr => _5;
                    let mut _14: Foo<u32>;
                    scope 5 {
                        debug foo => _14;
                        let mut _16: Bar<u32>;
                        scope 6 {
                            debug bar => _16;
                            let mut _21: [Foo<u32>; 1];
                            scope 7 {
                                debug arr => _21;
                                let mut _31: [Bar<u32>; 1];
                                scope 8 {
                                    debug arr => _31;
                                    let mut _41: Foo<[u32; 1]>;
                                    scope 9 {
                                        debug arr => _41;
                                        let mut _51: Bar<[u32; 1]>;
                                        scope 10 {
                                            debug arr => _51;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        StorageLive(_2);
        _2 = (_1.0: u32);
        StorageLive(_3);
        _3 = const 65535_u32;
        StorageLive(_4);
        _4 = _2;
        _4 = BitAnd(_4, const 65534_u32);
        StorageLive(_5);
        StorageLive(_6);
        _6 = _3;
        _5 = [move _6];
        StorageDead(_6);
        StorageLive(_7);
        _7 = const 0_usize;
        _8 = Len(_5);
        _9 = Lt(_7, _8);
        assert(move _9, "index out of bounds: the length is {} but the index is {}", move _8, _7) -> bb1;
    }

    bb1: {
        _5[_7] = BitAnd(_5[_7], const 65533_u32);
        StorageDead(_7);
        StorageLive(_10);
        StorageLive(_11);
        _11 = const 0_usize;
        _12 = Len(_5);
        _13 = Lt(_11, _12);
        assert(move _13, "index out of bounds: the length is {} but the index is {}", move _12, _11) -> bb2;
    }

    bb2: {
        _10 = _5[_11];
        _4 = BitAnd(_4, move _10);
        StorageDead(_10);
        StorageDead(_11);
        StorageLive(_14);
        StorageLive(_15);
        _15 = _3;
        _14 = Foo::<u32>(move _15);
        StorageDead(_15);
        StorageLive(_16);
        StorageLive(_17);
        _17 = _3;
        _16 = Bar::<u32> { x: move _17 };
        StorageDead(_17);
        (_14.0: u32) = BitAnd((_14.0: u32), const 65527_u32);
        (_16.0: u32) = BitAnd((_16.0: u32), const 65503_u32);
        StorageLive(_18);
        StorageLive(_19);
        _19 = (_14.0: u32);
        StorageLive(_20);
        _20 = (_16.0: u32);
        _18 = BitAnd(move _19, move _20);
        StorageDead(_20);
        StorageDead(_19);
        _4 = BitAnd(_4, move _18);
        StorageDead(_18);
        StorageLive(_21);
        StorageLive(_22);
        StorageLive(_23);
        _23 = _3;
        _22 = Foo::<u32>(move _23);
        StorageDead(_23);
        _21 = [move _22];
        StorageDead(_22);
        StorageLive(_24);
        _24 = const 0_usize;
        _25 = Len(_21);
        _26 = Lt(_24, _25);
        assert(move _26, "index out of bounds: the length is {} but the index is {}", move _25, _24) -> bb3;
    }

    bb3: {
        (_21[_24].0: u32) = BitAnd((_21[_24].0: u32), const 65279_u32);
        StorageDead(_24);
        StorageLive(_27);
        StorageLive(_28);
        _28 = const 0_usize;
        _29 = Len(_21);
        _30 = Lt(_28, _29);
        assert(move _30, "index out of bounds: the length is {} but the index is {}", move _29, _28) -> bb4;
    }

    bb4: {
        _27 = (_21[_28].0: u32);
        _4 = BitAnd(_4, move _27);
        StorageDead(_27);
        StorageDead(_28);
        StorageLive(_31);
        StorageLive(_32);
        StorageLive(_33);
        _33 = _3;
        _32 = Bar::<u32> { x: move _33 };
        StorageDead(_33);
        _31 = [move _32];
        StorageDead(_32);
        StorageLive(_34);
        _34 = const 0_usize;
        _35 = Len(_31);
        _36 = Lt(_34, _35);
        assert(move _36, "index out of bounds: the length is {} but the index is {}", move _35, _34) -> bb5;
    }

    bb5: {
        (_31[_34].0: u32) = BitAnd((_31[_34].0: u32), const 65023_u32);
        StorageDead(_34);
        StorageLive(_37);
        StorageLive(_38);
        _38 = const 0_usize;
        _39 = Len(_31);
        _40 = Lt(_38, _39);
        assert(move _40, "index out of bounds: the length is {} but the index is {}", move _39, _38) -> bb6;
    }

    bb6: {
        _37 = (_31[_38].0: u32);
        _4 = BitAnd(_4, move _37);
        StorageDead(_37);
        StorageDead(_38);
        StorageLive(_41);
        StorageLive(_42);
        StorageLive(_43);
        _43 = _3;
        _42 = [move _43];
        StorageDead(_43);
        _41 = Foo::<[u32; 1]>(move _42);
        StorageDead(_42);
        StorageLive(_44);
        _44 = const 0_usize;
        _45 = Len((_41.0: [u32; 1]));
        _46 = Lt(_44, _45);
        assert(move _46, "index out of bounds: the length is {} but the index is {}", move _45, _44) -> bb7;
    }

    bb7: {
        (_41.0: [u32; 1])[_44] = BitAnd((_41.0: [u32; 1])[_44], const 49151_u32);
        StorageDead(_44);
        StorageLive(_47);
        StorageLive(_48);
        _48 = const 0_usize;
        _49 = Len((_41.0: [u32; 1]));
        _50 = Lt(_48, _49);
        assert(move _50, "index out of bounds: the length is {} but the index is {}", move _49, _48) -> bb8;
    }

    bb8: {
        _47 = (_41.0: [u32; 1])[_48];
        _4 = BitAnd(_4, move _47);
        StorageDead(_47);
        StorageDead(_48);
        StorageLive(_51);
        StorageLive(_52);
        StorageLive(_53);
        _53 = _3;
        _52 = [move _53];
        StorageDead(_53);
        _51 = Bar::<[u32; 1]> { x: move _52 };
        StorageDead(_52);
        StorageLive(_54);
        _54 = const 0_usize;
        _55 = Len((_51.0: [u32; 1]));
        _56 = Lt(_54, _55);
        assert(move _56, "index out of bounds: the length is {} but the index is {}", move _55, _54) -> bb9;
    }

    bb9: {
        (_51.0: [u32; 1])[_54] = BitAnd((_51.0: [u32; 1])[_54], const 32767_u32);
        StorageDead(_54);
        StorageLive(_57);
        StorageLive(_58);
        _58 = const 0_usize;
        _59 = Len((_51.0: [u32; 1]));
        _60 = Lt(_58, _59);
        assert(move _60, "index out of bounds: the length is {} but the index is {}", move _59, _58) -> bb10;
    }

    bb10: {
        _57 = (_51.0: [u32; 1])[_58];
        _4 = BitAnd(_4, move _57);
        StorageDead(_57);
        StorageDead(_58);
        _0 = _4;
        StorageDead(_51);
        StorageDead(_41);
        StorageDead(_31);
        StorageDead(_21);
        StorageDead(_16);
        StorageDead(_14);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

bit_and_assign::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

bit_and_assign::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

bit_and_assign::{constant#2}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

bit_and_assign::{constant#3}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

bit_and_assign::{constant#4}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

fn bit_or_assign(_1: W) -> u32 {
    let mut _0: u32;
    let _2: u32;
    let _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let mut _9: u32;
    let _10: usize;
    let mut _11: usize;
    let mut _12: bool;
    let mut _15: u32;
    let mut _16: u32;
    let mut _17: u32;
    let mut _19: Foo<u32>;
    let _20: usize;
    let mut _21: usize;
    let mut _22: bool;
    let mut _23: u32;
    let _24: usize;
    let mut _25: usize;
    let mut _26: bool;
    let mut _28: Bar<u32>;
    let _29: usize;
    let mut _30: usize;
    let mut _31: bool;
    let mut _32: u32;
    let _33: usize;
    let mut _34: usize;
    let mut _35: bool;
    let mut _37: [u32; 1];
    let _38: usize;
    let mut _39: usize;
    let mut _40: bool;
    let mut _41: u32;
    let _42: usize;
    let mut _43: usize;
    let mut _44: bool;
    let mut _46: [u32; 1];
    let _47: usize;
    let mut _48: usize;
    let mut _49: bool;
    let mut _50: u32;
    let _51: usize;
    let mut _52: usize;
    let mut _53: bool;
    scope 1 {
        debug a => _2;
        let _3: u32;
        scope 2 {
            debug f => _3;
            let mut _4: u32;
            scope 3 {
                debug d => _4;
                let mut _5: [u32; 1];
                scope 4 {
                    debug arr => _5;
                    let mut _13: Foo<u32>;
                    scope 5 {
                        debug foo => _13;
                        let mut _14: Bar<u32>;
                        scope 6 {
                            debug bar => _14;
                            let mut _18: [Foo<u32>; 1];
                            scope 7 {
                                debug arr => _18;
                                let mut _27: [Bar<u32>; 1];
                                scope 8 {
                                    debug arr => _27;
                                    let mut _36: Foo<[u32; 1]>;
                                    scope 9 {
                                        debug arr => _36;
                                        let mut _45: Bar<[u32; 1]>;
                                        scope 10 {
                                            debug arr => _45;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = (_1.0: u32);
        _3 = const 0_u32;
        _4 = _2;
        _4 = BitOr(_4, const 1_u32);
        _5 = [_3];
        _6 = const 0_usize;
        _7 = const 1_usize;
        _8 = Lt(_6, _7);
        assert(move _8, "index out of bounds: the length is {} but the index is {}", move _7, _6) -> bb1;
    }

    bb1: {
        _5[_6] = BitOr(_5[_6], const 9_u32);
        _10 = const 0_usize;
        _11 = const 1_usize;
        _12 = Lt(_10, _11);
        assert(move _12, "index out of bounds: the length is {} but the index is {}", move _11, _10) -> bb2;
    }

    bb2: {
        _9 = _5[_10];
        _4 = BitOr(_4, move _9);
        _13 = Foo::<u32>(_3);
        _14 = Bar::<u32> { x: _3 };
        (_13.0: u32) = BitOr((_13.0: u32), const 16_u32);
        (_14.0: u32) = BitOr((_14.0: u32), const 64_u32);
        _16 = (_13.0: u32);
        _17 = (_14.0: u32);
        _15 = BitOr(move _16, move _17);
        _4 = BitOr(_4, move _15);
        _19 = Foo::<u32>(_3);
        _18 = [move _19];
        _20 = const 0_usize;
        _21 = const 1_usize;
        _22 = Lt(_20, _21);
        assert(move _22, "index out of bounds: the length is {} but the index is {}", move _21, _20) -> bb3;
    }

    bb3: {
        (_18[_20].0: u32) = BitOr((_18[_20].0: u32), const 256_u32);
        _24 = const 0_usize;
        _25 = const 1_usize;
        _26 = Lt(_24, _25);
        assert(move _26, "index out of bounds: the length is {} but the index is {}", move _25, _24) -> bb4;
    }

    bb4: {
        _23 = (_18[_24].0: u32);
        _4 = BitOr(_4, move _23);
        _28 = Bar::<u32> { x: _3 };
        _27 = [move _28];
        _29 = const 0_usize;
        _30 = const 1_usize;
        _31 = Lt(_29, _30);
        assert(move _31, "index out of bounds: the length is {} but the index is {}", move _30, _29) -> bb5;
    }

    bb5: {
        (_27[_29].0: u32) = BitOr((_27[_29].0: u32), const 512_u32);
        _33 = const 0_usize;
        _34 = const 1_usize;
        _35 = Lt(_33, _34);
        assert(move _35, "index out of bounds: the length is {} but the index is {}", move _34, _33) -> bb6;
    }

    bb6: {
        _32 = (_27[_33].0: u32);
        _4 = BitOr(_4, move _32);
        _37 = [_3];
        _36 = Foo::<[u32; 1]>(move _37);
        _38 = const 0_usize;
        _39 = const 1_usize;
        _40 = Lt(_38, _39);
        assert(move _40, "index out of bounds: the length is {} but the index is {}", move _39, _38) -> bb7;
    }

    bb7: {
        (_36.0: [u32; 1])[_38] = BitOr((_36.0: [u32; 1])[_38], const 32768_u32);
        _42 = const 0_usize;
        _43 = const 1_usize;
        _44 = Lt(_42, _43);
        assert(move _44, "index out of bounds: the length is {} but the index is {}", move _43, _42) -> bb8;
    }

    bb8: {
        _41 = (_36.0: [u32; 1])[_42];
        _4 = BitOr(_4, move _41);
        _46 = [_3];
        _45 = Bar::<[u32; 1]> { x: move _46 };
        _47 = const 0_usize;
        _48 = const 1_usize;
        _49 = Lt(_47, _48);
        assert(move _49, "index out of bounds: the length is {} but the index is {}", move _48, _47) -> bb9;
    }

    bb9: {
        (_45.0: [u32; 1])[_47] = BitOr((_45.0: [u32; 1])[_47], const 49152_u32);
        _51 = const 0_usize;
        _52 = const 1_usize;
        _53 = Lt(_51, _52);
        assert(move _53, "index out of bounds: the length is {} but the index is {}", move _52, _51) -> bb10;
    }

    bb10: {
        _50 = (_45.0: [u32; 1])[_51];
        _4 = BitOr(_4, move _50);
        _0 = _4;
        return;
    }
}

// MIR FOR CTFE
fn bit_or_assign(_1: W) -> u32 {
    let mut _0: u32;
    let _2: u32;
    let mut _6: u32;
    let _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let mut _10: u32;
    let _11: usize;
    let mut _12: usize;
    let mut _13: bool;
    let mut _15: u32;
    let mut _17: u32;
    let mut _18: u32;
    let mut _19: u32;
    let mut _20: u32;
    let mut _22: Foo<u32>;
    let mut _23: u32;
    let _24: usize;
    let mut _25: usize;
    let mut _26: bool;
    let mut _27: u32;
    let _28: usize;
    let mut _29: usize;
    let mut _30: bool;
    let mut _32: Bar<u32>;
    let mut _33: u32;
    let _34: usize;
    let mut _35: usize;
    let mut _36: bool;
    let mut _37: u32;
    let _38: usize;
    let mut _39: usize;
    let mut _40: bool;
    let mut _42: [u32; 1];
    let mut _43: u32;
    let _44: usize;
    let mut _45: usize;
    let mut _46: bool;
    let mut _47: u32;
    let _48: usize;
    let mut _49: usize;
    let mut _50: bool;
    let mut _52: [u32; 1];
    let mut _53: u32;
    let _54: usize;
    let mut _55: usize;
    let mut _56: bool;
    let mut _57: u32;
    let _58: usize;
    let mut _59: usize;
    let mut _60: bool;
    scope 1 {
        debug a => _2;
        let _3: u32;
        scope 2 {
            debug f => _3;
            let mut _4: u32;
            scope 3 {
                debug d => _4;
                let mut _5: [u32; 1];
                scope 4 {
                    debug arr => _5;
                    let mut _14: Foo<u32>;
                    scope 5 {
                        debug foo => _14;
                        let mut _16: Bar<u32>;
                        scope 6 {
                            debug bar => _16;
                            let mut _21: [Foo<u32>; 1];
                            scope 7 {
                                debug arr => _21;
                                let mut _31: [Bar<u32>; 1];
                                scope 8 {
                                    debug arr => _31;
                                    let mut _41: Foo<[u32; 1]>;
                                    scope 9 {
                                        debug arr => _41;
                                        let mut _51: Bar<[u32; 1]>;
                                        scope 10 {
                                            debug arr => _51;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        StorageLive(_2);
        _2 = (_1.0: u32);
        StorageLive(_3);
        _3 = const 0_u32;
        StorageLive(_4);
        _4 = _2;
        _4 = BitOr(_4, const 1_u32);
        StorageLive(_5);
        StorageLive(_6);
        _6 = _3;
        _5 = [move _6];
        StorageDead(_6);
        StorageLive(_7);
        _7 = const 0_usize;
        _8 = Len(_5);
        _9 = Lt(_7, _8);
        assert(move _9, "index out of bounds: the length is {} but the index is {}", move _8, _7) -> bb1;
    }

    bb1: {
        _5[_7] = BitOr(_5[_7], const 9_u32);
        StorageDead(_7);
        StorageLive(_10);
        StorageLive(_11);
        _11 = const 0_usize;
        _12 = Len(_5);
        _13 = Lt(_11, _12);
        assert(move _13, "index out of bounds: the length is {} but the index is {}", move _12, _11) -> bb2;
    }

    bb2: {
        _10 = _5[_11];
        _4 = BitOr(_4, move _10);
        StorageDead(_10);
        StorageDead(_11);
        StorageLive(_14);
        StorageLive(_15);
        _15 = _3;
        _14 = Foo::<u32>(move _15);
        StorageDead(_15);
        StorageLive(_16);
        StorageLive(_17);
        _17 = _3;
        _16 = Bar::<u32> { x: move _17 };
        StorageDead(_17);
        (_14.0: u32) = BitOr((_14.0: u32), const 16_u32);
        (_16.0: u32) = BitOr((_16.0: u32), const 64_u32);
        StorageLive(_18);
        StorageLive(_19);
        _19 = (_14.0: u32);
        StorageLive(_20);
        _20 = (_16.0: u32);
        _18 = BitOr(move _19, move _20);
        StorageDead(_20);
        StorageDead(_19);
        _4 = BitOr(_4, move _18);
        StorageDead(_18);
        StorageLive(_21);
        StorageLive(_22);
        StorageLive(_23);
        _23 = _3;
        _22 = Foo::<u32>(move _23);
        StorageDead(_23);
        _21 = [move _22];
        StorageDead(_22);
        StorageLive(_24);
        _24 = const 0_usize;
        _25 = Len(_21);
        _26 = Lt(_24, _25);
        assert(move _26, "index out of bounds: the length is {} but the index is {}", move _25, _24) -> bb3;
    }

    bb3: {
        (_21[_24].0: u32) = BitOr((_21[_24].0: u32), const 256_u32);
        StorageDead(_24);
        StorageLive(_27);
        StorageLive(_28);
        _28 = const 0_usize;
        _29 = Len(_21);
        _30 = Lt(_28, _29);
        assert(move _30, "index out of bounds: the length is {} but the index is {}", move _29, _28) -> bb4;
    }

    bb4: {
        _27 = (_21[_28].0: u32);
        _4 = BitOr(_4, move _27);
        StorageDead(_27);
        StorageDead(_28);
        StorageLive(_31);
        StorageLive(_32);
        StorageLive(_33);
        _33 = _3;
        _32 = Bar::<u32> { x: move _33 };
        StorageDead(_33);
        _31 = [move _32];
        StorageDead(_32);
        StorageLive(_34);
        _34 = const 0_usize;
        _35 = Len(_31);
        _36 = Lt(_34, _35);
        assert(move _36, "index out of bounds: the length is {} but the index is {}", move _35, _34) -> bb5;
    }

    bb5: {
        (_31[_34].0: u32) = BitOr((_31[_34].0: u32), const 512_u32);
        StorageDead(_34);
        StorageLive(_37);
        StorageLive(_38);
        _38 = const 0_usize;
        _39 = Len(_31);
        _40 = Lt(_38, _39);
        assert(move _40, "index out of bounds: the length is {} but the index is {}", move _39, _38) -> bb6;
    }

    bb6: {
        _37 = (_31[_38].0: u32);
        _4 = BitOr(_4, move _37);
        StorageDead(_37);
        StorageDead(_38);
        StorageLive(_41);
        StorageLive(_42);
        StorageLive(_43);
        _43 = _3;
        _42 = [move _43];
        StorageDead(_43);
        _41 = Foo::<[u32; 1]>(move _42);
        StorageDead(_42);
        StorageLive(_44);
        _44 = const 0_usize;
        _45 = Len((_41.0: [u32; 1]));
        _46 = Lt(_44, _45);
        assert(move _46, "index out of bounds: the length is {} but the index is {}", move _45, _44) -> bb7;
    }

    bb7: {
        (_41.0: [u32; 1])[_44] = BitOr((_41.0: [u32; 1])[_44], const 32768_u32);
        StorageDead(_44);
        StorageLive(_47);
        StorageLive(_48);
        _48 = const 0_usize;
        _49 = Len((_41.0: [u32; 1]));
        _50 = Lt(_48, _49);
        assert(move _50, "index out of bounds: the length is {} but the index is {}", move _49, _48) -> bb8;
    }

    bb8: {
        _47 = (_41.0: [u32; 1])[_48];
        _4 = BitOr(_4, move _47);
        StorageDead(_47);
        StorageDead(_48);
        StorageLive(_51);
        StorageLive(_52);
        StorageLive(_53);
        _53 = _3;
        _52 = [move _53];
        StorageDead(_53);
        _51 = Bar::<[u32; 1]> { x: move _52 };
        StorageDead(_52);
        StorageLive(_54);
        _54 = const 0_usize;
        _55 = Len((_51.0: [u32; 1]));
        _56 = Lt(_54, _55);
        assert(move _56, "index out of bounds: the length is {} but the index is {}", move _55, _54) -> bb9;
    }

    bb9: {
        (_51.0: [u32; 1])[_54] = BitOr((_51.0: [u32; 1])[_54], const 49152_u32);
        StorageDead(_54);
        StorageLive(_57);
        StorageLive(_58);
        _58 = const 0_usize;
        _59 = Len((_51.0: [u32; 1]));
        _60 = Lt(_58, _59);
        assert(move _60, "index out of bounds: the length is {} but the index is {}", move _59, _58) -> bb10;
    }

    bb10: {
        _57 = (_51.0: [u32; 1])[_58];
        _4 = BitOr(_4, move _57);
        StorageDead(_57);
        StorageDead(_58);
        _0 = _4;
        StorageDead(_51);
        StorageDead(_41);
        StorageDead(_31);
        StorageDead(_21);
        StorageDead(_16);
        StorageDead(_14);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

bit_or_assign::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

bit_or_assign::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

bit_or_assign::{constant#2}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

bit_or_assign::{constant#3}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

bit_or_assign::{constant#4}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

fn bit_xor_assign(_1: W) -> u32 {
    let mut _0: u32;
    let _2: u32;
    let _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let mut _9: u32;
    let _10: usize;
    let mut _11: usize;
    let mut _12: bool;
    let mut _15: u32;
    let mut _16: u32;
    let mut _17: u32;
    let mut _19: Foo<u32>;
    let _20: usize;
    let mut _21: usize;
    let mut _22: bool;
    let mut _23: u32;
    let _24: usize;
    let mut _25: usize;
    let mut _26: bool;
    let mut _28: Bar<u32>;
    let _29: usize;
    let mut _30: usize;
    let mut _31: bool;
    let mut _32: u32;
    let _33: usize;
    let mut _34: usize;
    let mut _35: bool;
    let mut _37: [u32; 1];
    let _38: usize;
    let mut _39: usize;
    let mut _40: bool;
    let mut _41: u32;
    let _42: usize;
    let mut _43: usize;
    let mut _44: bool;
    let mut _46: [u32; 1];
    let _47: usize;
    let mut _48: usize;
    let mut _49: bool;
    let mut _50: u32;
    let _51: usize;
    let mut _52: usize;
    let mut _53: bool;
    scope 1 {
        debug a => _2;
        let _3: u32;
        scope 2 {
            debug f => _3;
            let mut _4: u32;
            scope 3 {
                debug d => _4;
                let mut _5: [u32; 1];
                scope 4 {
                    debug arr => _5;
                    let mut _13: Foo<u32>;
                    scope 5 {
                        debug foo => _13;
                        let mut _14: Bar<u32>;
                        scope 6 {
                            debug bar => _14;
                            let mut _18: [Foo<u32>; 1];
                            scope 7 {
                                debug arr => _18;
                                let mut _27: [Bar<u32>; 1];
                                scope 8 {
                                    debug arr => _27;
                                    let mut _36: Foo<[u32; 1]>;
                                    scope 9 {
                                        debug arr => _36;
                                        let mut _45: Bar<[u32; 1]>;
                                        scope 10 {
                                            debug arr => _45;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = (_1.0: u32);
        _3 = const 0_u32;
        _4 = _2;
        _4 = BitXor(_4, const 1_u32);
        _5 = [_3];
        _6 = const 0_usize;
        _7 = const 1_usize;
        _8 = Lt(_6, _7);
        assert(move _8, "index out of bounds: the length is {} but the index is {}", move _7, _6) -> bb1;
    }

    bb1: {
        _5[_6] = BitXor(_5[_6], const 2_u32);
        _10 = const 0_usize;
        _11 = const 1_usize;
        _12 = Lt(_10, _11);
        assert(move _12, "index out of bounds: the length is {} but the index is {}", move _11, _10) -> bb2;
    }

    bb2: {
        _9 = _5[_10];
        _4 = BitXor(_4, move _9);
        _13 = Foo::<u32>(_3);
        _14 = Bar::<u32> { x: _3 };
        (_13.0: u32) = BitXor((_13.0: u32), const 16_u32);
        (_14.0: u32) = BitXor((_14.0: u32), const 128_u32);
        _16 = (_13.0: u32);
        _17 = (_14.0: u32);
        _15 = BitXor(move _16, move _17);
        _4 = BitXor(_4, move _15);
        _19 = Foo::<u32>(_3);
        _18 = [move _19];
        _20 = const 0_usize;
        _21 = const 1_usize;
        _22 = Lt(_20, _21);
        assert(move _22, "index out of bounds: the length is {} but the index is {}", move _21, _20) -> bb3;
    }

    bb3: {
        (_18[_20].0: u32) = BitXor((_18[_20].0: u32), const 256_u32);
        _24 = const 0_usize;
        _25 = const 1_usize;
        _26 = Lt(_24, _25);
        assert(move _26, "index out of bounds: the length is {} but the index is {}", move _25, _24) -> bb4;
    }

    bb4: {
        _23 = (_18[_24].0: u32);
        _4 = BitXor(_4, move _23);
        _28 = Bar::<u32> { x: _3 };
        _27 = [move _28];
        _29 = const 0_usize;
        _30 = const 1_usize;
        _31 = Lt(_29, _30);
        assert(move _31, "index out of bounds: the length is {} but the index is {}", move _30, _29) -> bb5;
    }

    bb5: {
        (_27[_29].0: u32) = BitXor((_27[_29].0: u32), const 512_u32);
        _33 = const 0_usize;
        _34 = const 1_usize;
        _35 = Lt(_33, _34);
        assert(move _35, "index out of bounds: the length is {} but the index is {}", move _34, _33) -> bb6;
    }

    bb6: {
        _32 = (_27[_33].0: u32);
        _4 = BitXor(_4, move _32);
        _37 = [_3];
        _36 = Foo::<[u32; 1]>(move _37);
        _38 = const 0_usize;
        _39 = const 1_usize;
        _40 = Lt(_38, _39);
        assert(move _40, "index out of bounds: the length is {} but the index is {}", move _39, _38) -> bb7;
    }

    bb7: {
        (_36.0: [u32; 1])[_38] = BitXor((_36.0: [u32; 1])[_38], const 16384_u32);
        _42 = const 0_usize;
        _43 = const 1_usize;
        _44 = Lt(_42, _43);
        assert(move _44, "index out of bounds: the length is {} but the index is {}", move _43, _42) -> bb8;
    }

    bb8: {
        _41 = (_36.0: [u32; 1])[_42];
        _4 = BitXor(_4, move _41);
        _46 = [_3];
        _45 = Bar::<[u32; 1]> { x: move _46 };
        _47 = const 0_usize;
        _48 = const 1_usize;
        _49 = Lt(_47, _48);
        assert(move _49, "index out of bounds: the length is {} but the index is {}", move _48, _47) -> bb9;
    }

    bb9: {
        (_45.0: [u32; 1])[_47] = BitXor((_45.0: [u32; 1])[_47], const 32768_u32);
        _51 = const 0_usize;
        _52 = const 1_usize;
        _53 = Lt(_51, _52);
        assert(move _53, "index out of bounds: the length is {} but the index is {}", move _52, _51) -> bb10;
    }

    bb10: {
        _50 = (_45.0: [u32; 1])[_51];
        _4 = BitXor(_4, move _50);
        _0 = _4;
        return;
    }
}

// MIR FOR CTFE
fn bit_xor_assign(_1: W) -> u32 {
    let mut _0: u32;
    let _2: u32;
    let mut _6: u32;
    let _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let mut _10: u32;
    let _11: usize;
    let mut _12: usize;
    let mut _13: bool;
    let mut _15: u32;
    let mut _17: u32;
    let mut _18: u32;
    let mut _19: u32;
    let mut _20: u32;
    let mut _22: Foo<u32>;
    let mut _23: u32;
    let _24: usize;
    let mut _25: usize;
    let mut _26: bool;
    let mut _27: u32;
    let _28: usize;
    let mut _29: usize;
    let mut _30: bool;
    let mut _32: Bar<u32>;
    let mut _33: u32;
    let _34: usize;
    let mut _35: usize;
    let mut _36: bool;
    let mut _37: u32;
    let _38: usize;
    let mut _39: usize;
    let mut _40: bool;
    let mut _42: [u32; 1];
    let mut _43: u32;
    let _44: usize;
    let mut _45: usize;
    let mut _46: bool;
    let mut _47: u32;
    let _48: usize;
    let mut _49: usize;
    let mut _50: bool;
    let mut _52: [u32; 1];
    let mut _53: u32;
    let _54: usize;
    let mut _55: usize;
    let mut _56: bool;
    let mut _57: u32;
    let _58: usize;
    let mut _59: usize;
    let mut _60: bool;
    scope 1 {
        debug a => _2;
        let _3: u32;
        scope 2 {
            debug f => _3;
            let mut _4: u32;
            scope 3 {
                debug d => _4;
                let mut _5: [u32; 1];
                scope 4 {
                    debug arr => _5;
                    let mut _14: Foo<u32>;
                    scope 5 {
                        debug foo => _14;
                        let mut _16: Bar<u32>;
                        scope 6 {
                            debug bar => _16;
                            let mut _21: [Foo<u32>; 1];
                            scope 7 {
                                debug arr => _21;
                                let mut _31: [Bar<u32>; 1];
                                scope 8 {
                                    debug arr => _31;
                                    let mut _41: Foo<[u32; 1]>;
                                    scope 9 {
                                        debug arr => _41;
                                        let mut _51: Bar<[u32; 1]>;
                                        scope 10 {
                                            debug arr => _51;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        StorageLive(_2);
        _2 = (_1.0: u32);
        StorageLive(_3);
        _3 = const 0_u32;
        StorageLive(_4);
        _4 = _2;
        _4 = BitXor(_4, const 1_u32);
        StorageLive(_5);
        StorageLive(_6);
        _6 = _3;
        _5 = [move _6];
        StorageDead(_6);
        StorageLive(_7);
        _7 = const 0_usize;
        _8 = Len(_5);
        _9 = Lt(_7, _8);
        assert(move _9, "index out of bounds: the length is {} but the index is {}", move _8, _7) -> bb1;
    }

    bb1: {
        _5[_7] = BitXor(_5[_7], const 2_u32);
        StorageDead(_7);
        StorageLive(_10);
        StorageLive(_11);
        _11 = const 0_usize;
        _12 = Len(_5);
        _13 = Lt(_11, _12);
        assert(move _13, "index out of bounds: the length is {} but the index is {}", move _12, _11) -> bb2;
    }

    bb2: {
        _10 = _5[_11];
        _4 = BitXor(_4, move _10);
        StorageDead(_10);
        StorageDead(_11);
        StorageLive(_14);
        StorageLive(_15);
        _15 = _3;
        _14 = Foo::<u32>(move _15);
        StorageDead(_15);
        StorageLive(_16);
        StorageLive(_17);
        _17 = _3;
        _16 = Bar::<u32> { x: move _17 };
        StorageDead(_17);
        (_14.0: u32) = BitXor((_14.0: u32), const 16_u32);
        (_16.0: u32) = BitXor((_16.0: u32), const 128_u32);
        StorageLive(_18);
        StorageLive(_19);
        _19 = (_14.0: u32);
        StorageLive(_20);
        _20 = (_16.0: u32);
        _18 = BitXor(move _19, move _20);
        StorageDead(_20);
        StorageDead(_19);
        _4 = BitXor(_4, move _18);
        StorageDead(_18);
        StorageLive(_21);
        StorageLive(_22);
        StorageLive(_23);
        _23 = _3;
        _22 = Foo::<u32>(move _23);
        StorageDead(_23);
        _21 = [move _22];
        StorageDead(_22);
        StorageLive(_24);
        _24 = const 0_usize;
        _25 = Len(_21);
        _26 = Lt(_24, _25);
        assert(move _26, "index out of bounds: the length is {} but the index is {}", move _25, _24) -> bb3;
    }

    bb3: {
        (_21[_24].0: u32) = BitXor((_21[_24].0: u32), const 256_u32);
        StorageDead(_24);
        StorageLive(_27);
        StorageLive(_28);
        _28 = const 0_usize;
        _29 = Len(_21);
        _30 = Lt(_28, _29);
        assert(move _30, "index out of bounds: the length is {} but the index is {}", move _29, _28) -> bb4;
    }

    bb4: {
        _27 = (_21[_28].0: u32);
        _4 = BitXor(_4, move _27);
        StorageDead(_27);
        StorageDead(_28);
        StorageLive(_31);
        StorageLive(_32);
        StorageLive(_33);
        _33 = _3;
        _32 = Bar::<u32> { x: move _33 };
        StorageDead(_33);
        _31 = [move _32];
        StorageDead(_32);
        StorageLive(_34);
        _34 = const 0_usize;
        _35 = Len(_31);
        _36 = Lt(_34, _35);
        assert(move _36, "index out of bounds: the length is {} but the index is {}", move _35, _34) -> bb5;
    }

    bb5: {
        (_31[_34].0: u32) = BitXor((_31[_34].0: u32), const 512_u32);
        StorageDead(_34);
        StorageLive(_37);
        StorageLive(_38);
        _38 = const 0_usize;
        _39 = Len(_31);
        _40 = Lt(_38, _39);
        assert(move _40, "index out of bounds: the length is {} but the index is {}", move _39, _38) -> bb6;
    }

    bb6: {
        _37 = (_31[_38].0: u32);
        _4 = BitXor(_4, move _37);
        StorageDead(_37);
        StorageDead(_38);
        StorageLive(_41);
        StorageLive(_42);
        StorageLive(_43);
        _43 = _3;
        _42 = [move _43];
        StorageDead(_43);
        _41 = Foo::<[u32; 1]>(move _42);
        StorageDead(_42);
        StorageLive(_44);
        _44 = const 0_usize;
        _45 = Len((_41.0: [u32; 1]));
        _46 = Lt(_44, _45);
        assert(move _46, "index out of bounds: the length is {} but the index is {}", move _45, _44) -> bb7;
    }

    bb7: {
        (_41.0: [u32; 1])[_44] = BitXor((_41.0: [u32; 1])[_44], const 16384_u32);
        StorageDead(_44);
        StorageLive(_47);
        StorageLive(_48);
        _48 = const 0_usize;
        _49 = Len((_41.0: [u32; 1]));
        _50 = Lt(_48, _49);
        assert(move _50, "index out of bounds: the length is {} but the index is {}", move _49, _48) -> bb8;
    }

    bb8: {
        _47 = (_41.0: [u32; 1])[_48];
        _4 = BitXor(_4, move _47);
        StorageDead(_47);
        StorageDead(_48);
        StorageLive(_51);
        StorageLive(_52);
        StorageLive(_53);
        _53 = _3;
        _52 = [move _53];
        StorageDead(_53);
        _51 = Bar::<[u32; 1]> { x: move _52 };
        StorageDead(_52);
        StorageLive(_54);
        _54 = const 0_usize;
        _55 = Len((_51.0: [u32; 1]));
        _56 = Lt(_54, _55);
        assert(move _56, "index out of bounds: the length is {} but the index is {}", move _55, _54) -> bb9;
    }

    bb9: {
        (_51.0: [u32; 1])[_54] = BitXor((_51.0: [u32; 1])[_54], const 32768_u32);
        StorageDead(_54);
        StorageLive(_57);
        StorageLive(_58);
        _58 = const 0_usize;
        _59 = Len((_51.0: [u32; 1]));
        _60 = Lt(_58, _59);
        assert(move _60, "index out of bounds: the length is {} but the index is {}", move _59, _58) -> bb10;
    }

    bb10: {
        _57 = (_51.0: [u32; 1])[_58];
        _4 = BitXor(_4, move _57);
        StorageDead(_57);
        StorageDead(_58);
        _0 = _4;
        StorageDead(_51);
        StorageDead(_41);
        StorageDead(_31);
        StorageDead(_21);
        StorageDead(_16);
        StorageDead(_14);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

bit_xor_assign::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

bit_xor_assign::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

bit_xor_assign::{constant#2}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

bit_xor_assign::{constant#3}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

bit_xor_assign::{constant#4}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let mut _1: (&u32, &u32);
    let mut _2: &u32;
    let _3: u32;
    let mut _4: &u32;
    let _5: u32;
    let _6: &u32;
    let _7: &u32;
    let mut _8: bool;
    let mut _9: bool;
    let mut _10: u32;
    let mut _11: u32;
    let _13: !;
    let mut _14: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _15: (&u32, &u32);
    let mut _16: &u32;
    let _17: u32;
    let mut _18: (u32,);
    let mut _19: &u32;
    let _20: u32;
    let _21: &u32;
    let _22: &u32;
    let mut _23: bool;
    let mut _24: bool;
    let mut _25: u32;
    let mut _26: u32;
    let _28: !;
    let mut _29: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _30: (&u32, &u32);
    let mut _31: &u32;
    let _32: u32;
    let mut _33: &u32;
    let _34: u32;
    let _35: &u32;
    let _36: &u32;
    let mut _37: bool;
    let mut _38: bool;
    let mut _39: u32;
    let mut _40: u32;
    let _42: !;
    let mut _43: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _44: (&u32, &u32);
    let mut _45: &u32;
    let _46: u32;
    let mut _47: W;
    let mut _48: &u32;
    let _49: u32;
    let _50: &u32;
    let _51: &u32;
    let mut _52: bool;
    let mut _53: bool;
    let mut _54: u32;
    let mut _55: u32;
    let _57: !;
    let mut _58: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _59: (&u32, &u32);
    let mut _60: &u32;
    let _61: u32;
    let mut _62: &u32;
    let _63: u32;
    let _64: &u32;
    let _65: &u32;
    let mut _66: bool;
    let mut _67: bool;
    let mut _68: u32;
    let mut _69: u32;
    let _71: !;
    let mut _72: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _73: (&u32, &u32);
    let mut _74: &u32;
    let _75: u32;
    let mut _76: A;
    let mut _77: &u32;
    let _78: u32;
    let _79: &u32;
    let _80: &u32;
    let mut _81: bool;
    let mut _82: bool;
    let mut _83: u32;
    let mut _84: u32;
    let _86: !;
    let mut _87: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _88: (&u32, &u32);
    let mut _89: &u32;
    let _90: u32;
    let mut _91: &u32;
    let _92: u32;
    let _93: &u32;
    let _94: &u32;
    let mut _95: bool;
    let mut _96: bool;
    let mut _97: u32;
    let mut _98: u32;
    let _100: !;
    let mut _101: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _102: (&u32, &u32);
    let mut _103: &u32;
    let _104: u32;
    let mut _105: [u32; 1];
    let mut _106: &u32;
    let _107: u32;
    let _108: &u32;
    let _109: &u32;
    let mut _110: bool;
    let mut _111: bool;
    let mut _112: u32;
    let mut _113: u32;
    let _115: !;
    let mut _116: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _117: (&u32, &u32);
    let mut _118: &u32;
    let _119: u32;
    let mut _120: &u32;
    let _121: u32;
    let _122: &u32;
    let _123: &u32;
    let mut _124: bool;
    let mut _125: bool;
    let mut _126: u32;
    let mut _127: u32;
    let _129: !;
    let mut _130: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _131: (&u32, &u32);
    let mut _132: &u32;
    let _133: u32;
    let mut _134: W;
    let mut _135: &u32;
    let _136: u32;
    let _137: &u32;
    let _138: &u32;
    let mut _139: bool;
    let mut _140: bool;
    let mut _141: u32;
    let mut _142: u32;
    let _144: !;
    let mut _145: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _146: (&u32, &u32);
    let mut _147: &u32;
    let _148: u32;
    let mut _149: &u32;
    let _150: u32;
    let _151: &u32;
    let _152: &u32;
    let mut _153: bool;
    let mut _154: bool;
    let mut _155: u32;
    let mut _156: u32;
    let _158: !;
    let mut _159: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _160: (&u32, &u32);
    let mut _161: &u32;
    let _162: u32;
    let mut _163: W;
    let mut _164: &u32;
    let _165: u32;
    let _166: &u32;
    let _167: &u32;
    let mut _168: bool;
    let mut _169: bool;
    let mut _170: u32;
    let mut _171: u32;
    let _173: !;
    let mut _174: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _175: (&u32, &u32);
    let mut _176: &u32;
    let _177: u32;
    let mut _178: &u32;
    let _179: u32;
    let _180: &u32;
    let _181: &u32;
    let mut _182: bool;
    let mut _183: bool;
    let mut _184: u32;
    let mut _185: u32;
    let _187: !;
    let mut _188: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _189: (&u32, &u32);
    let mut _190: &u32;
    let _191: u32;
    let mut _192: W;
    let mut _193: &u32;
    let _194: u32;
    let _195: &u32;
    let _196: &u32;
    let mut _197: bool;
    let mut _198: bool;
    let mut _199: u32;
    let mut _200: u32;
    let _202: !;
    let mut _203: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _204: (&u32, &u32);
    let mut _205: &u32;
    let _206: u32;
    let mut _207: &u32;
    let _208: u32;
    let _209: &u32;
    let _210: &u32;
    let mut _211: bool;
    let mut _212: bool;
    let mut _213: u32;
    let mut _214: u32;
    let _216: !;
    let mut _217: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _218: (&u32, &u32);
    let mut _219: &u32;
    let _220: u32;
    let mut _221: W;
    let mut _222: &u32;
    let _223: u32;
    let _224: &u32;
    let _225: &u32;
    let mut _226: bool;
    let mut _227: bool;
    let mut _228: u32;
    let mut _229: u32;
    let _231: !;
    let mut _232: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _233: (&u32, &u32);
    let mut _234: &u32;
    let _235: u32;
    let mut _236: &u32;
    let _237: u32;
    let _238: &u32;
    let _239: &u32;
    let mut _240: bool;
    let mut _241: bool;
    let mut _242: u32;
    let mut _243: u32;
    let _245: !;
    let mut _246: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _247: (&u32, &u32);
    let mut _248: &u32;
    let _249: u32;
    let mut _250: W;
    let mut _251: &u32;
    let _252: u32;
    let _253: &u32;
    let _254: &u32;
    let mut _255: bool;
    let mut _256: bool;
    let mut _257: u32;
    let mut _258: u32;
    let _260: !;
    let mut _261: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _262: (&u32, &u32);
    let mut _263: &u32;
    let _264: u32;
    let mut _265: &u32;
    let _266: u32;
    let _267: &u32;
    let _268: &u32;
    let mut _269: bool;
    let mut _270: bool;
    let mut _271: u32;
    let mut _272: u32;
    let _274: !;
    let mut _275: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _276: (&u32, &u32);
    let mut _277: &u32;
    let _278: u32;
    let mut _279: W;
    let mut _280: &u32;
    let _281: u32;
    let _282: &u32;
    let _283: &u32;
    let mut _284: bool;
    let mut _285: bool;
    let mut _286: u32;
    let mut _287: u32;
    let _289: !;
    let mut _290: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _291: (&u32, &u32);
    let mut _292: &u32;
    let _293: u32;
    let mut _294: &u32;
    let _295: u32;
    let _296: &u32;
    let _297: &u32;
    let mut _298: bool;
    let mut _299: bool;
    let mut _300: u32;
    let mut _301: u32;
    let _303: !;
    let mut _304: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _305: (&u32, &u32);
    let mut _306: &u32;
    let _307: u32;
    let mut _308: W;
    let mut _309: &u32;
    let _310: u32;
    let _311: &u32;
    let _312: &u32;
    let mut _313: bool;
    let mut _314: bool;
    let mut _315: u32;
    let mut _316: u32;
    let _318: !;
    let mut _319: std::option::Option<std::fmt::Arguments<'_>>;
    scope 1 {
        debug left_val => _6;
        debug right_val => _7;
        let _12: core::panicking::AssertKind;
        scope 2 {
            debug kind => _12;
        }
    }
    scope 3 {
        debug left_val => _21;
        debug right_val => _22;
        let _27: core::panicking::AssertKind;
        scope 4 {
            debug kind => _27;
        }
    }
    scope 5 {
        debug left_val => _35;
        debug right_val => _36;
        let _41: core::panicking::AssertKind;
        scope 6 {
            debug kind => _41;
        }
    }
    scope 7 {
        debug left_val => _50;
        debug right_val => _51;
        let _56: core::panicking::AssertKind;
        scope 8 {
            debug kind => _56;
        }
    }
    scope 9 {
        debug left_val => _64;
        debug right_val => _65;
        let _70: core::panicking::AssertKind;
        scope 10 {
            debug kind => _70;
        }
    }
    scope 11 {
        debug left_val => _79;
        debug right_val => _80;
        let _85: core::panicking::AssertKind;
        scope 12 {
            debug kind => _85;
        }
    }
    scope 13 {
        debug left_val => _93;
        debug right_val => _94;
        let _99: core::panicking::AssertKind;
        scope 14 {
            debug kind => _99;
        }
    }
    scope 15 {
        debug left_val => _108;
        debug right_val => _109;
        let _114: core::panicking::AssertKind;
        scope 16 {
            debug kind => _114;
        }
    }
    scope 17 {
        debug left_val => _122;
        debug right_val => _123;
        let _128: core::panicking::AssertKind;
        scope 18 {
            debug kind => _128;
        }
    }
    scope 19 {
        debug left_val => _137;
        debug right_val => _138;
        let _143: core::panicking::AssertKind;
        scope 20 {
            debug kind => _143;
        }
    }
    scope 21 {
        debug left_val => _151;
        debug right_val => _152;
        let _157: core::panicking::AssertKind;
        scope 22 {
            debug kind => _157;
        }
    }
    scope 23 {
        debug left_val => _166;
        debug right_val => _167;
        let _172: core::panicking::AssertKind;
        scope 24 {
            debug kind => _172;
        }
    }
    scope 25 {
        debug left_val => _180;
        debug right_val => _181;
        let _186: core::panicking::AssertKind;
        scope 26 {
            debug kind => _186;
        }
    }
    scope 27 {
        debug left_val => _195;
        debug right_val => _196;
        let _201: core::panicking::AssertKind;
        scope 28 {
            debug kind => _201;
        }
    }
    scope 29 {
        debug left_val => _209;
        debug right_val => _210;
        let _215: core::panicking::AssertKind;
        scope 30 {
            debug kind => _215;
        }
    }
    scope 31 {
        debug left_val => _224;
        debug right_val => _225;
        let _230: core::panicking::AssertKind;
        scope 32 {
            debug kind => _230;
        }
    }
    scope 33 {
        debug left_val => _238;
        debug right_val => _239;
        let _244: core::panicking::AssertKind;
        scope 34 {
            debug kind => _244;
        }
    }
    scope 35 {
        debug left_val => _253;
        debug right_val => _254;
        let _259: core::panicking::AssertKind;
        scope 36 {
            debug kind => _259;
        }
    }
    scope 37 {
        debug left_val => _267;
        debug right_val => _268;
        let _273: core::panicking::AssertKind;
        scope 38 {
            debug kind => _273;
        }
    }
    scope 39 {
        debug left_val => _282;
        debug right_val => _283;
        let _288: core::panicking::AssertKind;
        scope 40 {
            debug kind => _288;
        }
    }
    scope 41 {
        debug left_val => _296;
        debug right_val => _297;
        let _302: core::panicking::AssertKind;
        scope 42 {
            debug kind => _302;
        }
    }
    scope 43 {
        debug left_val => _311;
        debug right_val => _312;
        let _317: core::panicking::AssertKind;
        scope 44 {
            debug kind => _317;
        }
    }

    bb0: {
        _3 = const _;
        _2 = &_3;
        _5 = const 13_u32;
        _4 = &_5;
        _1 = (move _2, move _4);
        _6 = (_1.0: &u32);
        _7 = (_1.1: &u32);
        _10 = (*_6);
        _11 = (*_7);
        _9 = Eq(move _10, move _11);
        _8 = Not(move _9);
        switchInt(move _8) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _12 = core::panicking::AssertKind::Eq;
        _14 = Option::<Arguments<'_>>::None;
        _13 = core::panicking::assert_failed::<u32, u32>(move _12, _6, _7, move _14);
    }

    bb2: {
        _18 = (const 2_u32,);
        _17 = basics(move _18) -> bb3;
    }

    bb3: {
        _16 = &_17;
        _20 = const 13_u32;
        _19 = &_20;
        _15 = (move _16, move _19);
        _21 = (_15.0: &u32);
        _22 = (_15.1: &u32);
        _25 = (*_21);
        _26 = (*_22);
        _24 = Eq(move _25, move _26);
        _23 = Not(move _24);
        switchInt(move _23) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _27 = core::panicking::AssertKind::Eq;
        _29 = Option::<Arguments<'_>>::None;
        _28 = core::panicking::assert_failed::<u32, u32>(move _27, _21, _22, move _29);
    }

    bb5: {
        _32 = const _;
        _31 = &_32;
        _34 = const 10_u32;
        _33 = &_34;
        _30 = (move _31, move _33);
        _35 = (_30.0: &u32);
        _36 = (_30.1: &u32);
        _39 = (*_35);
        _40 = (*_36);
        _38 = Eq(move _39, move _40);
        _37 = Not(move _38);
        switchInt(move _37) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _41 = core::panicking::AssertKind::Eq;
        _43 = Option::<Arguments<'_>>::None;
        _42 = core::panicking::assert_failed::<u32, u32>(move _41, _35, _36, move _43);
    }

    bb7: {
        _47 = W(const 1_u32);
        _46 = add_assign(move _47) -> bb8;
    }

    bb8: {
        _45 = &_46;
        _49 = const 10_u32;
        _48 = &_49;
        _44 = (move _45, move _48);
        _50 = (_44.0: &u32);
        _51 = (_44.1: &u32);
        _54 = (*_50);
        _55 = (*_51);
        _53 = Eq(move _54, move _55);
        _52 = Not(move _53);
        switchInt(move _52) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _56 = core::panicking::AssertKind::Eq;
        _58 = Option::<Arguments<'_>>::None;
        _57 = core::panicking::assert_failed::<u32, u32>(move _56, _50, _51, move _58);
    }

    bb10: {
        _61 = const _;
        _60 = &_61;
        _63 = const 256_u32;
        _62 = &_63;
        _59 = (move _60, move _62);
        _64 = (_59.0: &u32);
        _65 = (_59.1: &u32);
        _68 = (*_64);
        _69 = (*_65);
        _67 = Eq(move _68, move _69);
        _66 = Not(move _67);
        switchInt(move _66) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _70 = core::panicking::AssertKind::Eq;
        _72 = Option::<Arguments<'_>>::None;
        _71 = core::panicking::assert_failed::<u32, u32>(move _70, _64, _65, move _72);
    }

    bb12: {
        _76 = A { a: const 0_u32 };
        _75 = mul_assign(move _76) -> bb13;
    }

    bb13: {
        _74 = &_75;
        _78 = const 256_u32;
        _77 = &_78;
        _73 = (move _74, move _77);
        _79 = (_73.0: &u32);
        _80 = (_73.1: &u32);
        _83 = (*_79);
        _84 = (*_80);
        _82 = Eq(move _83, move _84);
        _81 = Not(move _82);
        switchInt(move _81) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _85 = core::panicking::AssertKind::Eq;
        _87 = Option::<Arguments<'_>>::None;
        _86 = core::panicking::assert_failed::<u32, u32>(move _85, _79, _80, move _87);
    }

    bb15: {
        _90 = const _;
        _89 = &_90;
        _92 = const 4_u32;
        _91 = &_92;
        _88 = (move _89, move _91);
        _93 = (_88.0: &u32);
        _94 = (_88.1: &u32);
        _97 = (*_93);
        _98 = (*_94);
        _96 = Eq(move _97, move _98);
        _95 = Not(move _96);
        switchInt(move _95) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _99 = core::panicking::AssertKind::Eq;
        _101 = Option::<Arguments<'_>>::None;
        _100 = core::panicking::assert_failed::<u32, u32>(move _99, _93, _94, move _101);
    }

    bb17: {
        _105 = [const 1_u32];
        _104 = div_assign(move _105) -> bb18;
    }

    bb18: {
        _103 = &_104;
        _107 = const 4_u32;
        _106 = &_107;
        _102 = (move _103, move _106);
        _108 = (_102.0: &u32);
        _109 = (_102.1: &u32);
        _112 = (*_108);
        _113 = (*_109);
        _111 = Eq(move _112, move _113);
        _110 = Not(move _111);
        switchInt(move _110) -> [0: bb20, otherwise: bb19];
    }

    bb19: {
        _114 = core::panicking::AssertKind::Eq;
        _116 = Option::<Arguments<'_>>::None;
        _115 = core::panicking::assert_failed::<u32, u32>(move _114, _108, _109, move _116);
    }

    bb20: {
        _119 = const _;
        _118 = &_119;
        _121 = const 5_u32;
        _120 = &_121;
        _117 = (move _118, move _120);
        _122 = (_117.0: &u32);
        _123 = (_117.1: &u32);
        _126 = (*_122);
        _127 = (*_123);
        _125 = Eq(move _126, move _127);
        _124 = Not(move _125);
        switchInt(move _124) -> [0: bb22, otherwise: bb21];
    }

    bb21: {
        _128 = core::panicking::AssertKind::Eq;
        _130 = Option::<Arguments<'_>>::None;
        _129 = core::panicking::assert_failed::<u32, u32>(move _128, _122, _123, move _130);
    }

    bb22: {
        _134 = W(const 5_u32);
        _133 = rem_assign(move _134) -> bb23;
    }

    bb23: {
        _132 = &_133;
        _136 = const 5_u32;
        _135 = &_136;
        _131 = (move _132, move _135);
        _137 = (_131.0: &u32);
        _138 = (_131.1: &u32);
        _141 = (*_137);
        _142 = (*_138);
        _140 = Eq(move _141, move _142);
        _139 = Not(move _140);
        switchInt(move _139) -> [0: bb25, otherwise: bb24];
    }

    bb24: {
        _143 = core::panicking::AssertKind::Eq;
        _145 = Option::<Arguments<'_>>::None;
        _144 = core::panicking::assert_failed::<u32, u32>(move _143, _137, _138, move _145);
    }

    bb25: {
        _148 = const _;
        _147 = &_148;
        _150 = const 0_u32;
        _149 = &_150;
        _146 = (move _147, move _149);
        _151 = (_146.0: &u32);
        _152 = (_146.1: &u32);
        _155 = (*_151);
        _156 = (*_152);
        _154 = Eq(move _155, move _156);
        _153 = Not(move _154);
        switchInt(move _153) -> [0: bb27, otherwise: bb26];
    }

    bb26: {
        _157 = core::panicking::AssertKind::Eq;
        _159 = Option::<Arguments<'_>>::None;
        _158 = core::panicking::assert_failed::<u32, u32>(move _157, _151, _152, move _159);
    }

    bb27: {
        _163 = W(const 8_u32);
        _162 = sub_assign(move _163) -> bb28;
    }

    bb28: {
        _161 = &_162;
        _165 = const 0_u32;
        _164 = &_165;
        _160 = (move _161, move _164);
        _166 = (_160.0: &u32);
        _167 = (_160.1: &u32);
        _170 = (*_166);
        _171 = (*_167);
        _169 = Eq(move _170, move _171);
        _168 = Not(move _169);
        switchInt(move _168) -> [0: bb30, otherwise: bb29];
    }

    bb29: {
        _172 = core::panicking::AssertKind::Eq;
        _174 = Option::<Arguments<'_>>::None;
        _173 = core::panicking::assert_failed::<u32, u32>(move _172, _166, _167, move _174);
    }

    bb30: {
        _177 = const _;
        _176 = &_177;
        _179 = const 32768_u32;
        _178 = &_179;
        _175 = (move _176, move _178);
        _180 = (_175.0: &u32);
        _181 = (_175.1: &u32);
        _184 = (*_180);
        _185 = (*_181);
        _183 = Eq(move _184, move _185);
        _182 = Not(move _183);
        switchInt(move _182) -> [0: bb32, otherwise: bb31];
    }

    bb31: {
        _186 = core::panicking::AssertKind::Eq;
        _188 = Option::<Arguments<'_>>::None;
        _187 = core::panicking::assert_failed::<u32, u32>(move _186, _180, _181, move _188);
    }

    bb32: {
        _192 = W(const 1_u32);
        _191 = shl_assign(move _192) -> bb33;
    }

    bb33: {
        _190 = &_191;
        _194 = const 32768_u32;
        _193 = &_194;
        _189 = (move _190, move _193);
        _195 = (_189.0: &u32);
        _196 = (_189.1: &u32);
        _199 = (*_195);
        _200 = (*_196);
        _198 = Eq(move _199, move _200);
        _197 = Not(move _198);
        switchInt(move _197) -> [0: bb35, otherwise: bb34];
    }

    bb34: {
        _201 = core::panicking::AssertKind::Eq;
        _203 = Option::<Arguments<'_>>::None;
        _202 = core::panicking::assert_failed::<u32, u32>(move _201, _195, _196, move _203);
    }

    bb35: {
        _206 = const _;
        _205 = &_206;
        _208 = const 1_u32;
        _207 = &_208;
        _204 = (move _205, move _207);
        _209 = (_204.0: &u32);
        _210 = (_204.1: &u32);
        _213 = (*_209);
        _214 = (*_210);
        _212 = Eq(move _213, move _214);
        _211 = Not(move _212);
        switchInt(move _211) -> [0: bb37, otherwise: bb36];
    }

    bb36: {
        _215 = core::panicking::AssertKind::Eq;
        _217 = Option::<Arguments<'_>>::None;
        _216 = core::panicking::assert_failed::<u32, u32>(move _215, _209, _210, move _217);
    }

    bb37: {
        _221 = W(const 256_u32);
        _220 = shr_assign(move _221) -> bb38;
    }

    bb38: {
        _219 = &_220;
        _223 = const 1_u32;
        _222 = &_223;
        _218 = (move _219, move _222);
        _224 = (_218.0: &u32);
        _225 = (_218.1: &u32);
        _228 = (*_224);
        _229 = (*_225);
        _227 = Eq(move _228, move _229);
        _226 = Not(move _227);
        switchInt(move _226) -> [0: bb40, otherwise: bb39];
    }

    bb39: {
        _230 = core::panicking::AssertKind::Eq;
        _232 = Option::<Arguments<'_>>::None;
        _231 = core::panicking::assert_failed::<u32, u32>(move _230, _224, _225, move _232);
    }

    bb40: {
        _235 = const _;
        _234 = &_235;
        _237 = const 15572_u32;
        _236 = &_237;
        _233 = (move _234, move _236);
        _238 = (_233.0: &u32);
        _239 = (_233.1: &u32);
        _242 = (*_238);
        _243 = (*_239);
        _241 = Eq(move _242, move _243);
        _240 = Not(move _241);
        switchInt(move _240) -> [0: bb42, otherwise: bb41];
    }

    bb41: {
        _244 = core::panicking::AssertKind::Eq;
        _246 = Option::<Arguments<'_>>::None;
        _245 = core::panicking::assert_failed::<u32, u32>(move _244, _238, _239, move _246);
    }

    bb42: {
        _250 = W(const 786431_u32);
        _249 = bit_and_assign(move _250) -> bb43;
    }

    bb43: {
        _248 = &_249;
        _252 = const 15572_u32;
        _251 = &_252;
        _247 = (move _248, move _251);
        _253 = (_247.0: &u32);
        _254 = (_247.1: &u32);
        _257 = (*_253);
        _258 = (*_254);
        _256 = Eq(move _257, move _258);
        _255 = Not(move _256);
        switchInt(move _255) -> [0: bb45, otherwise: bb44];
    }

    bb44: {
        _259 = core::panicking::AssertKind::Eq;
        _261 = Option::<Arguments<'_>>::None;
        _260 = core::panicking::assert_failed::<u32, u32>(move _259, _253, _254, move _261);
    }

    bb45: {
        _264 = const _;
        _263 = &_264;
        _266 = const 62297_u32;
        _265 = &_266;
        _262 = (move _263, move _265);
        _267 = (_262.0: &u32);
        _268 = (_262.1: &u32);
        _271 = (*_267);
        _272 = (*_268);
        _270 = Eq(move _271, move _272);
        _269 = Not(move _270);
        switchInt(move _269) -> [0: bb47, otherwise: bb46];
    }

    bb46: {
        _273 = core::panicking::AssertKind::Eq;
        _275 = Option::<Arguments<'_>>::None;
        _274 = core::panicking::assert_failed::<u32, u32>(move _273, _267, _268, move _275);
    }

    bb47: {
        _279 = W(const 45056_u32);
        _278 = bit_or_assign(move _279) -> bb48;
    }

    bb48: {
        _277 = &_278;
        _281 = const 62297_u32;
        _280 = &_281;
        _276 = (move _277, move _280);
        _282 = (_276.0: &u32);
        _283 = (_276.1: &u32);
        _286 = (*_282);
        _287 = (*_283);
        _285 = Eq(move _286, move _287);
        _284 = Not(move _285);
        switchInt(move _284) -> [0: bb50, otherwise: bb49];
    }

    bb49: {
        _288 = core::panicking::AssertKind::Eq;
        _290 = Option::<Arguments<'_>>::None;
        _289 = core::panicking::assert_failed::<u32, u32>(move _288, _282, _283, move _290);
    }

    bb50: {
        _293 = const _;
        _292 = &_293;
        _295 = const 50067_u32;
        _294 = &_295;
        _291 = (move _292, move _294);
        _296 = (_291.0: &u32);
        _297 = (_291.1: &u32);
        _300 = (*_296);
        _301 = (*_297);
        _299 = Eq(move _300, move _301);
        _298 = Not(move _299);
        switchInt(move _298) -> [0: bb52, otherwise: bb51];
    }

    bb51: {
        _302 = core::panicking::AssertKind::Eq;
        _304 = Option::<Arguments<'_>>::None;
        _303 = core::panicking::assert_failed::<u32, u32>(move _302, _296, _297, move _304);
    }

    bb52: {
        _308 = W(const 0_u32);
        _307 = bit_xor_assign(move _308) -> bb53;
    }

    bb53: {
        _306 = &_307;
        _310 = const 50067_u32;
        _309 = &_310;
        _305 = (move _306, move _309);
        _311 = (_305.0: &u32);
        _312 = (_305.1: &u32);
        _315 = (*_311);
        _316 = (*_312);
        _314 = Eq(move _315, move _316);
        _313 = Not(move _314);
        switchInt(move _313) -> [0: bb55, otherwise: bb54];
    }

    bb54: {
        _317 = core::panicking::AssertKind::Eq;
        _319 = Option::<Arguments<'_>>::None;
        _318 = core::panicking::assert_failed::<u32, u32>(move _317, _311, _312, move _319);
    }

    bb55: {
        return;
    }
}

const BASICS: u32 = {
    let mut _0: u32;
    let mut _1: (u32,);

    bb0: {
        StorageLive(_1);
        _1 = (const 2_u32,);
        ConstEvalCounter;
        _0 = basics(move _1) -> bb1;
    }

    bb1: {
        StorageDead(_1);
        return;
    }
}

const ADD: u32 = {
    let mut _0: u32;
    let mut _1: W;

    bb0: {
        StorageLive(_1);
        _1 = W(const 1_u32);
        ConstEvalCounter;
        _0 = add_assign(move _1) -> bb1;
    }

    bb1: {
        StorageDead(_1);
        return;
    }
}

const MUL: u32 = {
    let mut _0: u32;
    let mut _1: A;

    bb0: {
        StorageLive(_1);
        _1 = A { a: const 0_u32 };
        ConstEvalCounter;
        _0 = mul_assign(move _1) -> bb1;
    }

    bb1: {
        StorageDead(_1);
        return;
    }
}

const DIV: u32 = {
    let mut _0: u32;
    let mut _1: [u32; 1];

    bb0: {
        StorageLive(_1);
        _1 = [const 1_u32];
        ConstEvalCounter;
        _0 = div_assign(move _1) -> bb1;
    }

    bb1: {
        StorageDead(_1);
        return;
    }
}

const REM: u32 = {
    let mut _0: u32;
    let mut _1: W;

    bb0: {
        StorageLive(_1);
        _1 = W(const 5_u32);
        ConstEvalCounter;
        _0 = rem_assign(move _1) -> bb1;
    }

    bb1: {
        StorageDead(_1);
        return;
    }
}

const SUB: u32 = {
    let mut _0: u32;
    let mut _1: W;

    bb0: {
        StorageLive(_1);
        _1 = W(const 8_u32);
        ConstEvalCounter;
        _0 = sub_assign(move _1) -> bb1;
    }

    bb1: {
        StorageDead(_1);
        return;
    }
}

const SHL: u32 = {
    let mut _0: u32;
    let mut _1: W;

    bb0: {
        StorageLive(_1);
        _1 = W(const 1_u32);
        ConstEvalCounter;
        _0 = shl_assign(move _1) -> bb1;
    }

    bb1: {
        StorageDead(_1);
        return;
    }
}

const SHR: u32 = {
    let mut _0: u32;
    let mut _1: W;

    bb0: {
        StorageLive(_1);
        _1 = W(const 256_u32);
        ConstEvalCounter;
        _0 = shr_assign(move _1) -> bb1;
    }

    bb1: {
        StorageDead(_1);
        return;
    }
}

const AND: u32 = {
    let mut _0: u32;
    let mut _1: W;

    bb0: {
        StorageLive(_1);
        _1 = W(const 786431_u32);
        ConstEvalCounter;
        _0 = bit_and_assign(move _1) -> bb1;
    }

    bb1: {
        StorageDead(_1);
        return;
    }
}

const OR: u32 = {
    let mut _0: u32;
    let mut _1: W;

    bb0: {
        StorageLive(_1);
        _1 = W(const 45056_u32);
        ConstEvalCounter;
        _0 = bit_or_assign(move _1) -> bb1;
    }

    bb1: {
        StorageDead(_1);
        return;
    }
}

const XOR: u32 = {
    let mut _0: u32;
    let mut _1: W;

    bb0: {
        StorageLive(_1);
        _1 = W(const 0_u32);
        ConstEvalCounter;
        _0 = bit_xor_assign(move _1) -> bb1;
    }

    bb1: {
        StorageDead(_1);
        return;
    }
}

fn Foo(_1: T) -> Foo<T> {
    let mut _0: Foo<T>;

    bb0: {
        _0 = Foo::<T>(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Foo(_1: T) -> Foo<T> {
    let mut _0: Foo<T>;

    bb0: {
        _0 = Foo::<T>(move _1);
        return;
    }
}

fn W(_1: u32) -> W {
    let mut _0: W;

    bb0: {
        _0 = W(move _1);
        return;
    }
}

// MIR FOR CTFE
fn W(_1: u32) -> W {
    let mut _0: W;

    bb0: {
        _0 = W(move _1);
        return;
    }
}
