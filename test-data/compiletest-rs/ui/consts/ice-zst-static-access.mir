// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn <impl at ui/consts/ice-zst-static-access.rs:8:16: 8:21>::clone(_1: &Glfw) -> Glfw {
    debug self => _1;
    let mut _0: Glfw;

    bb0: {
        return;
    }
}

static mut GLFW: Option<Glfw> = {
    let mut _0: std::option::Option<Glfw>;

    bb0: {
        _0 = Option::<Glfw>::None;
        return;
    }
}

fn new() -> Glfw {
    let mut _0: Glfw;
    let mut _1: *mut std::option::Option<Glfw>;
    let mut _2: isize;
    let mut _3: !;
    scope 1 {
        scope 2 {
            debug glfw => const Glfw;
            let mut _4: *const ();
            let mut _5: usize;
            let mut _6: usize;
            let mut _7: usize;
            let mut _8: usize;
            let mut _9: bool;
            let mut _10: *const ();
            let mut _11: usize;
            let mut _12: usize;
            let mut _13: usize;
            let mut _14: usize;
            let mut _15: bool;
        }
    }

    bb0: {
        _1 = const {alloc1: *mut Option<Glfw>};
        _10 = _1 as *const () (PtrToPtr);
        _11 = _10 as usize (Transmute);
        _12 = AlignOf(std::option::Option<Glfw>);
        _13 = Sub(_12, const 1_usize);
        _14 = BitAnd(_11, _13);
        _15 = Eq(_14, const 0_usize);
        assert(_15, "misaligned pointer dereference: address must be a multiple of {} but is {}", _12, _11) -> [success: bb4, unwind unreachable];
    }

    bb1: {
        _4 = _1 as *const () (PtrToPtr);
        _5 = _4 as usize (Transmute);
        _6 = AlignOf(std::option::Option<Glfw>);
        _7 = Sub(_6, const 1_usize);
        _8 = BitAnd(_5, _7);
        _9 = Eq(_8, const 0_usize);
        assert(_9, "misaligned pointer dereference: address must be a multiple of {} but is {}", _6, _5) -> [success: bb3, unwind unreachable];
    }

    bb2: {
        _3 = core::panicking::panic(const "not yet implemented");
    }

    bb3: {
        return;
    }

    bb4: {
        _2 = discriminant((*_1));
        switchInt(move _2) -> [1: bb1, otherwise: bb2];
    }
}

alloc1 (static: GLFW, size: 1, align: 1) {
    00                                              â”‚ .
}

_dispatch_queue_attr_concurrent::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 0_usize;
        return;
    }
}

static DISPATCH_QUEUE_CONCURRENT: &[u8; 0] = {
    let mut _0: &[u8; 0];
    let _1: &[u8; 0];
    let _2: *const [u8; 0];
    scope 1 {
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _2 = const {alloc2: *const [u8; 0]};
        _1 = &(*_2);
        _0 = &(*_1);
        StorageDead(_1);
        return;
    }
}

alloc2 (extern static: _dispatch_queue_attr_concurrent)

DISPATCH_QUEUE_CONCURRENT::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 0_usize;
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let _1: Glfw;

    bb0: {
        _1 = new() -> bb1;
    }

    bb1: {
        return;
    }
}
