// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn drain(_1: &mut G, _2: Vec<(R, GeneratorState<Y, <G as Generator<R>>::Return>)>) -> () {
    debug gen => _1;
    debug inout => _2;
    let mut _0: ();
    let mut _3: std::pin::Pin<&mut G>;
    let mut _4: std::vec::IntoIter<(R, std::ops::GeneratorState<Y, <G as std::ops::Generator<R>>::Return>)>;
    let mut _5: std::vec::Vec<(R, std::ops::GeneratorState<Y, <G as std::ops::Generator<R>>::Return>)>;
    let mut _7: std::option::Option<(R, std::ops::GeneratorState<Y, <G as std::ops::Generator<R>>::Return>)>;
    let mut _8: &mut std::vec::IntoIter<(R, std::ops::GeneratorState<Y, <G as std::ops::Generator<R>>::Return>)>;
    let mut _9: isize;
    let mut _12: (&std::ops::GeneratorState<Y, <G as std::ops::Generator<R>>::Return>, &std::ops::GeneratorState<Y, <G as std::ops::Generator<R>>::Return>);
    let mut _13: &std::ops::GeneratorState<Y, <G as std::ops::Generator<R>>::Return>;
    let _14: std::ops::GeneratorState<Y, <G as std::ops::Generator<R>>::Return>;
    let mut _15: std::pin::Pin<&mut G>;
    let mut _16: &mut std::pin::Pin<&mut G>;
    let mut _17: R;
    let mut _18: &std::ops::GeneratorState<Y, <G as std::ops::Generator<R>>::Return>;
    let mut _21: bool;
    let mut _22: bool;
    let _24: !;
    let mut _25: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _26: bool;
    let mut _27: bool;
    scope 1 {
        debug gen => _3;
        let mut _6: std::vec::IntoIter<(R, std::ops::GeneratorState<Y, <G as std::ops::Generator<R>>::Return>)>;
        scope 2 {
            debug iter => _6;
            let _10: R;
            let _11: std::ops::GeneratorState<Y, <G as std::ops::Generator<R>>::Return>;
            scope 3 {
                debug input => _10;
                debug out => _11;
                let _19: &std::ops::GeneratorState<Y, <G as std::ops::Generator<R>>::Return>;
                let _20: &std::ops::GeneratorState<Y, <G as std::ops::Generator<R>>::Return>;
                scope 4 {
                    debug left_val => _19;
                    debug right_val => _20;
                    let _23: core::panicking::AssertKind;
                    scope 5 {
                        debug kind => _23;
                    }
                }
            }
        }
    }

    bb0: {
        _27 = const false;
        _26 = const false;
        _27 = const true;
        _3 = Pin::<&mut G>::new(move _1) -> [return: bb1, unwind: bb23];
    }

    bb1: {
        _27 = const false;
        _5 = move _2;
        _4 = <Vec<(R, GeneratorState<Y, <G as Generator<R>>::Return>)> as IntoIterator>::into_iter(move _5) -> [return: bb2, unwind: bb23];
    }

    bb2: {
        _6 = move _4;
        goto -> bb3;
    }

    bb3: {
        _8 = &mut _6;
        _7 = <std::vec::IntoIter<(R, GeneratorState<Y, <G as Generator<R>>::Return>)> as Iterator>::next(_8) -> [return: bb4, unwind: bb18];
    }

    bb4: {
        _9 = discriminant(_7);
        switchInt(move _9) -> [0: bb7, 1: bb5, otherwise: bb6];
    }

    bb5: {
        _26 = const true;
        _10 = move (((_7 as Some).0: (R, std::ops::GeneratorState<Y, <G as std::ops::Generator<R>>::Return>)).0: R);
        _11 = move (((_7 as Some).0: (R, std::ops::GeneratorState<Y, <G as std::ops::Generator<R>>::Return>)).1: std::ops::GeneratorState<Y, <G as std::ops::Generator<R>>::Return>);
        _16 = &mut _3;
        _15 = Pin::<&mut G>::as_mut(move _16) -> [return: bb8, unwind: bb17];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        drop(_6) -> [return: bb15, unwind: bb23];
    }

    bb8: {
        _26 = const false;
        _17 = move _10;
        _14 = <G as Generator<R>>::resume(move _15, move _17) -> [return: bb9, unwind: bb17];
    }

    bb9: {
        _13 = &_14;
        _18 = &_11;
        _12 = (move _13, move _18);
        _19 = (_12.0: &std::ops::GeneratorState<Y, <G as std::ops::Generator<R>>::Return>);
        _20 = (_12.1: &std::ops::GeneratorState<Y, <G as std::ops::Generator<R>>::Return>);
        _22 = <GeneratorState<Y, <G as Generator<R>>::Return> as PartialEq>::eq(_19, _20) -> [return: bb10, unwind: bb16];
    }

    bb10: {
        _21 = Not(move _22);
        switchInt(move _21) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _23 = core::panicking::AssertKind::Eq;
        _25 = Option::<Arguments<'_>>::None;
        _24 = core::panicking::assert_failed::<GeneratorState<Y, <G as Generator<R>>::Return>, GeneratorState<Y, <G as Generator<R>>::Return>>(move _23, _19, _20, move _25) -> bb16;
    }

    bb12: {
        drop(_14) -> [return: bb13, unwind: bb17];
    }

    bb13: {
        drop(_11) -> [return: bb14, unwind: bb21];
    }

    bb14: {
        _26 = const false;
        goto -> bb3;
    }

    bb15: {
        return;
    }

    bb16 (cleanup): {
        drop(_14) -> [return: bb17, unwind terminate];
    }

    bb17 (cleanup): {
        drop(_11) -> [return: bb21, unwind terminate];
    }

    bb18 (cleanup): {
        drop(_6) -> [return: bb23, unwind terminate];
    }

    bb19 (cleanup): {
        resume;
    }

    bb20 (cleanup): {
        drop(_10) -> [return: bb18, unwind terminate];
    }

    bb21 (cleanup): {
        switchInt(_26) -> [0: bb18, otherwise: bb20];
    }

    bb22 (cleanup): {
        drop(_2) -> [return: bb19, unwind terminate];
    }

    bb23 (cleanup): {
        switchInt(_27) -> [0: bb19, otherwise: bb22];
    }
}

static DROPS: AtomicUsize = {
    let mut _0: std::sync::atomic::AtomicUsize;

    bb0: {
        ConstEvalCounter;
        _0 = AtomicUsize::new(const 0_usize) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/generator/smoke-resume-args.rs:33:10: 33:15>::fmt(_1: &DropMe, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "DropMe";
        _0 = Formatter::<'_>::write_str(_2, _3) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/generator/smoke-resume-args.rs:33:17: 33:26>::eq(_1: &DropMe, _2: &DropMe) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;

    bb0: {
        _0 = const true;
        return;
    }
}

fn <impl at ui/generator/smoke-resume-args.rs:36:1: 36:21>::drop(_1: &mut DropMe) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: usize;
    let _3: &std::sync::atomic::AtomicUsize;
    let mut _4: std::sync::atomic::Ordering;

    bb0: {
        _3 = const {alloc1: &AtomicUsize};
        _4 = SeqCst;
        _2 = AtomicUsize::fetch_add(_3, const 1_usize, move _4) -> bb1;
    }

    bb1: {
        return;
    }
}

alloc1 (static: DROPS, size: 8, align: 8) {
    00 00 00 00 00 00 00 00                         │ ........
}

fn expect_drops(_1: usize, _2: impl FnOnce() -> T) -> T {
    debug expected_drops => _1;
    debug f => _2;
    let mut _0: T;
    let _3: ();
    let _4: &std::sync::atomic::AtomicUsize;
    let mut _5: std::sync::atomic::Ordering;
    let _6: T;
    let mut _7: impl FnOnce() -> T;
    let _9: &std::sync::atomic::AtomicUsize;
    let mut _10: std::sync::atomic::Ordering;
    let mut _11: (&usize, &usize);
    let mut _12: &usize;
    let mut _13: &usize;
    let mut _16: bool;
    let mut _17: bool;
    let mut _18: usize;
    let mut _19: usize;
    let _21: !;
    let mut _22: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _23: bool;
    scope 1 {
        debug res => _6;
        let _8: usize;
        scope 2 {
            debug actual_drops => _8;
            let _14: &usize;
            let _15: &usize;
            scope 3 {
                debug left_val => _14;
                debug right_val => _15;
                let _20: core::panicking::AssertKind;
                scope 4 {
                    debug kind => _20;
                }
            }
        }
    }

    bb0: {
        _23 = const false;
        _23 = const true;
        _4 = const {alloc1: &AtomicUsize};
        _5 = SeqCst;
        _3 = AtomicUsize::store(_4, const 0_usize, move _5) -> [return: bb1, unwind: bb9];
    }

    bb1: {
        _23 = const false;
        _7 = move _2;
        _6 = <impl FnOnce() -> T as FnOnce<()>>::call_once(move _7, const ()) -> [return: bb2, unwind: bb9];
    }

    bb2: {
        _9 = const {alloc1: &AtomicUsize};
        _10 = SeqCst;
        _8 = AtomicUsize::load(_9, move _10) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        _12 = &_8;
        _13 = &_1;
        _11 = (move _12, move _13);
        _14 = (_11.0: &usize);
        _15 = (_11.1: &usize);
        _18 = (*_14);
        _19 = (*_15);
        _17 = Eq(move _18, move _19);
        _16 = Not(move _17);
        switchInt(move _16) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _20 = core::panicking::AssertKind::Eq;
        _22 = Option::<Arguments<'_>>::None;
        _21 = core::panicking::assert_failed::<usize, usize>(move _20, _14, _15, move _22) -> bb6;
    }

    bb5: {
        _0 = move _6;
        return;
    }

    bb6 (cleanup): {
        drop(_6) -> [return: bb9, unwind terminate];
    }

    bb7 (cleanup): {
        resume;
    }

    bb8 (cleanup): {
        drop(_2) -> [return: bb7, unwind terminate];
    }

    bb9 (cleanup): {
        switchInt(_23) -> [0: bb7, otherwise: bb8];
    }
}

alloc1 (static: DROPS, size: 8, align: 8) {
    00 00 00 00 00 00 00 00                         │ ........
}

fn main() -> () {
    let mut _0: ();
    let _1: ();
    let mut _2: &mut [generator@ui/generator/smoke-resume-args.rs:54:14: 54:21];
    let mut _3: [generator@ui/generator/smoke-resume-args.rs:54:14: 54:21];
    let mut _4: std::vec::Vec<(i32, std::ops::GeneratorState<i32, i32>)>;
    let mut _5: std::boxed::Box<[(i32, std::ops::GeneratorState<i32, i32>)]>;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: *mut u8;
    let mut _9: std::boxed::Box<[(i32, std::ops::GeneratorState<i32, i32>); 4]>;
    let mut _10: (i32, std::ops::GeneratorState<i32, i32>);
    let mut _11: std::ops::GeneratorState<i32, i32>;
    let mut _12: (i32, std::ops::GeneratorState<i32, i32>);
    let mut _13: std::ops::GeneratorState<i32, i32>;
    let mut _14: (i32, std::ops::GeneratorState<i32, i32>);
    let mut _15: std::ops::GeneratorState<i32, i32>;
    let mut _16: (i32, std::ops::GeneratorState<i32, i32>);
    let mut _17: std::ops::GeneratorState<i32, i32>;
    let _18: ();
    let _19: ();
    let _20: ();
    let _21: ();
    let _22: ();
    let mut _23: *const [(i32, std::ops::GeneratorState<i32, i32>); 4];
    let mut _24: *const ();
    let mut _25: usize;
    let mut _26: usize;
    let mut _27: usize;
    let mut _28: usize;
    let mut _29: bool;
    scope 1 {
    }
    scope 2 {
    }

    bb0: {
        _3 = [generator@ui/generator/smoke-resume-args.rs:54:14: 54:21 (#0)];
        _2 = &mut _3;
        _6 = SizeOf([(i32, std::ops::GeneratorState<i32, i32>); 4]);
        _7 = AlignOf([(i32, std::ops::GeneratorState<i32, i32>); 4]);
        _8 = alloc::alloc::exchange_malloc(move _6, move _7) -> bb1;
    }

    bb1: {
        _9 = ShallowInitBox(move _8, [(i32, std::ops::GeneratorState<i32, i32>); 4]);
        _11 = GeneratorState::<i32, i32>::Yielded(const 2_i32);
        _10 = (const 1_i32, move _11);
        _13 = GeneratorState::<i32, i32>::Yielded(const -44_i32);
        _12 = (const -45_i32, move _13);
        _15 = GeneratorState::<i32, i32>::Yielded(const 501_i32);
        _14 = (const 500_i32, move _15);
        _17 = GeneratorState::<i32, i32>::Complete(const -1_i32);
        _16 = (const 0_i32, move _17);
        _23 = (((_9.0: std::ptr::Unique<[(i32, std::ops::GeneratorState<i32, i32>); 4]>).0: std::ptr::NonNull<[(i32, std::ops::GeneratorState<i32, i32>); 4]>).0: *const [(i32, std::ops::GeneratorState<i32, i32>); 4]);
        _24 = _23 as *const () (PtrToPtr);
        _25 = _24 as usize (Transmute);
        _26 = AlignOf((i32, std::ops::GeneratorState<i32, i32>));
        _27 = Sub(_26, const 1_usize);
        _28 = BitAnd(_25, _27);
        _29 = Eq(_28, const 0_usize);
        assert(_29, "misaligned pointer dereference: address must be a multiple of {} but is {}", _26, _25) -> [success: bb9, unwind unreachable];
    }

    bb2: {
        _1 = drain::<[generator@ui/generator/smoke-resume-args.rs:54:14: 54:21], i32, i32>(_2, move _4) -> bb3;
    }

    bb3: {
        _18 = expect_drops::<(), [closure@ui/generator/smoke-resume-args.rs:63:21: 63:23]>(const 2_usize, const ZeroSized: [closure@ui/generator/smoke-resume-args.rs:63:21: 63:23]) -> bb4;
    }

    bb4: {
        _19 = expect_drops::<(), [closure@ui/generator/smoke-resume-args.rs:65:21: 65:23]>(const 6_usize, const ZeroSized: [closure@ui/generator/smoke-resume-args.rs:65:21: 65:23]) -> bb5;
    }

    bb5: {
        _20 = expect_drops::<(), [closure@ui/generator/smoke-resume-args.rs:73:21: 73:23]>(const 2_usize, const ZeroSized: [closure@ui/generator/smoke-resume-args.rs:73:21: 73:23]) -> bb6;
    }

    bb6: {
        _21 = expect_drops::<(), [closure@ui/generator/smoke-resume-args.rs:75:21: 75:23]>(const 2_usize, const ZeroSized: [closure@ui/generator/smoke-resume-args.rs:75:21: 75:23]) -> bb7;
    }

    bb7: {
        _22 = expect_drops::<(), [closure@ui/generator/smoke-resume-args.rs:84:21: 84:23]>(const 4_usize, const ZeroSized: [closure@ui/generator/smoke-resume-args.rs:84:21: 84:23]) -> bb8;
    }

    bb8: {
        return;
    }

    bb9: {
        (*_23) = [move _10, move _12, move _14, move _16];
        _5 = move _9 as std::boxed::Box<[(i32, std::ops::GeneratorState<i32, i32>)]> (Pointer(Unsize));
        _4 = slice::<impl [(i32, GeneratorState<i32, i32>)]>::into_vec::<std::alloc::Global>(move _5) -> bb2;
    }
}

fn main::{closure#0}(_1: Pin<&mut [generator@ui/generator/smoke-resume-args.rs:54:14: 54:21]>, _2: i32) -> GeneratorState<i32, i32> {
    debug b => _7;
    let mut _0: std::ops::GeneratorState<i32, i32>;
    let mut _3: i32;
    let mut _4: i32;
    let mut _5: i32;
    let mut _6: i32;
    let mut _7: i32;
    let mut _8: u32;
    let mut _9: &mut [generator@ui/generator/smoke-resume-args.rs:54:14: 54:21];
    let mut _10: &mut [generator@ui/generator/smoke-resume-args.rs:54:14: 54:21];
    let mut _11: &mut [generator@ui/generator/smoke-resume-args.rs:54:14: 54:21];

    bb0: {
        _9 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:54:14: 54:21]);
        _8 = discriminant((*_9));
        switchInt(move _8) -> [0: bb1, 1: bb6, 3: bb5, otherwise: bb7];
    }

    bb1: {
        _7 = move _2;
        goto -> bb2;
    }

    bb2: {
        _3 = _7;
        switchInt(move _3) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _5 = _7;
        _4 = Add(move _5, const 1_i32);
        _0 = GeneratorState::<i32, i32>::Yielded(move _4);
        _10 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:54:14: 54:21]);
        discriminant((*_10)) = 3;
        return;
    }

    bb4: {
        _6 = const -1_i32;
        _0 = GeneratorState::<i32, i32>::Complete(move _6);
        _11 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:54:14: 54:21]);
        discriminant((*_11)) = 1;
        return;
    }

    bb5: {
        _7 = move _2;
        goto -> bb2;
    }

    bb6: {
        assert(const false, "generator resumed after completion") -> bb6;
    }

    bb7: {
        unreachable;
    }
}

fn main::{closure#1}(_1: [closure@ui/generator/smoke-resume-args.rs:63:21: 63:23]) -> () {
    let mut _0: ();
    let mut _2: &mut [generator@ui/generator/smoke-resume-args.rs:63:35: 63:38];
    let mut _3: [generator@ui/generator/smoke-resume-args.rs:63:35: 63:38];
    let mut _4: std::vec::Vec<(DropMe, std::ops::GeneratorState<DropMe, DropMe>)>;
    let mut _5: std::boxed::Box<[(DropMe, std::ops::GeneratorState<DropMe, DropMe>)]>;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: *mut u8;
    let mut _9: std::boxed::Box<[(DropMe, std::ops::GeneratorState<DropMe, DropMe>); 1]>;
    let mut _10: (DropMe, std::ops::GeneratorState<DropMe, DropMe>);
    let mut _11: std::ops::GeneratorState<DropMe, DropMe>;
    let mut _12: *const [(DropMe, std::ops::GeneratorState<DropMe, DropMe>); 1];
    let mut _13: *const ();
    let mut _14: usize;
    let mut _15: usize;
    let mut _16: usize;
    let mut _17: usize;
    let mut _18: bool;
    scope 1 {
    }

    bb0: {
        _3 = [generator@ui/generator/smoke-resume-args.rs:63:35: 63:38 (#0)];
        _2 = &mut _3;
        _6 = SizeOf([(DropMe, std::ops::GeneratorState<DropMe, DropMe>); 1]);
        _7 = AlignOf([(DropMe, std::ops::GeneratorState<DropMe, DropMe>); 1]);
        _8 = alloc::alloc::exchange_malloc(move _6, move _7) -> [return: bb1, unwind: bb5];
    }

    bb1: {
        _9 = ShallowInitBox(move _8, [(DropMe, std::ops::GeneratorState<DropMe, DropMe>); 1]);
        _11 = GeneratorState::<DropMe, DropMe>::Yielded(const DropMe);
        _10 = (const DropMe, move _11);
        _12 = (((_9.0: std::ptr::Unique<[(DropMe, std::ops::GeneratorState<DropMe, DropMe>); 1]>).0: std::ptr::NonNull<[(DropMe, std::ops::GeneratorState<DropMe, DropMe>); 1]>).0: *const [(DropMe, std::ops::GeneratorState<DropMe, DropMe>); 1]);
        _13 = _12 as *const () (PtrToPtr);
        _14 = _13 as usize (Transmute);
        _15 = AlignOf((DropMe, std::ops::GeneratorState<DropMe, DropMe>));
        _16 = Sub(_15, const 1_usize);
        _17 = BitAnd(_14, _16);
        _18 = Eq(_17, const 0_usize);
        assert(_18, "misaligned pointer dereference: address must be a multiple of {} but is {}", _15, _14) -> [success: bb7, unwind unreachable];
    }

    bb2: {
        _0 = drain::<[generator@ui/generator/smoke-resume-args.rs:63:35: 63:38], DropMe, DropMe>(_2, move _4) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        drop(_3) -> bb4;
    }

    bb4: {
        return;
    }

    bb5 (cleanup): {
        drop(_3) -> [return: bb6, unwind terminate];
    }

    bb6 (cleanup): {
        resume;
    }

    bb7: {
        (*_12) = [move _10];
        _5 = move _9 as std::boxed::Box<[(DropMe, std::ops::GeneratorState<DropMe, DropMe>)]> (Pointer(Unsize));
        _4 = slice::<impl [(DropMe, GeneratorState<DropMe, DropMe>)]>::into_vec::<std::alloc::Global>(move _5) -> [return: bb2, unwind: bb5];
    }
}

fn main::{closure#1}::{closure#0}(_1: Pin<&mut [generator@ui/generator/smoke-resume-args.rs:63:35: 63:38]>, _2: DropMe) -> GeneratorState<DropMe, DropMe> {
    debug a => _2;
    let mut _0: std::ops::GeneratorState<DropMe, DropMe>;
    let mut _3: u32;
    let mut _4: &mut [generator@ui/generator/smoke-resume-args.rs:63:35: 63:38];
    let mut _5: &mut [generator@ui/generator/smoke-resume-args.rs:63:35: 63:38];
    let mut _6: &mut [generator@ui/generator/smoke-resume-args.rs:63:35: 63:38];

    bb0: {
        _4 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:63:35: 63:38]);
        _3 = discriminant((*_4));
        switchInt(move _3) -> [0: bb1, 1: bb3, 3: bb2, otherwise: bb4];
    }

    bb1: {
        _0 = GeneratorState::<DropMe, DropMe>::Yielded(move _2);
        _5 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:63:35: 63:38]);
        discriminant((*_5)) = 3;
        return;
    }

    bb2: {
        _0 = GeneratorState::<DropMe, DropMe>::Complete(move _2);
        _6 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:63:35: 63:38]);
        discriminant((*_6)) = 1;
        return;
    }

    bb3: {
        assert(const false, "generator resumed after completion") -> bb3;
    }

    bb4: {
        unreachable;
    }
}

fn main::{closure#2}(_1: [closure@ui/generator/smoke-resume-args.rs:65:21: 65:23]) -> () {
    let mut _0: ();
    let mut _2: &mut [generator@ui/generator/smoke-resume-args.rs:67:18: 67:21];
    let mut _3: [generator@ui/generator/smoke-resume-args.rs:67:18: 67:21];
    let mut _4: std::vec::Vec<(DropMe, std::ops::GeneratorState<DropMe, DropMe>)>;
    let mut _5: std::boxed::Box<[(DropMe, std::ops::GeneratorState<DropMe, DropMe>)]>;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: *mut u8;
    let mut _9: std::boxed::Box<[(DropMe, std::ops::GeneratorState<DropMe, DropMe>); 3]>;
    let mut _10: (DropMe, std::ops::GeneratorState<DropMe, DropMe>);
    let mut _11: std::ops::GeneratorState<DropMe, DropMe>;
    let mut _12: (DropMe, std::ops::GeneratorState<DropMe, DropMe>);
    let mut _13: std::ops::GeneratorState<DropMe, DropMe>;
    let mut _14: (DropMe, std::ops::GeneratorState<DropMe, DropMe>);
    let mut _15: std::ops::GeneratorState<DropMe, DropMe>;
    let mut _16: *const [(DropMe, std::ops::GeneratorState<DropMe, DropMe>); 3];
    let mut _17: *const ();
    let mut _18: usize;
    let mut _19: usize;
    let mut _20: usize;
    let mut _21: usize;
    let mut _22: bool;
    scope 1 {
    }

    bb0: {
        _3 = [generator@ui/generator/smoke-resume-args.rs:67:18: 67:21 (#0)];
        _2 = &mut _3;
        _6 = SizeOf([(DropMe, std::ops::GeneratorState<DropMe, DropMe>); 3]);
        _7 = AlignOf([(DropMe, std::ops::GeneratorState<DropMe, DropMe>); 3]);
        _8 = alloc::alloc::exchange_malloc(move _6, move _7) -> [return: bb1, unwind: bb5];
    }

    bb1: {
        _9 = ShallowInitBox(move _8, [(DropMe, std::ops::GeneratorState<DropMe, DropMe>); 3]);
        _11 = GeneratorState::<DropMe, DropMe>::Yielded(const DropMe);
        _10 = (const DropMe, move _11);
        _13 = GeneratorState::<DropMe, DropMe>::Yielded(const DropMe);
        _12 = (const DropMe, move _13);
        _15 = GeneratorState::<DropMe, DropMe>::Complete(const DropMe);
        _14 = (const DropMe, move _15);
        _16 = (((_9.0: std::ptr::Unique<[(DropMe, std::ops::GeneratorState<DropMe, DropMe>); 3]>).0: std::ptr::NonNull<[(DropMe, std::ops::GeneratorState<DropMe, DropMe>); 3]>).0: *const [(DropMe, std::ops::GeneratorState<DropMe, DropMe>); 3]);
        _17 = _16 as *const () (PtrToPtr);
        _18 = _17 as usize (Transmute);
        _19 = AlignOf((DropMe, std::ops::GeneratorState<DropMe, DropMe>));
        _20 = Sub(_19, const 1_usize);
        _21 = BitAnd(_18, _20);
        _22 = Eq(_21, const 0_usize);
        assert(_22, "misaligned pointer dereference: address must be a multiple of {} but is {}", _19, _18) -> [success: bb7, unwind unreachable];
    }

    bb2: {
        _0 = drain::<[generator@ui/generator/smoke-resume-args.rs:67:18: 67:21], DropMe, DropMe>(_2, move _4) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        drop(_3) -> bb4;
    }

    bb4: {
        return;
    }

    bb5 (cleanup): {
        drop(_3) -> [return: bb6, unwind terminate];
    }

    bb6 (cleanup): {
        resume;
    }

    bb7: {
        (*_16) = [move _10, move _12, move _14];
        _5 = move _9 as std::boxed::Box<[(DropMe, std::ops::GeneratorState<DropMe, DropMe>)]> (Pointer(Unsize));
        _4 = slice::<impl [(DropMe, GeneratorState<DropMe, DropMe>)]>::into_vec::<std::alloc::Global>(move _5) -> [return: bb2, unwind: bb5];
    }
}

fn main::{closure#2}::{closure#0}(_1: Pin<&mut [generator@ui/generator/smoke-resume-args.rs:67:18: 67:21]>, _2: DropMe) -> GeneratorState<DropMe, DropMe> {
    debug a => _2;
    let mut _0: std::ops::GeneratorState<DropMe, DropMe>;
    let mut _3: u32;
    let mut _4: &mut [generator@ui/generator/smoke-resume-args.rs:67:18: 67:21];
    let mut _5: &mut [generator@ui/generator/smoke-resume-args.rs:67:18: 67:21];
    let mut _6: &mut [generator@ui/generator/smoke-resume-args.rs:67:18: 67:21];
    let mut _7: &mut [generator@ui/generator/smoke-resume-args.rs:67:18: 67:21];

    bb0: {
        _4 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:67:18: 67:21]);
        _3 = discriminant((*_4));
        switchInt(move _3) -> [0: bb1, 1: bb4, 3: bb2, 4: bb3, otherwise: bb5];
    }

    bb1: {
        _0 = GeneratorState::<DropMe, DropMe>::Yielded(move _2);
        _5 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:67:18: 67:21]);
        discriminant((*_5)) = 3;
        return;
    }

    bb2: {
        _0 = GeneratorState::<DropMe, DropMe>::Yielded(move _2);
        _6 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:67:18: 67:21]);
        discriminant((*_6)) = 4;
        return;
    }

    bb3: {
        _0 = GeneratorState::<DropMe, DropMe>::Complete(move _2);
        _7 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:67:18: 67:21]);
        discriminant((*_7)) = 1;
        return;
    }

    bb4: {
        assert(const false, "generator resumed after completion") -> bb4;
    }

    bb5: {
        unreachable;
    }
}

fn main::{closure#3}(_1: [closure@ui/generator/smoke-resume-args.rs:73:21: 73:23]) -> () {
    let mut _0: ();
    let mut _2: &mut [generator@ui/generator/smoke-resume-args.rs:73:35: 73:38];
    let mut _3: [generator@ui/generator/smoke-resume-args.rs:73:35: 73:38];
    let mut _4: std::vec::Vec<(DropMe, std::ops::GeneratorState<(), DropMe>)>;
    let mut _5: std::boxed::Box<[(DropMe, std::ops::GeneratorState<(), DropMe>)]>;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: *mut u8;
    let mut _9: std::boxed::Box<[(DropMe, std::ops::GeneratorState<(), DropMe>); 1]>;
    let mut _10: (DropMe, std::ops::GeneratorState<(), DropMe>);
    let mut _11: std::ops::GeneratorState<(), DropMe>;
    let mut _12: *const [(DropMe, std::ops::GeneratorState<(), DropMe>); 1];
    let mut _13: *const ();
    let mut _14: usize;
    let mut _15: usize;
    let mut _16: usize;
    let mut _17: usize;
    let mut _18: bool;
    scope 1 {
    }

    bb0: {
        _3 = [generator@ui/generator/smoke-resume-args.rs:73:35: 73:38 (#0)];
        _2 = &mut _3;
        _6 = SizeOf([(DropMe, std::ops::GeneratorState<(), DropMe>); 1]);
        _7 = AlignOf([(DropMe, std::ops::GeneratorState<(), DropMe>); 1]);
        _8 = alloc::alloc::exchange_malloc(move _6, move _7) -> [return: bb1, unwind: bb5];
    }

    bb1: {
        _9 = ShallowInitBox(move _8, [(DropMe, std::ops::GeneratorState<(), DropMe>); 1]);
        _11 = GeneratorState::<(), DropMe>::Complete(const DropMe);
        _10 = (const DropMe, move _11);
        _12 = (((_9.0: std::ptr::Unique<[(DropMe, std::ops::GeneratorState<(), DropMe>); 1]>).0: std::ptr::NonNull<[(DropMe, std::ops::GeneratorState<(), DropMe>); 1]>).0: *const [(DropMe, std::ops::GeneratorState<(), DropMe>); 1]);
        _13 = _12 as *const () (PtrToPtr);
        _14 = _13 as usize (Transmute);
        _15 = AlignOf((DropMe, std::ops::GeneratorState<(), DropMe>));
        _16 = Sub(_15, const 1_usize);
        _17 = BitAnd(_14, _16);
        _18 = Eq(_17, const 0_usize);
        assert(_18, "misaligned pointer dereference: address must be a multiple of {} but is {}", _15, _14) -> [success: bb7, unwind unreachable];
    }

    bb2: {
        _0 = drain::<[generator@ui/generator/smoke-resume-args.rs:73:35: 73:38], DropMe, ()>(_2, move _4) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        drop(_3) -> bb4;
    }

    bb4: {
        return;
    }

    bb5 (cleanup): {
        drop(_3) -> [return: bb6, unwind terminate];
    }

    bb6 (cleanup): {
        resume;
    }

    bb7: {
        (*_12) = [move _10];
        _5 = move _9 as std::boxed::Box<[(DropMe, std::ops::GeneratorState<(), DropMe>)]> (Pointer(Unsize));
        _4 = slice::<impl [(DropMe, GeneratorState<(), DropMe>)]>::into_vec::<std::alloc::Global>(move _5) -> [return: bb2, unwind: bb5];
    }
}

fn main::{closure#3}::{closure#0}(_1: Pin<&mut [generator@ui/generator/smoke-resume-args.rs:73:35: 73:38]>, _2: DropMe) -> GeneratorState<(), DropMe> {
    debug a => _2;
    let mut _0: std::ops::GeneratorState<(), DropMe>;
    let mut _3: u32;
    let mut _4: &mut [generator@ui/generator/smoke-resume-args.rs:73:35: 73:38];
    let mut _5: &mut [generator@ui/generator/smoke-resume-args.rs:73:35: 73:38];

    bb0: {
        _4 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:73:35: 73:38]);
        _3 = discriminant((*_4));
        switchInt(move _3) -> [0: bb1, 1: bb2, otherwise: bb3];
    }

    bb1: {
        _0 = GeneratorState::<(), DropMe>::Complete(move _2);
        _5 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:73:35: 73:38]);
        discriminant((*_5)) = 1;
        return;
    }

    bb2: {
        assert(const false, "generator resumed after completion") -> bb2;
    }

    bb3: {
        unreachable;
    }
}

fn main::{closure#4}(_1: [closure@ui/generator/smoke-resume-args.rs:75:21: 75:23]) -> () {
    let mut _0: ();
    let mut _2: &mut [generator@ui/generator/smoke-resume-args.rs:77:18: 77:29];
    let mut _3: [generator@ui/generator/smoke-resume-args.rs:77:18: 77:29];
    let mut _4: std::vec::Vec<(DropMe, std::ops::GeneratorState<(), DropMe>)>;
    let mut _5: std::boxed::Box<[(DropMe, std::ops::GeneratorState<(), DropMe>)]>;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: *mut u8;
    let mut _9: std::boxed::Box<[(DropMe, std::ops::GeneratorState<(), DropMe>); 1]>;
    let mut _10: (DropMe, std::ops::GeneratorState<(), DropMe>);
    let mut _11: std::ops::GeneratorState<(), DropMe>;
    let mut _12: *const [(DropMe, std::ops::GeneratorState<(), DropMe>); 1];
    let mut _13: *const ();
    let mut _14: usize;
    let mut _15: usize;
    let mut _16: usize;
    let mut _17: usize;
    let mut _18: bool;
    scope 1 {
    }

    bb0: {
        _3 = [generator@ui/generator/smoke-resume-args.rs:77:18: 77:29 (#0)];
        _2 = &mut _3;
        _6 = SizeOf([(DropMe, std::ops::GeneratorState<(), DropMe>); 1]);
        _7 = AlignOf([(DropMe, std::ops::GeneratorState<(), DropMe>); 1]);
        _8 = alloc::alloc::exchange_malloc(move _6, move _7) -> [return: bb1, unwind: bb5];
    }

    bb1: {
        _9 = ShallowInitBox(move _8, [(DropMe, std::ops::GeneratorState<(), DropMe>); 1]);
        _11 = GeneratorState::<(), DropMe>::Complete(const DropMe);
        _10 = (const DropMe, move _11);
        _12 = (((_9.0: std::ptr::Unique<[(DropMe, std::ops::GeneratorState<(), DropMe>); 1]>).0: std::ptr::NonNull<[(DropMe, std::ops::GeneratorState<(), DropMe>); 1]>).0: *const [(DropMe, std::ops::GeneratorState<(), DropMe>); 1]);
        _13 = _12 as *const () (PtrToPtr);
        _14 = _13 as usize (Transmute);
        _15 = AlignOf((DropMe, std::ops::GeneratorState<(), DropMe>));
        _16 = Sub(_15, const 1_usize);
        _17 = BitAnd(_14, _16);
        _18 = Eq(_17, const 0_usize);
        assert(_18, "misaligned pointer dereference: address must be a multiple of {} but is {}", _15, _14) -> [success: bb7, unwind unreachable];
    }

    bb2: {
        _0 = drain::<[generator@ui/generator/smoke-resume-args.rs:77:18: 77:29], DropMe, ()>(_2, move _4) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        drop(_3) -> bb4;
    }

    bb4: {
        return;
    }

    bb5 (cleanup): {
        drop(_3) -> [return: bb6, unwind terminate];
    }

    bb6 (cleanup): {
        resume;
    }

    bb7: {
        (*_12) = [move _10];
        _5 = move _9 as std::boxed::Box<[(DropMe, std::ops::GeneratorState<(), DropMe>)]> (Pointer(Unsize));
        _4 = slice::<impl [(DropMe, GeneratorState<(), DropMe>)]>::into_vec::<std::alloc::Global>(move _5) -> [return: bb2, unwind: bb5];
    }
}

fn main::{closure#4}::{closure#0}(_1: Pin<&mut [generator@ui/generator/smoke-resume-args.rs:77:18: 77:29]>, _2: DropMe) -> GeneratorState<(), DropMe> {
    debug a => (((*(_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:77:18: 77:29])) as variant#3).1: DropMe);
    let mut _0: std::ops::GeneratorState<(), DropMe>;
    let mut _3: bool;
    let mut _4: ();
    let mut _5: DropMe;
    let mut _6: u32;
    let mut _7: &mut [generator@ui/generator/smoke-resume-args.rs:77:18: 77:29];
    let mut _8: &mut [generator@ui/generator/smoke-resume-args.rs:77:18: 77:29];
    let mut _9: &mut [generator@ui/generator/smoke-resume-args.rs:77:18: 77:29];
    let mut _10: &mut [generator@ui/generator/smoke-resume-args.rs:77:18: 77:29];
    let mut _11: &mut [generator@ui/generator/smoke-resume-args.rs:77:18: 77:29];
    let mut _12: &mut [generator@ui/generator/smoke-resume-args.rs:77:18: 77:29];
    let mut _13: &mut [generator@ui/generator/smoke-resume-args.rs:77:18: 77:29];
    let mut _14: &mut [generator@ui/generator/smoke-resume-args.rs:77:18: 77:29];
    let mut _15: &mut [generator@ui/generator/smoke-resume-args.rs:77:18: 77:29];
    let mut _16: &mut [generator@ui/generator/smoke-resume-args.rs:77:18: 77:29];
    let mut _17: &mut [generator@ui/generator/smoke-resume-args.rs:77:18: 77:29];

    bb0: {
        _7 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:77:18: 77:29]);
        _6 = discriminant((*_7));
        switchInt(move _6) -> [0: bb1, 1: bb10, 2: bb9, 3: bb8, otherwise: bb11];
    }

    bb1: {
        _8 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:77:18: 77:29]);
        (((*_8) as variant#3).1: DropMe) = move _2;
        _9 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:77:18: 77:29]);
        (((*_9) as variant#3).0: bool) = const false;
        _10 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:77:18: 77:29]);
        (((*_10) as variant#3).0: bool) = const true;
        _3 = const false;
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _4 = ();
        _0 = GeneratorState::<(), DropMe>::Yielded(move _4);
        _11 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:77:18: 77:29]);
        discriminant((*_11)) = 3;
        return;
    }

    bb3: {
        _12 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:77:18: 77:29]);
        (((*_12) as variant#3).0: bool) = const false;
        _13 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:77:18: 77:29]);
        _5 = move (((*_13) as variant#3).1: DropMe);
        goto -> bb4;
    }

    bb4: {
        _16 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:77:18: 77:29]);
        switchInt((((*_16) as variant#3).0: bool)) -> [0: bb5, otherwise: bb7];
    }

    bb5: {
        _0 = GeneratorState::<(), DropMe>::Complete(move _5);
        _14 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:77:18: 77:29]);
        discriminant((*_14)) = 1;
        return;
    }

    bb6 (cleanup): {
        _17 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:77:18: 77:29]);
        discriminant((*_17)) = 2;
        resume;
    }

    bb7: {
        _15 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:77:18: 77:29]);
        drop((((*_15) as variant#3).1: DropMe)) -> [return: bb5, unwind: bb6];
    }

    bb8: {
        _5 = move _2;
        goto -> bb4;
    }

    bb9: {
        assert(const false, "generator resumed after panicking") -> bb9;
    }

    bb10: {
        assert(const false, "generator resumed after completion") -> bb10;
    }

    bb11: {
        unreachable;
    }
}

fn main::{closure#5}(_1: [closure@ui/generator/smoke-resume-args.rs:84:21: 84:23]) -> () {
    let mut _0: ();
    let mut _2: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33];
    let mut _3: [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33];
    let mut _4: std::vec::Vec<(DropMe, std::ops::GeneratorState<(), ()>)>;
    let mut _5: std::boxed::Box<[(DropMe, std::ops::GeneratorState<(), ()>)]>;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: *mut u8;
    let mut _9: std::boxed::Box<[(DropMe, std::ops::GeneratorState<(), ()>); 4]>;
    let mut _10: (DropMe, std::ops::GeneratorState<(), ()>);
    let mut _11: std::ops::GeneratorState<(), ()>;
    let mut _12: (DropMe, std::ops::GeneratorState<(), ()>);
    let mut _13: std::ops::GeneratorState<(), ()>;
    let mut _14: (DropMe, std::ops::GeneratorState<(), ()>);
    let mut _15: std::ops::GeneratorState<(), ()>;
    let mut _16: (DropMe, std::ops::GeneratorState<(), ()>);
    let mut _17: std::ops::GeneratorState<(), ()>;
    let mut _18: *const [(DropMe, std::ops::GeneratorState<(), ()>); 4];
    let mut _19: *const ();
    let mut _20: usize;
    let mut _21: usize;
    let mut _22: usize;
    let mut _23: usize;
    let mut _24: bool;
    scope 1 {
    }
    scope 2 {
    }

    bb0: {
        _3 = [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33 (#0)];
        _2 = &mut _3;
        _6 = SizeOf([(DropMe, std::ops::GeneratorState<(), ()>); 4]);
        _7 = AlignOf([(DropMe, std::ops::GeneratorState<(), ()>); 4]);
        _8 = alloc::alloc::exchange_malloc(move _6, move _7) -> [return: bb1, unwind: bb5];
    }

    bb1: {
        _9 = ShallowInitBox(move _8, [(DropMe, std::ops::GeneratorState<(), ()>); 4]);
        _11 = GeneratorState::<(), ()>::Yielded(const ());
        _10 = (const DropMe, move _11);
        _13 = GeneratorState::<(), ()>::Yielded(const ());
        _12 = (const DropMe, move _13);
        _15 = GeneratorState::<(), ()>::Yielded(const ());
        _14 = (const DropMe, move _15);
        _17 = GeneratorState::<(), ()>::Complete(const ());
        _16 = (const DropMe, move _17);
        _18 = (((_9.0: std::ptr::Unique<[(DropMe, std::ops::GeneratorState<(), ()>); 4]>).0: std::ptr::NonNull<[(DropMe, std::ops::GeneratorState<(), ()>); 4]>).0: *const [(DropMe, std::ops::GeneratorState<(), ()>); 4]);
        _19 = _18 as *const () (PtrToPtr);
        _20 = _19 as usize (Transmute);
        _21 = AlignOf((DropMe, std::ops::GeneratorState<(), ()>));
        _22 = Sub(_21, const 1_usize);
        _23 = BitAnd(_20, _22);
        _24 = Eq(_23, const 0_usize);
        assert(_24, "misaligned pointer dereference: address must be a multiple of {} but is {}", _21, _20) -> [success: bb7, unwind unreachable];
    }

    bb2: {
        _0 = drain::<[generator@ui/generator/smoke-resume-args.rs:87:18: 87:33], DropMe, ()>(_2, move _4) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        drop(_3) -> bb4;
    }

    bb4: {
        return;
    }

    bb5 (cleanup): {
        drop(_3) -> [return: bb6, unwind terminate];
    }

    bb6 (cleanup): {
        resume;
    }

    bb7: {
        (*_18) = [move _10, move _12, move _14, move _16];
        _5 = move _9 as std::boxed::Box<[(DropMe, std::ops::GeneratorState<(), ()>)]> (Pointer(Unsize));
        _4 = slice::<impl [(DropMe, GeneratorState<(), ()>)]>::into_vec::<std::alloc::Global>(move _5) -> [return: bb2, unwind: bb5];
    }
}

fn main::{closure#5}::{closure#0}(_1: Pin<&mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33]>, _2: DropMe) -> GeneratorState<(), ()> {
    debug a => (((*(_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33])) as variant#3).0: DropMe);
    let mut _0: std::ops::GeneratorState<(), ()>;
    let mut _3: ();
    let mut _4: ();
    let mut _5: ();
    let mut _6: ();
    let mut _7: u32;
    let mut _8: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33];
    let mut _9: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33];
    let mut _10: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33];
    let mut _11: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33];
    let mut _12: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33];
    let mut _13: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33];
    let mut _14: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33];
    let mut _15: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33];
    let mut _16: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33];
    let mut _17: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33];
    let mut _18: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33];
    let mut _19: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33];
    let mut _20: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33];
    let mut _21: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33];
    let mut _22: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33];
    let mut _23: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33];
    let mut _24: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33];
    let mut _25: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33];

    bb0: {
        _8 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33]);
        _7 = discriminant((*_8));
        switchInt(move _7) -> [0: bb1, 1: bb15, 2: bb14, 3: bb11, 4: bb12, 5: bb13, otherwise: bb16];
    }

    bb1: {
        _9 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33]);
        (((*_9) as variant#3).0: DropMe) = move _2;
        _3 = ();
        _0 = GeneratorState::<(), ()>::Yielded(move _3);
        _10 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33]);
        discriminant((*_10)) = 3;
        return;
    }

    bb2: {
        _12 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33]);
        (((*_12) as variant#3).0: DropMe) = move _2;
        _4 = ();
        _0 = GeneratorState::<(), ()>::Yielded(move _4);
        _14 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33]);
        discriminant((*_14)) = 4;
        return;
    }

    bb3 (cleanup): {
        _13 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33]);
        (((*_13) as variant#3).0: DropMe) = move _2;
        goto -> bb9;
    }

    bb4: {
        _16 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33]);
        (((*_16) as variant#3).0: DropMe) = move _2;
        _5 = ();
        _0 = GeneratorState::<(), ()>::Yielded(move _5);
        _18 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33]);
        discriminant((*_18)) = 5;
        return;
    }

    bb5 (cleanup): {
        _17 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33]);
        (((*_17) as variant#3).0: DropMe) = move _2;
        goto -> bb9;
    }

    bb6: {
        _20 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33]);
        (((*_20) as variant#3).0: DropMe) = move _2;
        _6 = const ();
        _22 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33]);
        drop((((*_22) as variant#3).0: DropMe)) -> [return: bb8, unwind: bb10];
    }

    bb7 (cleanup): {
        _21 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33]);
        (((*_21) as variant#3).0: DropMe) = move _2;
        goto -> bb9;
    }

    bb8: {
        _0 = GeneratorState::<(), ()>::Complete(move _6);
        _23 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33]);
        discriminant((*_23)) = 1;
        return;
    }

    bb9 (cleanup): {
        _24 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33]);
        drop((((*_24) as variant#3).0: DropMe)) -> [return: bb10, unwind terminate];
    }

    bb10 (cleanup): {
        _25 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33]);
        discriminant((*_25)) = 2;
        resume;
    }

    bb11: {
        _11 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33]);
        drop((((*_11) as variant#3).0: DropMe)) -> [return: bb2, unwind: bb3];
    }

    bb12: {
        _15 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33]);
        drop((((*_15) as variant#3).0: DropMe)) -> [return: bb4, unwind: bb5];
    }

    bb13: {
        _19 = deref_copy (_1.0: &mut [generator@ui/generator/smoke-resume-args.rs:87:18: 87:33]);
        drop((((*_19) as variant#3).0: DropMe)) -> [return: bb6, unwind: bb7];
    }

    bb14: {
        assert(const false, "generator resumed after panicking") -> bb14;
    }

    bb15: {
        assert(const false, "generator resumed after completion") -> bb15;
    }

    bb16: {
        unreachable;
    }
}
