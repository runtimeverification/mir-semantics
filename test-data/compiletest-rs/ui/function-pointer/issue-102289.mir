// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn Parser::parse(_1: &mut Self, _2: &str) -> Result<(), ()> {
    debug self => _1;
    debug _input => _2;
    let mut _0: std::result::Result<(), ()>;

    bb0: {
        goto -> bb1;
    }

    bb1: {
        goto -> bb1;
    }
}

fn Parser::map(_1: Self, _2: F) -> Map<Self, F> {
    debug self => _1;
    debug _f => _2;
    let mut _0: Map<Self, F>;
    let mut _3: !;

    bb0: {
        _3 = core::panicking::panic(const "not yet implemented") -> bb1;
    }

    bb1 (cleanup): {
        drop(_2) -> [return: bb2, unwind terminate];
    }

    bb2 (cleanup): {
        drop(_1) -> [return: bb3, unwind terminate];
    }

    bb3 (cleanup): {
        resume;
    }
}

fn chainl1(_1: P, _2: Op) -> Chainl1<P, Op> {
    debug _parser => _1;
    debug _op => _2;
    let mut _0: Chainl1<P, Op>;

    bb0: {
        goto -> bb1;
    }

    bb1: {
        goto -> bb1;
    }
}

fn chainl1_error_consume() -> () {
    let mut _0: ();
    let mut _1: std::result::Result<(), ()>;
    let mut _2: &mut Chainl1<u32, Map<u32, [closure@ui/function-pointer/issue-102289.rs:51:30: 51:33]>>;
    let mut _3: Chainl1<u32, Map<u32, [closure@ui/function-pointer/issue-102289.rs:51:30: 51:33]>>;
    let mut _4: Map<u32, [closure@ui/function-pointer/issue-102289.rs:51:30: 51:33]>;
    let _5: &str;
    scope 1 {
    }

    bb0: {
        _4 = <u32 as Parser>::map::<[closure@ui/function-pointer/issue-102289.rs:51:30: 51:33], fn((), ()) {first::<(), ()>}>(const 1_u32, const ZeroSized: [closure@ui/function-pointer/issue-102289.rs:51:30: 51:33]) -> bb1;
    }

    bb1: {
        _3 = chainl1::<u32, Map<u32, [closure@ui/function-pointer/issue-102289.rs:51:30: 51:33]>>(const 1_u32, move _4) -> bb2;
    }

    bb2: {
        _2 = &mut _3;
        _5 = const "";
        _1 = <Chainl1<u32, Map<u32, [closure@ui/function-pointer/issue-102289.rs:51:30: 51:33]>> as Parser>::parse(move _2, _5) -> bb3;
    }

    bb3: {
        return;
    }
}

fn first(_1: T, _2: U) -> T {
    debug t => _1;
    let mut _0: T;

    bb0: {
        _0 = move _1;
        drop(_2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn chainl1_error_consume::{closure#0}(_1: &mut [closure@ui/function-pointer/issue-102289.rs:51:30: 51:33], _2: ()) -> fn((), ()) {first::<(), ()>} {
    let mut _0: fn((), ()) {chainl1_error_consume::first::<(), ()>};

    bb0: {
        return;
    }
}

fn main() -> () {
    let mut _0: ();

    bb0: {
        return;
    }
}

fn Chainl1(_1: P, _2: Op) -> Chainl1<P, Op> {
    let mut _0: Chainl1<P, Op>;

    bb0: {
        _0 = Chainl1::<P, Op>(move _1, move _2);
        return;
    }
}

// MIR FOR CTFE
fn Chainl1(_1: P, _2: Op) -> Chainl1<P, Op> {
    let mut _0: Chainl1<P, Op>;

    bb0: {
        _0 = Chainl1::<P, Op>(move _1, move _2);
        return;
    }
}

fn Map(_1: P, _2: F) -> Map<P, F> {
    let mut _0: Map<P, F>;

    bb0: {
        _0 = Map::<P, F>(move _1, move _2);
        return;
    }
}

// MIR FOR CTFE
fn Map(_1: P, _2: F) -> Map<P, F> {
    let mut _0: Map<P, F>;

    bb0: {
        _0 = Map::<P, F>(move _1, move _2);
        return;
    }
}
