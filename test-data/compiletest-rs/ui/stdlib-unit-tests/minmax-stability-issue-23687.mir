// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn <impl at ui/stdlib-unit-tests/minmax-stability-issue-23687.rs:6:10: 6:15>::fmt(_1: &Foo, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &u8;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &&&str;
    let _10: &&str;

    bb0: {
        _3 = const "Foo";
        _4 = const "n";
        _6 = &((*_1).0: u8);
        _5 = _6 as &dyn std::fmt::Debug (Pointer(Unsize));
        _7 = const "name";
        _10 = &((*_1).1: &str);
        _9 = &_10;
        _8 = _9 as &dyn std::fmt::Debug (Pointer(Unsize));
        _0 = Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/stdlib-unit-tests/minmax-stability-issue-23687.rs:6:23: 6:28>::clone(_1: &Foo) -> Foo {
    debug self => _1;
    let mut _0: Foo;
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn <impl at ui/stdlib-unit-tests/minmax-stability-issue-23687.rs:6:30: 6:39>::eq(_1: &Foo, _2: &Foo) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: u8;
    let mut _5: u8;
    let mut _6: bool;
    let mut _7: &&str;
    let mut _8: &&str;

    bb0: {
        _4 = ((*_1).0: u8);
        _5 = ((*_2).0: u8);
        _3 = Eq(move _4, move _5);
        switchInt(move _3) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = const false;
        goto -> bb3;
    }

    bb2: {
        _7 = &((*_1).1: &str);
        _8 = &((*_2).1: &str);
        _6 = <&str as PartialEq>::eq(move _7, move _8) -> bb4;
    }

    bb3: {
        return;
    }

    bb4: {
        _0 = move _6;
        goto -> bb3;
    }
}

fn <impl at ui/stdlib-unit-tests/minmax-stability-issue-23687.rs:6:41: 6:43>::assert_receiver_is_total_eq(_1: &Foo) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        return;
    }
}

fn <impl at ui/stdlib-unit-tests/minmax-stability-issue-23687.rs:12:1: 12:24>::partial_cmp(_1: &Foo, _2: &Foo) -> Option<std::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: std::option::Option<std::cmp::Ordering>;
    let mut _3: std::cmp::Ordering;

    bb0: {
        _3 = <Foo as Ord>::cmp(_1, _2) -> bb1;
    }

    bb1: {
        _0 = Option::<std::cmp::Ordering>::Some(move _3);
        return;
    }
}

fn <impl at ui/stdlib-unit-tests/minmax-stability-issue-23687.rs:18:1: 18:17>::cmp(_1: &Foo, _2: &Foo) -> std::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: std::cmp::Ordering;
    let mut _3: &u8;
    let _4: &u8;

    bb0: {
        _3 = &((*_1).0: u8);
        _4 = &((*_2).0: u8);
        _0 = <u8 as Ord>::cmp(move _3, _4) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let _1: Foo;
    let mut _8: Foo;
    let mut _9: Foo;
    let mut _10: Foo;
    let mut _11: Foo;
    let mut _12: (&std::option::Option<&Foo>, &std::option::Option<&Foo>);
    let mut _13: &std::option::Option<&Foo>;
    let _14: std::option::Option<&Foo>;
    let mut _15: std::slice::Iter<'_, Foo>;
    let mut _16: &[Foo];
    let mut _17: &[Foo; 6];
    let mut _18: &std::option::Option<&Foo>;
    let _19: std::option::Option<&Foo>;
    let mut _20: &Foo;
    let mut _23: bool;
    let mut _24: bool;
    let _26: !;
    let mut _27: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _28: (&std::option::Option<&Foo>, &std::option::Option<&Foo>);
    let mut _29: &std::option::Option<&Foo>;
    let _30: std::option::Option<&Foo>;
    let mut _31: std::slice::Iter<'_, Foo>;
    let mut _32: &[Foo];
    let mut _33: &[Foo; 6];
    let mut _34: &std::option::Option<&Foo>;
    let _35: std::option::Option<&Foo>;
    let mut _36: &Foo;
    let mut _39: bool;
    let mut _40: bool;
    let _42: !;
    let mut _43: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _44: (&Foo, &Foo);
    let mut _45: &Foo;
    let _46: Foo;
    let mut _47: Foo;
    let mut _48: Foo;
    let mut _49: &Foo;
    let mut _52: bool;
    let mut _53: bool;
    let _55: !;
    let mut _56: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _57: (&Foo, &Foo);
    let mut _58: &Foo;
    let _59: Foo;
    let mut _60: Foo;
    let mut _61: Foo;
    let mut _62: &Foo;
    let mut _65: bool;
    let mut _66: bool;
    let _68: !;
    let mut _69: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _70: (&std::option::Option<&Foo>, &std::option::Option<&Foo>);
    let mut _71: &std::option::Option<&Foo>;
    let _72: std::option::Option<&Foo>;
    let mut _73: std::slice::Iter<'_, Foo>;
    let mut _74: &[Foo];
    let mut _75: &[Foo; 6];
    let mut _76: &std::option::Option<&Foo>;
    let _77: std::option::Option<&Foo>;
    let mut _78: &Foo;
    let mut _81: bool;
    let mut _82: bool;
    let _84: !;
    let mut _85: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _86: (&std::option::Option<&Foo>, &std::option::Option<&Foo>);
    let mut _87: &std::option::Option<&Foo>;
    let _88: std::option::Option<&Foo>;
    let mut _89: std::slice::Iter<'_, Foo>;
    let mut _90: &[Foo];
    let mut _91: &[Foo; 6];
    let mut _92: &std::option::Option<&Foo>;
    let _93: std::option::Option<&Foo>;
    let mut _94: &Foo;
    let mut _97: bool;
    let mut _98: bool;
    let _100: !;
    let mut _101: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _102: (&Foo, &Foo);
    let mut _103: &Foo;
    let _104: Foo;
    let mut _105: Foo;
    let mut _106: Foo;
    let mut _107: &Foo;
    let mut _110: bool;
    let mut _111: bool;
    let _113: !;
    let mut _114: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _115: (&Foo, &Foo);
    let mut _116: &Foo;
    let _117: Foo;
    let mut _118: Foo;
    let mut _119: Foo;
    let mut _120: &Foo;
    let mut _123: bool;
    let mut _124: bool;
    let _126: !;
    let mut _127: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _129: &[Foo];
    let mut _130: &[Foo; 6];
    let _131: ();
    let mut _132: &mut [Foo];
    let mut _133: &mut [Foo];
    let mut _134: &mut std::vec::Vec<Foo>;
    let _135: ();
    let mut _136: &[Foo];
    let _137: &[Foo];
    let _138: &std::vec::Vec<Foo>;
    let mut _140: &[Foo];
    let mut _141: &[Foo; 6];
    let _142: ();
    let mut _143: &mut [Foo];
    let mut _144: &mut [Foo];
    let mut _145: &mut std::vec::Vec<Foo>;
    let _146: ();
    let mut _147: &[Foo];
    let _148: &[Foo];
    let _149: &std::vec::Vec<Foo>;
    scope 1 {
        debug a => _1;
        let _2: Foo;
        scope 2 {
            debug b => _2;
            let _3: Foo;
            scope 3 {
                debug c => _3;
                let _4: Foo;
                scope 4 {
                    debug d => _4;
                    let _5: Foo;
                    scope 5 {
                        debug e => _5;
                        let _6: Foo;
                        scope 6 {
                            debug f => _6;
                            let _7: [Foo; 6];
                            scope 7 {
                                debug data => _7;
                                let _21: &std::option::Option<&Foo>;
                                let _22: &std::option::Option<&Foo>;
                                let _37: &std::option::Option<&Foo>;
                                let _38: &std::option::Option<&Foo>;
                                let _50: &Foo;
                                let _51: &Foo;
                                let _63: &Foo;
                                let _64: &Foo;
                                let _79: &std::option::Option<&Foo>;
                                let _80: &std::option::Option<&Foo>;
                                let _95: &std::option::Option<&Foo>;
                                let _96: &std::option::Option<&Foo>;
                                let _108: &Foo;
                                let _109: &Foo;
                                let _121: &Foo;
                                let _122: &Foo;
                                let mut _128: std::vec::Vec<Foo>;
                                scope 8 {
                                    debug left_val => _21;
                                    debug right_val => _22;
                                    let _25: core::panicking::AssertKind;
                                    scope 9 {
                                        debug kind => _25;
                                    }
                                }
                                scope 10 {
                                    debug left_val => _37;
                                    debug right_val => _38;
                                    let _41: core::panicking::AssertKind;
                                    scope 11 {
                                        debug kind => _41;
                                    }
                                }
                                scope 12 {
                                    debug left_val => _50;
                                    debug right_val => _51;
                                    let _54: core::panicking::AssertKind;
                                    scope 13 {
                                        debug kind => _54;
                                    }
                                }
                                scope 14 {
                                    debug left_val => _63;
                                    debug right_val => _64;
                                    let _67: core::panicking::AssertKind;
                                    scope 15 {
                                        debug kind => _67;
                                    }
                                }
                                scope 16 {
                                    debug left_val => _79;
                                    debug right_val => _80;
                                    let _83: core::panicking::AssertKind;
                                    scope 17 {
                                        debug kind => _83;
                                    }
                                }
                                scope 18 {
                                    debug left_val => _95;
                                    debug right_val => _96;
                                    let _99: core::panicking::AssertKind;
                                    scope 19 {
                                        debug kind => _99;
                                    }
                                }
                                scope 20 {
                                    debug left_val => _108;
                                    debug right_val => _109;
                                    let _112: core::panicking::AssertKind;
                                    scope 21 {
                                        debug kind => _112;
                                    }
                                }
                                scope 22 {
                                    debug left_val => _121;
                                    debug right_val => _122;
                                    let _125: core::panicking::AssertKind;
                                    scope 23 {
                                        debug kind => _125;
                                    }
                                }
                                scope 24 {
                                    debug presorted => _128;
                                    let mut _139: std::vec::Vec<Foo>;
                                    scope 25 {
                                        debug presorted => _139;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _1 = Foo { n: const 4_u8, name: const "a" };
        _2 = Foo { n: const 4_u8, name: const "b" };
        _3 = Foo { n: const 8_u8, name: const "c" };
        _4 = Foo { n: const 8_u8, name: const "d" };
        _5 = Foo { n: const 22_u8, name: const "e" };
        _6 = Foo { n: const 22_u8, name: const "f" };
        _8 = _1;
        _9 = _2;
        _10 = _5;
        _11 = _6;
        _7 = [move _8, move _9, _3, _4, move _10, move _11];
        _17 = &_7;
        _16 = move _17 as &[Foo] (Pointer(Unsize));
        _15 = core::slice::<impl [Foo]>::iter(move _16) -> bb1;
    }

    bb1: {
        _14 = <std::slice::Iter<'_, Foo> as Iterator>::min(move _15) -> bb2;
    }

    bb2: {
        _13 = &_14;
        _20 = &_1;
        _19 = Option::<&Foo>::Some(move _20);
        _18 = &_19;
        _12 = (move _13, move _18);
        _21 = (_12.0: &std::option::Option<&Foo>);
        _22 = (_12.1: &std::option::Option<&Foo>);
        _24 = <Option<&Foo> as PartialEq>::eq(_21, _22) -> bb3;
    }

    bb3: {
        _23 = Not(move _24);
        switchInt(move _23) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _25 = core::panicking::AssertKind::Eq;
        _27 = Option::<Arguments<'_>>::None;
        _26 = core::panicking::assert_failed::<Option<&Foo>, Option<&Foo>>(move _25, _21, _22, move _27);
    }

    bb5: {
        _33 = &_7;
        _32 = move _33 as &[Foo] (Pointer(Unsize));
        _31 = core::slice::<impl [Foo]>::iter(move _32) -> bb6;
    }

    bb6: {
        _30 = <std::slice::Iter<'_, Foo> as Iterator>::min_by_key::<u8, [closure@ui/stdlib-unit-tests/minmax-stability-issue-23687.rs:36:39: 36:42]>(move _31, const ZeroSized: [closure@ui/stdlib-unit-tests/minmax-stability-issue-23687.rs:36:39: 36:42]) -> bb7;
    }

    bb7: {
        _29 = &_30;
        _36 = &_1;
        _35 = Option::<&Foo>::Some(move _36);
        _34 = &_35;
        _28 = (move _29, move _34);
        _37 = (_28.0: &std::option::Option<&Foo>);
        _38 = (_28.1: &std::option::Option<&Foo>);
        _40 = <Option<&Foo> as PartialEq>::eq(_37, _38) -> bb8;
    }

    bb8: {
        _39 = Not(move _40);
        switchInt(move _39) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _41 = core::panicking::AssertKind::Eq;
        _43 = Option::<Arguments<'_>>::None;
        _42 = core::panicking::assert_failed::<Option<&Foo>, Option<&Foo>>(move _41, _37, _38, move _43);
    }

    bb10: {
        _47 = _1;
        _48 = _2;
        _46 = std::cmp::min::<Foo>(move _47, move _48) -> bb11;
    }

    bb11: {
        _45 = &_46;
        _49 = &_1;
        _44 = (move _45, move _49);
        _50 = (_44.0: &Foo);
        _51 = (_44.1: &Foo);
        _53 = <Foo as PartialEq>::eq(_50, _51) -> bb12;
    }

    bb12: {
        _52 = Not(move _53);
        switchInt(move _52) -> [0: bb14, otherwise: bb13];
    }

    bb13: {
        _54 = core::panicking::AssertKind::Eq;
        _56 = Option::<Arguments<'_>>::None;
        _55 = core::panicking::assert_failed::<Foo, Foo>(move _54, _50, _51, move _56);
    }

    bb14: {
        _60 = _2;
        _61 = _1;
        _59 = std::cmp::min::<Foo>(move _60, move _61) -> bb15;
    }

    bb15: {
        _58 = &_59;
        _62 = &_2;
        _57 = (move _58, move _62);
        _63 = (_57.0: &Foo);
        _64 = (_57.1: &Foo);
        _66 = <Foo as PartialEq>::eq(_63, _64) -> bb16;
    }

    bb16: {
        _65 = Not(move _66);
        switchInt(move _65) -> [0: bb18, otherwise: bb17];
    }

    bb17: {
        _67 = core::panicking::AssertKind::Eq;
        _69 = Option::<Arguments<'_>>::None;
        _68 = core::panicking::assert_failed::<Foo, Foo>(move _67, _63, _64, move _69);
    }

    bb18: {
        _75 = &_7;
        _74 = move _75 as &[Foo] (Pointer(Unsize));
        _73 = core::slice::<impl [Foo]>::iter(move _74) -> bb19;
    }

    bb19: {
        _72 = <std::slice::Iter<'_, Foo> as Iterator>::max(move _73) -> bb20;
    }

    bb20: {
        _71 = &_72;
        _78 = &_6;
        _77 = Option::<&Foo>::Some(move _78);
        _76 = &_77;
        _70 = (move _71, move _76);
        _79 = (_70.0: &std::option::Option<&Foo>);
        _80 = (_70.1: &std::option::Option<&Foo>);
        _82 = <Option<&Foo> as PartialEq>::eq(_79, _80) -> bb21;
    }

    bb21: {
        _81 = Not(move _82);
        switchInt(move _81) -> [0: bb23, otherwise: bb22];
    }

    bb22: {
        _83 = core::panicking::AssertKind::Eq;
        _85 = Option::<Arguments<'_>>::None;
        _84 = core::panicking::assert_failed::<Option<&Foo>, Option<&Foo>>(move _83, _79, _80, move _85);
    }

    bb23: {
        _91 = &_7;
        _90 = move _91 as &[Foo] (Pointer(Unsize));
        _89 = core::slice::<impl [Foo]>::iter(move _90) -> bb24;
    }

    bb24: {
        _88 = <std::slice::Iter<'_, Foo> as Iterator>::max_by_key::<u8, [closure@ui/stdlib-unit-tests/minmax-stability-issue-23687.rs:42:39: 42:42]>(move _89, const ZeroSized: [closure@ui/stdlib-unit-tests/minmax-stability-issue-23687.rs:42:39: 42:42]) -> bb25;
    }

    bb25: {
        _87 = &_88;
        _94 = &_6;
        _93 = Option::<&Foo>::Some(move _94);
        _92 = &_93;
        _86 = (move _87, move _92);
        _95 = (_86.0: &std::option::Option<&Foo>);
        _96 = (_86.1: &std::option::Option<&Foo>);
        _98 = <Option<&Foo> as PartialEq>::eq(_95, _96) -> bb26;
    }

    bb26: {
        _97 = Not(move _98);
        switchInt(move _97) -> [0: bb28, otherwise: bb27];
    }

    bb27: {
        _99 = core::panicking::AssertKind::Eq;
        _101 = Option::<Arguments<'_>>::None;
        _100 = core::panicking::assert_failed::<Option<&Foo>, Option<&Foo>>(move _99, _95, _96, move _101);
    }

    bb28: {
        _105 = _5;
        _106 = _6;
        _104 = std::cmp::max::<Foo>(move _105, move _106) -> bb29;
    }

    bb29: {
        _103 = &_104;
        _107 = &_6;
        _102 = (move _103, move _107);
        _108 = (_102.0: &Foo);
        _109 = (_102.1: &Foo);
        _111 = <Foo as PartialEq>::eq(_108, _109) -> bb30;
    }

    bb30: {
        _110 = Not(move _111);
        switchInt(move _110) -> [0: bb32, otherwise: bb31];
    }

    bb31: {
        _112 = core::panicking::AssertKind::Eq;
        _114 = Option::<Arguments<'_>>::None;
        _113 = core::panicking::assert_failed::<Foo, Foo>(move _112, _108, _109, move _114);
    }

    bb32: {
        _118 = _6;
        _119 = _5;
        _117 = std::cmp::max::<Foo>(move _118, move _119) -> bb33;
    }

    bb33: {
        _116 = &_117;
        _120 = &_5;
        _115 = (move _116, move _120);
        _121 = (_115.0: &Foo);
        _122 = (_115.1: &Foo);
        _124 = <Foo as PartialEq>::eq(_121, _122) -> bb34;
    }

    bb34: {
        _123 = Not(move _124);
        switchInt(move _123) -> [0: bb36, otherwise: bb35];
    }

    bb35: {
        _125 = core::panicking::AssertKind::Eq;
        _127 = Option::<Arguments<'_>>::None;
        _126 = core::panicking::assert_failed::<Foo, Foo>(move _125, _121, _122, move _127);
    }

    bb36: {
        _130 = &_7;
        _129 = move _130 as &[Foo] (Pointer(Unsize));
        _128 = slice::<impl [Foo]>::to_vec(move _129) -> bb37;
    }

    bb37: {
        _134 = &mut _128;
        _133 = <Vec<Foo> as DerefMut>::deref_mut(move _134) -> [return: bb38, unwind: bb50];
    }

    bb38: {
        _132 = _133;
        _131 = slice::<impl [Foo]>::sort(move _132) -> [return: bb39, unwind: bb50];
    }

    bb39: {
        _138 = &_128;
        _137 = <Vec<Foo> as Deref>::deref(_138) -> [return: bb40, unwind: bb50];
    }

    bb40: {
        _136 = _137;
        _135 = assert_stable::<Foo>(move _136) -> [return: bb41, unwind: bb50];
    }

    bb41: {
        _141 = &_7;
        _140 = move _141 as &[Foo] (Pointer(Unsize));
        _139 = slice::<impl [Foo]>::to_vec(move _140) -> [return: bb42, unwind: bb50];
    }

    bb42: {
        _145 = &mut _139;
        _144 = <Vec<Foo> as DerefMut>::deref_mut(move _145) -> [return: bb43, unwind: bb49];
    }

    bb43: {
        _143 = _144;
        _142 = slice::<impl [Foo]>::sort_by::<[closure@ui/stdlib-unit-tests/minmax-stability-issue-23687.rs:51:23: 51:29]>(move _143, const ZeroSized: [closure@ui/stdlib-unit-tests/minmax-stability-issue-23687.rs:51:23: 51:29]) -> [return: bb44, unwind: bb49];
    }

    bb44: {
        _149 = &_139;
        _148 = <Vec<Foo> as Deref>::deref(_149) -> [return: bb45, unwind: bb49];
    }

    bb45: {
        _147 = _148;
        _146 = assert_stable::<Foo>(move _147) -> [return: bb46, unwind: bb49];
    }

    bb46: {
        drop(_139) -> [return: bb47, unwind: bb50];
    }

    bb47: {
        drop(_128) -> bb48;
    }

    bb48: {
        return;
    }

    bb49 (cleanup): {
        drop(_139) -> [return: bb50, unwind terminate];
    }

    bb50 (cleanup): {
        drop(_128) -> [return: bb51, unwind terminate];
    }

    bb51 (cleanup): {
        resume;
    }
}

fn main::{closure#1}(_1: &mut [closure@ui/stdlib-unit-tests/minmax-stability-issue-23687.rs:36:39: 36:42], _2: &&Foo) -> u8 {
    debug a => _2;
    let mut _0: u8;
    let mut _3: &Foo;

    bb0: {
        _3 = deref_copy (*_2);
        _0 = ((*_3).0: u8);
        return;
    }
}

fn main::{closure#2}(_1: &mut [closure@ui/stdlib-unit-tests/minmax-stability-issue-23687.rs:42:39: 42:42], _2: &&Foo) -> u8 {
    debug a => _2;
    let mut _0: u8;
    let mut _3: &Foo;

    bb0: {
        _3 = deref_copy (*_2);
        _0 = ((*_3).0: u8);
        return;
    }
}

fn main::{closure#0}(_1: &mut [closure@ui/stdlib-unit-tests/minmax-stability-issue-23687.rs:51:23: 51:29], _2: &Foo, _3: &Foo) -> std::cmp::Ordering {
    debug a => _2;
    debug b => _3;
    let mut _0: std::cmp::Ordering;

    bb0: {
        _0 = <Foo as Ord>::cmp(_2, _3) -> bb1;
    }

    bb1: {
        return;
    }
}

fn assert_stable(_1: &[T]) -> () {
    debug presorted => _1;
    let mut _0: ();
    let mut _2: std::slice::Windows<'_, T>;
    let mut _3: std::slice::Windows<'_, T>;
    let mut _4: std::slice::Windows<'_, T>;
    let mut _5: std::option::Option<&[T]>;
    let mut _6: &mut std::slice::Windows<'_, T>;
    let mut _7: isize;
    let _10: usize;
    let mut _11: usize;
    let mut _12: bool;
    let _14: usize;
    let mut _15: usize;
    let mut _16: bool;
    let mut _17: (&&T, &&T);
    let mut _18: &&T;
    let mut _19: &&T;
    let _20: &T;
    let mut _21: &T;
    let mut _22: &T;
    let mut _25: bool;
    let mut _26: bool;
    let _28: !;
    let mut _29: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _30: (&&T, &&T);
    let mut _31: &&T;
    let mut _32: &&T;
    let _33: &T;
    let mut _34: &T;
    let mut _35: &T;
    let mut _38: bool;
    let mut _39: bool;
    let _41: !;
    let mut _42: std::option::Option<std::fmt::Arguments<'_>>;
    scope 1 {
        debug iter => _4;
        let _8: &[T];
        scope 2 {
            debug slice => _8;
            let _9: &T;
            scope 3 {
                debug a => _9;
                let _13: &T;
                scope 4 {
                    debug b => _13;
                    let _23: &&T;
                    let _24: &&T;
                    let _36: &&T;
                    let _37: &&T;
                    scope 5 {
                        debug left_val => _23;
                        debug right_val => _24;
                        let _27: core::panicking::AssertKind;
                        scope 6 {
                            debug kind => _27;
                        }
                    }
                    scope 7 {
                        debug left_val => _36;
                        debug right_val => _37;
                        let _40: core::panicking::AssertKind;
                        scope 8 {
                            debug kind => _40;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _3 = core::slice::<impl [T]>::windows(_1, const 2_usize) -> bb1;
    }

    bb1: {
        _2 = <Windows<'_, T> as IntoIterator>::into_iter(move _3) -> bb2;
    }

    bb2: {
        _4 = move _2;
        goto -> bb3;
    }

    bb3: {
        _6 = &mut _4;
        _5 = <Windows<'_, T> as Iterator>::next(_6) -> bb4;
    }

    bb4: {
        _7 = discriminant(_5);
        switchInt(move _7) -> [0: bb7, 1: bb5, otherwise: bb6];
    }

    bb5: {
        _8 = ((_5 as Some).0: &[T]);
        _10 = const 0_usize;
        _11 = Len((*_8));
        _12 = Lt(_10, _11);
        assert(move _12, "index out of bounds: the length is {} but the index is {}", move _11, _10) -> bb8;
    }

    bb6: {
        unreachable;
    }

    bb7: {
        return;
    }

    bb8: {
        _9 = &(*_8)[_10];
        _14 = const 1_usize;
        _15 = Len((*_8));
        _16 = Lt(_14, _15);
        assert(move _16, "index out of bounds: the length is {} but the index is {}", move _15, _14) -> bb9;
    }

    bb9: {
        _13 = &(*_8)[_14];
        _18 = &_9;
        _21 = _9;
        _22 = _13;
        _20 = std::cmp::min::<&T>(move _21, move _22) -> bb10;
    }

    bb10: {
        _19 = &_20;
        _17 = (move _18, move _19);
        _23 = (_17.0: &&T);
        _24 = (_17.1: &&T);
        _26 = <&T as PartialEq>::eq(_23, _24) -> bb11;
    }

    bb11: {
        _25 = Not(move _26);
        switchInt(move _25) -> [0: bb13, otherwise: bb12];
    }

    bb12: {
        _27 = core::panicking::AssertKind::Eq;
        _29 = Option::<Arguments<'_>>::None;
        _28 = core::panicking::assert_failed::<&T, &T>(move _27, _23, _24, move _29);
    }

    bb13: {
        _31 = &_13;
        _34 = _9;
        _35 = _13;
        _33 = std::cmp::max::<&T>(move _34, move _35) -> bb14;
    }

    bb14: {
        _32 = &_33;
        _30 = (move _31, move _32);
        _36 = (_30.0: &&T);
        _37 = (_30.1: &&T);
        _39 = <&T as PartialEq>::eq(_36, _37) -> bb15;
    }

    bb15: {
        _38 = Not(move _39);
        switchInt(move _38) -> [0: bb3, otherwise: bb16];
    }

    bb16: {
        _40 = core::panicking::AssertKind::Eq;
        _42 = Option::<Arguments<'_>>::None;
        _41 = core::panicking::assert_failed::<&T, &T>(move _40, _36, _37, move _42);
    }
}
