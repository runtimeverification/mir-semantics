// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn main() -> () {
    let mut _0: ();
    let mut _1: bool;
    let mut _2: bool;
    let mut _3: !;
    scope 1 {
    }

    bb0: {
        _2 = test_triangle() -> bb1;
    }

    bb1: {
        _1 = Not(move _2);
        switchInt(move _1) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _3 = core::panicking::panic(const "assertion failed: test_triangle()");
    }

    bb3: {
        return;
    }
}

fn test_triangle() -> bool {
    let mut _0: bool;
    let mut _1: std::vec::Vec<*mut u8>;
    let mut _2: *mut u8;
    let mut _3: usize;
    let mut _4: &usize;
    let mut _6: &mut [*mut u8];
    let mut _7: &mut std::vec::Vec<*mut u8>;
    let mut _8: std::ops::Range<usize>;
    let mut _9: std::ops::Range<usize>;
    let mut _10: usize;
    let mut _11: usize;
    let mut _12: &usize;
    let mut _13: bool;
    let mut _15: std::option::Option<usize>;
    let mut _16: &mut std::ops::Range<usize>;
    let mut _17: isize;
    let mut _20: *mut u8;
    let mut _21: std::alloc::Layout;
    let mut _22: std::result::Result<std::alloc::Layout, std::alloc::LayoutError>;
    let mut _23: usize;
    let mut _24: usize;
    let mut _25: &usize;
    let _26: usize;
    let mut _27: usize;
    let mut _28: bool;
    let mut _29: *mut u8;
    let mut _30: std::alloc::Layout;
    let mut _31: std::result::Result<std::alloc::Layout, std::alloc::LayoutError>;
    let mut _32: usize;
    let mut _33: usize;
    let mut _34: &usize;
    let _35: usize;
    let mut _36: usize;
    let mut _37: usize;
    let mut _38: bool;
    let mut _39: std::ops::Range<usize>;
    let mut _40: std::ops::Range<usize>;
    let mut _41: usize;
    let mut _42: usize;
    let mut _43: &usize;
    let mut _44: bool;
    let mut _46: std::option::Option<usize>;
    let mut _47: &mut std::ops::Range<usize>;
    let mut _48: isize;
    let mut _53: (*mut u8, *mut u8, usize);
    let mut _54: *mut u8;
    let _55: usize;
    let mut _56: usize;
    let mut _57: bool;
    let mut _58: *mut u8;
    let _59: usize;
    let mut _60: usize;
    let mut _61: usize;
    let mut _62: bool;
    let mut _63: usize;
    let mut _64: std::ops::Range<usize>;
    let mut _65: std::ops::Range<usize>;
    let mut _67: std::option::Option<usize>;
    let mut _68: &mut std::ops::Range<usize>;
    let mut _69: isize;
    let mut _71: *mut u8;
    let mut _72: *mut u8;
    let _73: ();
    let _74: &[*mut u8];
    let _75: ();
    let _76: ();
    let _77: ();
    let _78: ();
    let mut _79: std::ops::Range<usize>;
    let mut _80: std::ops::Range<usize>;
    let mut _81: usize;
    let mut _82: usize;
    let mut _83: &usize;
    let mut _84: bool;
    let mut _86: std::option::Option<usize>;
    let mut _87: &mut std::ops::Range<usize>;
    let mut _88: isize;
    let _91: ();
    let mut _92: *mut u8;
    let _93: usize;
    let mut _94: usize;
    let mut _95: bool;
    let mut _96: std::alloc::Layout;
    let mut _97: std::result::Result<std::alloc::Layout, std::alloc::LayoutError>;
    let mut _98: usize;
    let mut _99: usize;
    let mut _100: &usize;
    let _101: ();
    let mut _102: *mut u8;
    let _103: usize;
    let mut _104: usize;
    let mut _105: usize;
    let mut _106: bool;
    let mut _107: std::alloc::Layout;
    let mut _108: std::result::Result<std::alloc::Layout, std::alloc::LayoutError>;
    let mut _109: usize;
    let mut _110: usize;
    let mut _111: &usize;
    scope 1 {
        debug ascend => _1;
        let _5: &mut [*mut u8];
        scope 2 {
            debug ascend => _5;
            let mut _14: std::ops::Range<usize>;
            let mut _45: std::ops::Range<usize>;
            let mut _85: std::ops::Range<usize>;
            scope 3 {
                debug iter => _14;
                let _18: usize;
                scope 4 {
                    debug i => _18;
                    let _19: usize;
                    scope 5 {
                        debug size => _19;
                    }
                }
            }
            scope 6 {
                debug iter => _45;
                let _49: usize;
                scope 7 {
                    debug i => _49;
                    let _50: *mut u8;
                    let _51: *mut u8;
                    let _52: usize;
                    scope 8 {
                        debug p0 => _50;
                        debug p1 => _51;
                        debug size => _52;
                        let mut _66: std::ops::Range<usize>;
                        scope 9 {
                            debug iter => _66;
                            let _70: usize;
                            scope 10 {
                                debug j => _70;
                            }
                        }
                    }
                }
            }
            scope 11 {
                debug iter => _85;
                let _89: usize;
                scope 12 {
                    debug i => _89;
                    let _90: usize;
                    scope 13 {
                        debug size => _90;
                    }
                }
            }
        }
    }

    bb0: {
        _2 = null_mut::<u8>() -> bb1;
    }

    bb1: {
        _4 = const {alloc1: &usize};
        _3 = (*_4);
        _1 = from_elem::<*mut u8>(move _2, move _3) -> bb2;
    }

    bb2: {
        _7 = &mut _1;
        _6 = <Vec<*mut u8> as DerefMut>::deref_mut(move _7) -> [return: bb3, unwind: bb55];
    }

    bb3: {
        _5 = _6;
        _12 = const {alloc1: &usize};
        _11 = (*_12);
        _13 = Eq(const 2_usize, const 0_usize);
        assert(!move _13, "attempt to divide `{}` by zero", _11) -> [success: bb4, unwind: bb55];
    }

    bb4: {
        _10 = Div(move _11, const 2_usize);
        _9 = std::ops::Range::<usize> { start: const 0_usize, end: move _10 };
        _8 = <std::ops::Range<usize> as IntoIterator>::into_iter(move _9) -> [return: bb5, unwind: bb55];
    }

    bb5: {
        _14 = move _8;
        goto -> bb6;
    }

    bb6: {
        _16 = &mut _14;
        _15 = <std::ops::Range<usize> as Iterator>::next(_16) -> [return: bb7, unwind: bb55];
    }

    bb7: {
        _17 = discriminant(_15);
        switchInt(move _17) -> [0: bb10, 1: bb8, otherwise: bb9];
    }

    bb8: {
        _18 = ((_15 as Some).0: usize);
        _19 = idx_to_size(_18) -> [return: bb11, unwind: bb55];
    }

    bb9: {
        unreachable;
    }

    bb10: {
        _43 = const {alloc1: &usize};
        _42 = (*_43);
        _44 = Eq(const 2_usize, const 0_usize);
        assert(!move _44, "attempt to divide `{}` by zero", _42) -> [success: bb20, unwind: bb55];
    }

    bb11: {
        _23 = _19;
        _25 = const {alloc2: &usize};
        _24 = (*_25);
        _22 = Layout::from_size_align(move _23, move _24) -> [return: bb12, unwind: bb55];
    }

    bb12: {
        _21 = Result::<Layout, LayoutError>::unwrap(move _22) -> [return: bb13, unwind: bb55];
    }

    bb13: {
        _20 = test_triangle::allocate(move _21) -> [return: bb14, unwind: bb55];
    }

    bb14: {
        _26 = Mul(const 2_usize, _18);
        _27 = Len((*_5));
        _28 = Lt(_26, _27);
        assert(move _28, "index out of bounds: the length is {} but the index is {}", move _27, _26) -> [success: bb15, unwind: bb55];
    }

    bb15: {
        (*_5)[_26] = move _20;
        _32 = _19;
        _34 = const {alloc2: &usize};
        _33 = (*_34);
        _31 = Layout::from_size_align(move _32, move _33) -> [return: bb16, unwind: bb55];
    }

    bb16: {
        _30 = Result::<Layout, LayoutError>::unwrap(move _31) -> [return: bb17, unwind: bb55];
    }

    bb17: {
        _29 = test_triangle::allocate(move _30) -> [return: bb18, unwind: bb55];
    }

    bb18: {
        _36 = Mul(const 2_usize, _18);
        _35 = Add(move _36, const 1_usize);
        _37 = Len((*_5));
        _38 = Lt(_35, _37);
        assert(move _38, "index out of bounds: the length is {} but the index is {}", move _37, _35) -> [success: bb19, unwind: bb55];
    }

    bb19: {
        (*_5)[_35] = move _29;
        goto -> bb6;
    }

    bb20: {
        _41 = Div(move _42, const 2_usize);
        _40 = std::ops::Range::<usize> { start: const 0_usize, end: move _41 };
        _39 = <std::ops::Range<usize> as IntoIterator>::into_iter(move _40) -> [return: bb21, unwind: bb55];
    }

    bb21: {
        _45 = move _39;
        goto -> bb22;
    }

    bb22: {
        _47 = &mut _45;
        _46 = <std::ops::Range<usize> as Iterator>::next(_47) -> [return: bb23, unwind: bb55];
    }

    bb23: {
        _48 = discriminant(_46);
        switchInt(move _48) -> [0: bb25, 1: bb24, otherwise: bb9];
    }

    bb24: {
        _49 = ((_46 as Some).0: usize);
        _55 = Mul(const 2_usize, _49);
        _56 = Len((*_5));
        _57 = Lt(_55, _56);
        assert(move _57, "index out of bounds: the length is {} but the index is {}", move _56, _55) -> [success: bb26, unwind: bb55];
    }

    bb25: {
        _74 = &(*_5);
        _73 = sanity_check(_74) -> [return: bb35, unwind: bb55];
    }

    bb26: {
        _54 = (*_5)[_55];
        _60 = Mul(const 2_usize, _49);
        _59 = Add(move _60, const 1_usize);
        _61 = Len((*_5));
        _62 = Lt(_59, _61);
        assert(move _62, "index out of bounds: the length is {} but the index is {}", move _61, _59) -> [success: bb27, unwind: bb55];
    }

    bb27: {
        _58 = (*_5)[_59];
        _63 = idx_to_size(_49) -> [return: bb28, unwind: bb55];
    }

    bb28: {
        _53 = (move _54, move _58, move _63);
        _50 = (_53.0: *mut u8);
        _51 = (_53.1: *mut u8);
        _52 = (_53.2: usize);
        _65 = std::ops::Range::<usize> { start: const 0_usize, end: _52 };
        _64 = <std::ops::Range<usize> as IntoIterator>::into_iter(move _65) -> [return: bb29, unwind: bb55];
    }

    bb29: {
        _66 = move _64;
        goto -> bb30;
    }

    bb30: {
        _68 = &mut _66;
        _67 = <std::ops::Range<usize> as Iterator>::next(_68) -> [return: bb31, unwind: bb55];
    }

    bb31: {
        _69 = discriminant(_67);
        switchInt(move _69) -> [0: bb22, 1: bb32, otherwise: bb9];
    }

    bb32: {
        _70 = ((_67 as Some).0: usize);
        _71 = ptr::mut_ptr::<impl *mut u8>::add(_50, _70) -> [return: bb33, unwind: bb55];
    }

    bb33: {
        (*_71) = _49 as u8 (IntToInt);
        _72 = ptr::mut_ptr::<impl *mut u8>::add(_51, _70) -> [return: bb34, unwind: bb55];
    }

    bb34: {
        (*_72) = _49 as u8 (IntToInt);
        goto -> bb30;
    }

    bb35: {
        _75 = test_1(_5) -> [return: bb36, unwind: bb55];
    }

    bb36: {
        _76 = test_2(_5) -> [return: bb37, unwind: bb55];
    }

    bb37: {
        _77 = test_3(_5) -> [return: bb38, unwind: bb55];
    }

    bb38: {
        _78 = test_4(_5) -> [return: bb39, unwind: bb55];
    }

    bb39: {
        _83 = const {alloc1: &usize};
        _82 = (*_83);
        _84 = Eq(const 2_usize, const 0_usize);
        assert(!move _84, "attempt to divide `{}` by zero", _82) -> [success: bb40, unwind: bb55];
    }

    bb40: {
        _81 = Div(move _82, const 2_usize);
        _80 = std::ops::Range::<usize> { start: const 0_usize, end: move _81 };
        _79 = <std::ops::Range<usize> as IntoIterator>::into_iter(move _80) -> [return: bb41, unwind: bb55];
    }

    bb41: {
        _85 = move _79;
        goto -> bb42;
    }

    bb42: {
        _87 = &mut _85;
        _86 = <std::ops::Range<usize> as Iterator>::next(_87) -> [return: bb43, unwind: bb55];
    }

    bb43: {
        _88 = discriminant(_86);
        switchInt(move _88) -> [0: bb45, 1: bb44, otherwise: bb9];
    }

    bb44: {
        _89 = ((_86 as Some).0: usize);
        _90 = idx_to_size(_89) -> [return: bb46, unwind: bb55];
    }

    bb45: {
        _0 = const true;
        drop(_1) -> bb54;
    }

    bb46: {
        _93 = Mul(const 2_usize, _89);
        _94 = Len((*_5));
        _95 = Lt(_93, _94);
        assert(move _95, "index out of bounds: the length is {} but the index is {}", move _94, _93) -> [success: bb47, unwind: bb55];
    }

    bb47: {
        _92 = (*_5)[_93];
        _98 = _90;
        _100 = const {alloc2: &usize};
        _99 = (*_100);
        _97 = Layout::from_size_align(move _98, move _99) -> [return: bb48, unwind: bb55];
    }

    bb48: {
        _96 = Result::<Layout, LayoutError>::unwrap(move _97) -> [return: bb49, unwind: bb55];
    }

    bb49: {
        _91 = test_triangle::deallocate(move _92, move _96) -> [return: bb50, unwind: bb55];
    }

    bb50: {
        _104 = Mul(const 2_usize, _89);
        _103 = Add(move _104, const 1_usize);
        _105 = Len((*_5));
        _106 = Lt(_103, _105);
        assert(move _106, "index out of bounds: the length is {} but the index is {}", move _105, _103) -> [success: bb51, unwind: bb55];
    }

    bb51: {
        _102 = (*_5)[_103];
        _109 = _90;
        _111 = const {alloc2: &usize};
        _110 = (*_111);
        _108 = Layout::from_size_align(move _109, move _110) -> [return: bb52, unwind: bb55];
    }

    bb52: {
        _107 = Result::<Layout, LayoutError>::unwrap(move _108) -> [return: bb53, unwind: bb55];
    }

    bb53: {
        _101 = test_triangle::deallocate(move _102, move _107) -> [return: bb57, unwind: bb55];
    }

    bb54: {
        return;
    }

    bb55 (cleanup): {
        drop(_1) -> [return: bb56, unwind terminate];
    }

    bb56 (cleanup): {
        resume;
    }

    bb57: {
        goto -> bb42;
    }
}

alloc2 (static: ALIGN, size: 8, align: 8) {
    01 00 00 00 00 00 00 00                         │ ........
}

alloc1 (static: COUNT, size: 8, align: 8) {
    10 00 00 00 00 00 00 00                         │ ........
}

static COUNT: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 16_usize;
        return;
    }
}

static ALIGN: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

fn sanity_check(_1: &[*mut u8]) -> () {
    debug ascend => _1;
    let mut _0: ();
    let mut _2: std::ops::Range<usize>;
    let mut _3: std::ops::Range<usize>;
    let mut _4: usize;
    let mut _5: usize;
    let mut _6: &usize;
    let mut _7: bool;
    let mut _8: std::ops::Range<usize>;
    let mut _9: std::option::Option<usize>;
    let mut _10: &mut std::ops::Range<usize>;
    let mut _11: isize;
    let mut _16: (*mut u8, *mut u8, usize);
    let mut _17: *mut u8;
    let _18: usize;
    let mut _19: usize;
    let mut _20: bool;
    let mut _21: *mut u8;
    let _22: usize;
    let mut _23: usize;
    let mut _24: usize;
    let mut _25: bool;
    let mut _26: usize;
    let mut _27: std::ops::Range<usize>;
    let mut _28: std::ops::Range<usize>;
    let mut _30: std::option::Option<usize>;
    let mut _31: &mut std::ops::Range<usize>;
    let mut _32: isize;
    let mut _34: (&u8, &u8);
    let mut _35: &u8;
    let _36: *mut u8;
    let mut _37: &u8;
    let _38: u8;
    let mut _41: bool;
    let mut _42: bool;
    let mut _43: u8;
    let mut _44: u8;
    let _46: !;
    let mut _47: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _48: (&u8, &u8);
    let mut _49: &u8;
    let _50: *mut u8;
    let mut _51: &u8;
    let _52: u8;
    let mut _55: bool;
    let mut _56: bool;
    let mut _57: u8;
    let mut _58: u8;
    let _60: !;
    let mut _61: std::option::Option<std::fmt::Arguments<'_>>;
    scope 1 {
        debug iter => _8;
        let _12: usize;
        scope 2 {
            debug i => _12;
            let _13: *mut u8;
            let _14: *mut u8;
            let _15: usize;
            scope 3 {
                debug p0 => _13;
                debug p1 => _14;
                debug size => _15;
                let mut _29: std::ops::Range<usize>;
                scope 4 {
                    debug iter => _29;
                    let _33: usize;
                    scope 5 {
                        debug j => _33;
                        let _39: &u8;
                        let _40: &u8;
                        let _53: &u8;
                        let _54: &u8;
                        scope 6 {
                            debug left_val => _39;
                            debug right_val => _40;
                            let _45: core::panicking::AssertKind;
                            scope 7 {
                                debug kind => _45;
                            }
                        }
                        scope 8 {
                            debug left_val => _53;
                            debug right_val => _54;
                            let _59: core::panicking::AssertKind;
                            scope 9 {
                                debug kind => _59;
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _6 = const {alloc1: &usize};
        _5 = (*_6);
        _7 = Eq(const 2_usize, const 0_usize);
        assert(!move _7, "attempt to divide `{}` by zero", _5) -> bb1;
    }

    bb1: {
        _4 = Div(move _5, const 2_usize);
        _3 = std::ops::Range::<usize> { start: const 0_usize, end: move _4 };
        _2 = <std::ops::Range<usize> as IntoIterator>::into_iter(move _3) -> bb2;
    }

    bb2: {
        _8 = move _2;
        goto -> bb3;
    }

    bb3: {
        _10 = &mut _8;
        _9 = <std::ops::Range<usize> as Iterator>::next(_10) -> bb4;
    }

    bb4: {
        _11 = discriminant(_9);
        switchInt(move _11) -> [0: bb7, 1: bb5, otherwise: bb6];
    }

    bb5: {
        _12 = ((_9 as Some).0: usize);
        _18 = Mul(const 2_usize, _12);
        _19 = Len((*_1));
        _20 = Lt(_18, _19);
        assert(move _20, "index out of bounds: the length is {} but the index is {}", move _19, _18) -> bb8;
    }

    bb6: {
        unreachable;
    }

    bb7: {
        return;
    }

    bb8: {
        _17 = (*_1)[_18];
        _23 = Mul(const 2_usize, _12);
        _22 = Add(move _23, const 1_usize);
        _24 = Len((*_1));
        _25 = Lt(_22, _24);
        assert(move _25, "index out of bounds: the length is {} but the index is {}", move _24, _22) -> bb9;
    }

    bb9: {
        _21 = (*_1)[_22];
        _26 = idx_to_size(_12) -> bb10;
    }

    bb10: {
        _16 = (move _17, move _21, move _26);
        _13 = (_16.0: *mut u8);
        _14 = (_16.1: *mut u8);
        _15 = (_16.2: usize);
        _28 = std::ops::Range::<usize> { start: const 0_usize, end: _15 };
        _27 = <std::ops::Range<usize> as IntoIterator>::into_iter(move _28) -> bb11;
    }

    bb11: {
        _29 = move _27;
        goto -> bb12;
    }

    bb12: {
        _31 = &mut _29;
        _30 = <std::ops::Range<usize> as Iterator>::next(_31) -> bb13;
    }

    bb13: {
        _32 = discriminant(_30);
        switchInt(move _32) -> [0: bb3, 1: bb14, otherwise: bb6];
    }

    bb14: {
        _33 = ((_30 as Some).0: usize);
        _36 = ptr::mut_ptr::<impl *mut u8>::add(_13, _33) -> bb15;
    }

    bb15: {
        _35 = &(*_36);
        _38 = _12 as u8 (IntToInt);
        _37 = &_38;
        _34 = (move _35, move _37);
        _39 = (_34.0: &u8);
        _40 = (_34.1: &u8);
        _43 = (*_39);
        _44 = (*_40);
        _42 = Eq(move _43, move _44);
        _41 = Not(move _42);
        switchInt(move _41) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _45 = core::panicking::AssertKind::Eq;
        _47 = Option::<Arguments<'_>>::None;
        _46 = core::panicking::assert_failed::<u8, u8>(move _45, _39, _40, move _47);
    }

    bb17: {
        _50 = ptr::mut_ptr::<impl *mut u8>::add(_14, _33) -> bb18;
    }

    bb18: {
        _49 = &(*_50);
        _52 = _12 as u8 (IntToInt);
        _51 = &_52;
        _48 = (move _49, move _51);
        _53 = (_48.0: &u8);
        _54 = (_48.1: &u8);
        _57 = (*_53);
        _58 = (*_54);
        _56 = Eq(move _57, move _58);
        _55 = Not(move _56);
        switchInt(move _55) -> [0: bb12, otherwise: bb19];
    }

    bb19: {
        _59 = core::panicking::AssertKind::Eq;
        _61 = Option::<Arguments<'_>>::None;
        _60 = core::panicking::assert_failed::<u8, u8>(move _59, _53, _54, move _61);
    }
}

alloc1 (static: COUNT, size: 8, align: 8) {
    10 00 00 00 00 00 00 00                         │ ........
}

static PRINT: bool = {
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn test_triangle::allocate(_1: Layout) -> *mut u8 {
    debug layout => _1;
    let mut _0: *mut u8;
    let mut _2: bool;
    let mut _3: &bool;
    let _4: ();
    let mut _5: std::fmt::Arguments<'_>;
    let mut _6: &[&str];
    let _7: &[&str; 2];
    let _8: [&str; 2];
    let mut _9: &[core::fmt::rt::Argument<'_>];
    let _10: &[core::fmt::rt::Argument<'_>; 1];
    let _11: [core::fmt::rt::Argument<'_>; 1];
    let mut _12: core::fmt::rt::Argument<'_>;
    let _13: &std::alloc::Layout;
    let _14: std::ptr::NonNull<[u8]>;
    let mut _15: std::result::Result<std::ptr::NonNull<[u8]>, std::alloc::AllocError>;
    let mut _16: &std::alloc::Global;
    let _17: std::alloc::Global;
    let mut _18: std::alloc::Layout;
    let mut _19: [closure@ui/realloc-16687.rs:45:58: 45:61];
    let mut _20: &std::alloc::Layout;
    let mut _21: bool;
    let mut _22: &bool;
    let _23: ();
    let mut _24: std::fmt::Arguments<'_>;
    let mut _25: &[&str];
    let _26: &[&str; 3];
    let _27: [&str; 3];
    let mut _28: &[core::fmt::rt::Argument<'_>];
    let _29: &[core::fmt::rt::Argument<'_>; 2];
    let _30: [core::fmt::rt::Argument<'_>; 2];
    let mut _31: core::fmt::rt::Argument<'_>;
    let _32: &std::alloc::Layout;
    let mut _33: core::fmt::rt::Argument<'_>;
    let _34: &std::ptr::NonNull<[u8]>;
    let mut _35: std::ptr::NonNull<[u8]>;
    scope 1 {
        debug ptr => _14;
    }

    bb0: {
        _3 = const {alloc3: &bool};
        _2 = (*_3);
        switchInt(move _2) -> [0: bb4, otherwise: bb1];
    }

    bb1: {
        _8 = [const "allocate(", const ")\n"];
        _7 = &_8;
        _6 = _7 as &[&str] (Pointer(Unsize));
        _13 = &_1;
        _12 = core::fmt::rt::Argument::<'_>::new_debug::<Layout>(_13) -> bb2;
    }

    bb2: {
        _11 = [move _12];
        _10 = &_11;
        _9 = _10 as &[core::fmt::rt::Argument<'_>] (Pointer(Unsize));
        _5 = Arguments::<'_>::new_v1(move _6, move _9) -> bb3;
    }

    bb3: {
        _4 = _print(move _5) -> bb4;
    }

    bb4: {
        _16 = &_17;
        _18 = _1;
        _15 = <std::alloc::Global as Allocator>::allocate(move _16, move _18) -> bb5;
    }

    bb5: {
        _20 = &_1;
        _19 = [closure@ui/realloc-16687.rs:45:58: 45:61] { layout: move _20 };
        _14 = Result::<NonNull<[u8]>, std::alloc::AllocError>::unwrap_or_else::<[closure@ui/realloc-16687.rs:45:58: 45:61]>(move _15, move _19) -> bb6;
    }

    bb6: {
        _22 = const {alloc3: &bool};
        _21 = (*_22);
        switchInt(move _21) -> [0: bb11, otherwise: bb7];
    }

    bb7: {
        _27 = [const "allocate(", const ") = ", const "\n"];
        _26 = &_27;
        _25 = _26 as &[&str] (Pointer(Unsize));
        _32 = &_1;
        _31 = core::fmt::rt::Argument::<'_>::new_debug::<Layout>(_32) -> bb8;
    }

    bb8: {
        _34 = &_14;
        _33 = core::fmt::rt::Argument::<'_>::new_debug::<NonNull<[u8]>>(_34) -> bb9;
    }

    bb9: {
        _30 = [move _31, move _33];
        _29 = &_30;
        _28 = _29 as &[core::fmt::rt::Argument<'_>] (Pointer(Unsize));
        _24 = Arguments::<'_>::new_v1(move _25, move _28) -> bb10;
    }

    bb10: {
        _23 = _print(move _24) -> bb11;
    }

    bb11: {
        _35 = _14;
        _0 = NonNull::<[u8]>::as_mut_ptr(move _35) -> bb12;
    }

    bb12: {
        return;
    }
}

alloc3 (static: PRINT, size: 1, align: 1) {
    00                                              │ .
}

fn test_triangle::allocate::{closure#0}(_1: [closure@ui/realloc-16687.rs:45:58: 45:61], _2: std::alloc::AllocError) -> NonNull<[u8]> {
    debug layout => (*(_1.0: &std::alloc::Layout));
    let mut _0: std::ptr::NonNull<[u8]>;
    let mut _3: !;
    let mut _4: std::alloc::Layout;
    let mut _5: &std::alloc::Layout;

    bb0: {
        _5 = deref_copy (_1.0: &std::alloc::Layout);
        _4 = (*_5);
        _3 = handle_alloc_error(move _4);
    }
}

fn test_triangle::deallocate(_1: *mut u8, _2: Layout) -> () {
    debug ptr => _1;
    debug layout => _2;
    let mut _0: ();
    let mut _3: bool;
    let mut _4: &bool;
    let _5: ();
    let mut _6: std::fmt::Arguments<'_>;
    let mut _7: &[&str];
    let _8: &[&str; 3];
    let _9: [&str; 3];
    let mut _10: &[core::fmt::rt::Argument<'_>];
    let _11: &[core::fmt::rt::Argument<'_>; 2];
    let _12: [core::fmt::rt::Argument<'_>; 2];
    let mut _13: core::fmt::rt::Argument<'_>;
    let _14: &*mut u8;
    let mut _15: core::fmt::rt::Argument<'_>;
    let _16: &std::alloc::Layout;
    let _17: ();
    let mut _18: &std::alloc::Global;
    let _19: std::alloc::Global;
    let mut _20: std::ptr::NonNull<u8>;
    let mut _21: *mut u8;
    let mut _22: std::alloc::Layout;

    bb0: {
        _4 = const {alloc3: &bool};
        _3 = (*_4);
        switchInt(move _3) -> [0: bb5, otherwise: bb1];
    }

    bb1: {
        _9 = [const "deallocate(", const ", ", const "\n"];
        _8 = &_9;
        _7 = _8 as &[&str] (Pointer(Unsize));
        _14 = &_1;
        _13 = core::fmt::rt::Argument::<'_>::new_debug::<*mut u8>(_14) -> bb2;
    }

    bb2: {
        _16 = &_2;
        _15 = core::fmt::rt::Argument::<'_>::new_debug::<Layout>(_16) -> bb3;
    }

    bb3: {
        _12 = [move _13, move _15];
        _11 = &_12;
        _10 = _11 as &[core::fmt::rt::Argument<'_>] (Pointer(Unsize));
        _6 = Arguments::<'_>::new_v1(move _7, move _10) -> bb4;
    }

    bb4: {
        _5 = _print(move _6) -> bb5;
    }

    bb5: {
        _18 = &_19;
        _21 = _1;
        _20 = NonNull::<u8>::new_unchecked(move _21) -> bb6;
    }

    bb6: {
        _22 = _2;
        _17 = <std::alloc::Global as Allocator>::deallocate(move _18, move _20, move _22) -> bb7;
    }

    bb7: {
        return;
    }
}

alloc3 (static: PRINT, size: 1, align: 1) {
    00                                              │ .
}

fn reallocate(_1: *mut u8, _2: Layout, _3: Layout) -> *mut u8 {
    debug ptr => _1;
    debug old => _2;
    debug new => _3;
    let mut _0: *mut u8;
    let mut _4: bool;
    let mut _5: &bool;
    let _6: ();
    let mut _7: std::fmt::Arguments<'_>;
    let mut _8: &[&str];
    let _9: &[&str; 4];
    let _10: [&str; 4];
    let mut _11: &[core::fmt::rt::Argument<'_>];
    let _12: &[core::fmt::rt::Argument<'_>; 3];
    let _13: [core::fmt::rt::Argument<'_>; 3];
    let mut _14: core::fmt::rt::Argument<'_>;
    let _15: &*mut u8;
    let mut _16: core::fmt::rt::Argument<'_>;
    let _17: &std::alloc::Layout;
    let mut _18: core::fmt::rt::Argument<'_>;
    let _19: &std::alloc::Layout;
    let _20: std::result::Result<std::ptr::NonNull<[u8]>, std::alloc::AllocError>;
    let mut _21: bool;
    let mut _22: usize;
    let mut _23: &std::alloc::Layout;
    let mut _24: usize;
    let mut _25: &std::alloc::Layout;
    let mut _26: &std::alloc::Global;
    let _27: std::alloc::Global;
    let mut _28: std::ptr::NonNull<u8>;
    let mut _29: *mut u8;
    let mut _30: std::alloc::Layout;
    let mut _31: std::alloc::Layout;
    let mut _32: &std::alloc::Global;
    let _33: std::alloc::Global;
    let mut _34: std::ptr::NonNull<u8>;
    let mut _35: *mut u8;
    let mut _36: std::alloc::Layout;
    let mut _37: std::alloc::Layout;
    let mut _39: std::result::Result<std::ptr::NonNull<[u8]>, std::alloc::AllocError>;
    let mut _40: [closure@ui/realloc-16687.rs:73:41: 73:44];
    let mut _41: &std::alloc::Layout;
    let mut _42: bool;
    let mut _43: &bool;
    let _44: ();
    let mut _45: std::fmt::Arguments<'_>;
    let mut _46: &[&str];
    let _47: &[&str; 5];
    let _48: [&str; 5];
    let mut _49: &[core::fmt::rt::Argument<'_>];
    let _50: &[core::fmt::rt::Argument<'_>; 4];
    let _51: [core::fmt::rt::Argument<'_>; 4];
    let mut _52: core::fmt::rt::Argument<'_>;
    let _53: &std::ptr::NonNull<[u8]>;
    let mut _54: core::fmt::rt::Argument<'_>;
    let _55: &std::alloc::Layout;
    let mut _56: core::fmt::rt::Argument<'_>;
    let _57: &std::alloc::Layout;
    let mut _58: core::fmt::rt::Argument<'_>;
    let _59: &std::ptr::NonNull<[u8]>;
    let mut _60: std::ptr::NonNull<[u8]>;
    scope 1 {
        debug memory => _20;
        let _38: std::ptr::NonNull<[u8]>;
        scope 2 {
            debug ptr => _38;
        }
    }

    bb0: {
        _5 = const {alloc3: &bool};
        _4 = (*_5);
        switchInt(move _4) -> [0: bb6, otherwise: bb1];
    }

    bb1: {
        _10 = [const "reallocate(", const ", old=", const ", new=", const ")\n"];
        _9 = &_10;
        _8 = _9 as &[&str] (Pointer(Unsize));
        _15 = &_1;
        _14 = core::fmt::rt::Argument::<'_>::new_debug::<*mut u8>(_15) -> bb2;
    }

    bb2: {
        _17 = &_2;
        _16 = core::fmt::rt::Argument::<'_>::new_debug::<Layout>(_17) -> bb3;
    }

    bb3: {
        _19 = &_3;
        _18 = core::fmt::rt::Argument::<'_>::new_debug::<Layout>(_19) -> bb4;
    }

    bb4: {
        _13 = [move _14, move _16, move _18];
        _12 = &_13;
        _11 = _12 as &[core::fmt::rt::Argument<'_>] (Pointer(Unsize));
        _7 = Arguments::<'_>::new_v1(move _8, move _11) -> bb5;
    }

    bb5: {
        _6 = _print(move _7) -> bb6;
    }

    bb6: {
        _23 = &_3;
        _22 = Layout::size(move _23) -> bb7;
    }

    bb7: {
        _25 = &_2;
        _24 = Layout::size(move _25) -> bb8;
    }

    bb8: {
        _21 = Gt(move _22, move _24);
        switchInt(move _21) -> [0: bb11, otherwise: bb9];
    }

    bb9: {
        _26 = &_27;
        _29 = _1;
        _28 = NonNull::<u8>::new_unchecked(move _29) -> bb10;
    }

    bb10: {
        _30 = _2;
        _31 = _3;
        _20 = <std::alloc::Global as Allocator>::grow(move _26, move _28, move _30, move _31) -> bb13;
    }

    bb11: {
        _32 = &_33;
        _35 = _1;
        _34 = NonNull::<u8>::new_unchecked(move _35) -> bb12;
    }

    bb12: {
        _36 = _2;
        _37 = _3;
        _20 = <std::alloc::Global as Allocator>::shrink(move _32, move _34, move _36, move _37) -> bb13;
    }

    bb13: {
        _39 = _20;
        _41 = &_3;
        _40 = [closure@ui/realloc-16687.rs:73:41: 73:44] { new: move _41 };
        _38 = Result::<NonNull<[u8]>, std::alloc::AllocError>::unwrap_or_else::<[closure@ui/realloc-16687.rs:73:41: 73:44]>(move _39, move _40) -> bb14;
    }

    bb14: {
        _43 = const {alloc3: &bool};
        _42 = (*_43);
        switchInt(move _42) -> [0: bb21, otherwise: bb15];
    }

    bb15: {
        _48 = [const "reallocate(", const ", old=", const ", new=", const ") = ", const "\n"];
        _47 = &_48;
        _46 = _47 as &[&str] (Pointer(Unsize));
        _53 = &_38;
        _52 = core::fmt::rt::Argument::<'_>::new_debug::<NonNull<[u8]>>(_53) -> bb16;
    }

    bb16: {
        _55 = &_2;
        _54 = core::fmt::rt::Argument::<'_>::new_debug::<Layout>(_55) -> bb17;
    }

    bb17: {
        _57 = &_3;
        _56 = core::fmt::rt::Argument::<'_>::new_debug::<Layout>(_57) -> bb18;
    }

    bb18: {
        _59 = &_38;
        _58 = core::fmt::rt::Argument::<'_>::new_debug::<NonNull<[u8]>>(_59) -> bb19;
    }

    bb19: {
        _51 = [move _52, move _54, move _56, move _58];
        _50 = &_51;
        _49 = _50 as &[core::fmt::rt::Argument<'_>] (Pointer(Unsize));
        _45 = Arguments::<'_>::new_v1(move _46, move _49) -> bb20;
    }

    bb20: {
        _44 = _print(move _45) -> bb21;
    }

    bb21: {
        _60 = _38;
        _0 = NonNull::<[u8]>::as_mut_ptr(move _60) -> bb22;
    }

    bb22: {
        return;
    }
}

alloc3 (static: PRINT, size: 1, align: 1) {
    00                                              │ .
}

fn reallocate::{closure#0}(_1: [closure@ui/realloc-16687.rs:73:41: 73:44], _2: std::alloc::AllocError) -> NonNull<[u8]> {
    debug new => (*(_1.0: &std::alloc::Layout));
    let mut _0: std::ptr::NonNull<[u8]>;
    let mut _3: !;
    let mut _4: std::alloc::Layout;
    let mut _5: &std::alloc::Layout;

    bb0: {
        _5 = deref_copy (_1.0: &std::alloc::Layout);
        _4 = (*_5);
        _3 = handle_alloc_error(move _4);
    }
}

fn idx_to_size(_1: usize) -> usize {
    debug i => _1;
    let mut _0: usize;
    let mut _2: usize;

    bb0: {
        _2 = Add(_1, const 1_usize);
        _0 = Mul(move _2, const 10_usize);
        return;
    }
}

fn test_1(_1: &mut [*mut u8]) -> () {
    debug ascend => _1;
    let mut _0: ();
    let _2: usize;
    let mut _3: usize;
    let mut _4: usize;
    let mut _5: &usize;
    let mut _7: std::result::Result<std::alloc::Layout, std::alloc::LayoutError>;
    let mut _8: usize;
    let mut _9: usize;
    let mut _10: &usize;
    let mut _11: std::ops::Range<usize>;
    let mut _12: std::ops::Range<usize>;
    let mut _13: usize;
    let mut _14: usize;
    let mut _15: &usize;
    let mut _16: bool;
    let mut _18: std::option::Option<usize>;
    let mut _19: &mut std::ops::Range<usize>;
    let mut _20: isize;
    let mut _25: (*mut u8, *mut u8, usize);
    let mut _26: *mut u8;
    let _27: usize;
    let mut _28: usize;
    let mut _29: bool;
    let mut _30: *mut u8;
    let _31: usize;
    let mut _32: usize;
    let mut _33: usize;
    let mut _34: bool;
    let mut _35: usize;
    let mut _36: bool;
    let mut _37: bool;
    let mut _38: usize;
    let mut _39: !;
    let mut _41: std::result::Result<std::alloc::Layout, std::alloc::LayoutError>;
    let mut _42: usize;
    let mut _43: &usize;
    let mut _44: *mut u8;
    let mut _45: std::alloc::Layout;
    let mut _46: &std::alloc::Layout;
    let mut _47: std::alloc::Layout;
    let mut _48: &std::alloc::Layout;
    let _49: usize;
    let mut _50: usize;
    let mut _51: bool;
    let _52: ();
    let _53: &[*mut u8];
    let mut _54: *mut u8;
    let mut _55: std::alloc::Layout;
    let mut _56: &std::alloc::Layout;
    let mut _57: std::alloc::Layout;
    let mut _58: &std::alloc::Layout;
    let _59: usize;
    let mut _60: usize;
    let mut _61: usize;
    let mut _62: bool;
    let _63: ();
    let _64: &[*mut u8];
    scope 1 {
        debug new_size => _2;
        let _6: std::alloc::Layout;
        scope 2 {
            debug new => _6;
            let mut _17: std::ops::Range<usize>;
            scope 3 {
                debug iter => _17;
                let _21: usize;
                scope 4 {
                    debug i => _21;
                    let _22: *mut u8;
                    let _23: *mut u8;
                    let _24: usize;
                    scope 5 {
                        debug p0 => _22;
                        debug p1 => _23;
                        debug old_size => _24;
                        let _40: std::alloc::Layout;
                        scope 6 {
                            debug old => _40;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _5 = const {alloc1: &usize};
        _4 = (*_5);
        _3 = Sub(move _4, const 1_usize);
        _2 = idx_to_size(move _3) -> bb1;
    }

    bb1: {
        _8 = _2;
        _10 = const {alloc2: &usize};
        _9 = (*_10);
        _7 = Layout::from_size_align(move _8, move _9) -> bb2;
    }

    bb2: {
        _6 = Result::<Layout, LayoutError>::unwrap(move _7) -> bb3;
    }

    bb3: {
        _15 = const {alloc1: &usize};
        _14 = (*_15);
        _16 = Eq(const 2_usize, const 0_usize);
        assert(!move _16, "attempt to divide `{}` by zero", _14) -> bb4;
    }

    bb4: {
        _13 = Div(move _14, const 2_usize);
        _12 = std::ops::Range::<usize> { start: const 0_usize, end: move _13 };
        _11 = <std::ops::Range<usize> as IntoIterator>::into_iter(move _12) -> bb5;
    }

    bb5: {
        _17 = move _11;
        goto -> bb6;
    }

    bb6: {
        _19 = &mut _17;
        _18 = <std::ops::Range<usize> as Iterator>::next(_19) -> bb7;
    }

    bb7: {
        _20 = discriminant(_18);
        switchInt(move _20) -> [0: bb10, 1: bb8, otherwise: bb9];
    }

    bb8: {
        _21 = ((_18 as Some).0: usize);
        _27 = Mul(const 2_usize, _21);
        _28 = Len((*_1));
        _29 = Lt(_27, _28);
        assert(move _29, "index out of bounds: the length is {} but the index is {}", move _28, _27) -> bb11;
    }

    bb9: {
        unreachable;
    }

    bb10: {
        return;
    }

    bb11: {
        _26 = (*_1)[_27];
        _32 = Mul(const 2_usize, _21);
        _31 = Add(move _32, const 1_usize);
        _33 = Len((*_1));
        _34 = Lt(_31, _33);
        assert(move _34, "index out of bounds: the length is {} but the index is {}", move _33, _31) -> bb12;
    }

    bb12: {
        _30 = (*_1)[_31];
        _35 = idx_to_size(_21) -> bb13;
    }

    bb13: {
        _25 = (move _26, move _30, move _35);
        _22 = (_25.0: *mut u8);
        _23 = (_25.1: *mut u8);
        _24 = (_25.2: usize);
        _38 = _2;
        _37 = Lt(_24, move _38);
        _36 = Not(move _37);
        switchInt(move _36) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _39 = core::panicking::panic(const "assertion failed: old_size < new_size");
    }

    bb15: {
        _43 = const {alloc2: &usize};
        _42 = (*_43);
        _41 = Layout::from_size_align(_24, move _42) -> bb16;
    }

    bb16: {
        _40 = Result::<Layout, LayoutError>::unwrap(move _41) -> bb17;
    }

    bb17: {
        _46 = &_40;
        _45 = <Layout as Clone>::clone(move _46) -> bb18;
    }

    bb18: {
        _48 = &_6;
        _47 = <Layout as Clone>::clone(move _48) -> bb19;
    }

    bb19: {
        _44 = reallocate(_22, move _45, move _47) -> bb20;
    }

    bb20: {
        _49 = Mul(const 2_usize, _21);
        _50 = Len((*_1));
        _51 = Lt(_49, _50);
        assert(move _51, "index out of bounds: the length is {} but the index is {}", move _50, _49) -> bb21;
    }

    bb21: {
        (*_1)[_49] = move _44;
        _53 = &(*_1);
        _52 = sanity_check(_53) -> bb22;
    }

    bb22: {
        _56 = &_40;
        _55 = <Layout as Clone>::clone(move _56) -> bb23;
    }

    bb23: {
        _58 = &_6;
        _57 = <Layout as Clone>::clone(move _58) -> bb24;
    }

    bb24: {
        _54 = reallocate(_23, move _55, move _57) -> bb25;
    }

    bb25: {
        _60 = Mul(const 2_usize, _21);
        _59 = Add(move _60, const 1_usize);
        _61 = Len((*_1));
        _62 = Lt(_59, _61);
        assert(move _62, "index out of bounds: the length is {} but the index is {}", move _61, _59) -> bb26;
    }

    bb26: {
        (*_1)[_59] = move _54;
        _64 = &(*_1);
        _63 = sanity_check(_64) -> bb6;
    }
}

alloc2 (static: ALIGN, size: 8, align: 8) {
    01 00 00 00 00 00 00 00                         │ ........
}

alloc1 (static: COUNT, size: 8, align: 8) {
    10 00 00 00 00 00 00 00                         │ ........
}

fn test_2(_1: &mut [*mut u8]) -> () {
    debug ascend => _1;
    let mut _0: ();
    let _2: usize;
    let mut _3: usize;
    let mut _4: usize;
    let mut _5: &usize;
    let mut _7: std::result::Result<std::alloc::Layout, std::alloc::LayoutError>;
    let mut _8: usize;
    let mut _9: usize;
    let mut _10: &usize;
    let mut _11: std::ops::Range<usize>;
    let mut _12: std::ops::Range<usize>;
    let mut _13: usize;
    let mut _14: usize;
    let mut _15: &usize;
    let mut _16: bool;
    let mut _18: std::option::Option<usize>;
    let mut _19: &mut std::ops::Range<usize>;
    let mut _20: isize;
    let mut _25: (*mut u8, *mut u8, usize);
    let mut _26: *mut u8;
    let _27: usize;
    let mut _28: usize;
    let mut _29: bool;
    let mut _30: *mut u8;
    let _31: usize;
    let mut _32: usize;
    let mut _33: usize;
    let mut _34: bool;
    let mut _35: usize;
    let mut _36: bool;
    let mut _37: bool;
    let mut _38: usize;
    let mut _39: !;
    let mut _41: std::result::Result<std::alloc::Layout, std::alloc::LayoutError>;
    let mut _42: usize;
    let mut _43: &usize;
    let mut _44: *mut u8;
    let mut _45: std::alloc::Layout;
    let mut _46: &std::alloc::Layout;
    let mut _47: std::alloc::Layout;
    let mut _48: &std::alloc::Layout;
    let _49: usize;
    let mut _50: usize;
    let mut _51: bool;
    let _52: ();
    let _53: &[*mut u8];
    let mut _54: *mut u8;
    let mut _55: std::alloc::Layout;
    let mut _56: &std::alloc::Layout;
    let mut _57: std::alloc::Layout;
    let mut _58: &std::alloc::Layout;
    let _59: usize;
    let mut _60: usize;
    let mut _61: usize;
    let mut _62: bool;
    let _63: ();
    let _64: &[*mut u8];
    scope 1 {
        debug old_size => _2;
        let _6: std::alloc::Layout;
        scope 2 {
            debug old => _6;
            let mut _17: std::ops::Range<usize>;
            scope 3 {
                debug iter => _17;
                let _21: usize;
                scope 4 {
                    debug i => _21;
                    let _22: *mut u8;
                    let _23: *mut u8;
                    let _24: usize;
                    scope 5 {
                        debug p0 => _22;
                        debug p1 => _23;
                        debug new_size => _24;
                        let _40: std::alloc::Layout;
                        scope 6 {
                            debug new => _40;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _5 = const {alloc1: &usize};
        _4 = (*_5);
        _3 = Sub(move _4, const 1_usize);
        _2 = idx_to_size(move _3) -> bb1;
    }

    bb1: {
        _8 = _2;
        _10 = const {alloc2: &usize};
        _9 = (*_10);
        _7 = Layout::from_size_align(move _8, move _9) -> bb2;
    }

    bb2: {
        _6 = Result::<Layout, LayoutError>::unwrap(move _7) -> bb3;
    }

    bb3: {
        _15 = const {alloc1: &usize};
        _14 = (*_15);
        _16 = Eq(const 2_usize, const 0_usize);
        assert(!move _16, "attempt to divide `{}` by zero", _14) -> bb4;
    }

    bb4: {
        _13 = Div(move _14, const 2_usize);
        _12 = std::ops::Range::<usize> { start: const 0_usize, end: move _13 };
        _11 = <std::ops::Range<usize> as IntoIterator>::into_iter(move _12) -> bb5;
    }

    bb5: {
        _17 = move _11;
        goto -> bb6;
    }

    bb6: {
        _19 = &mut _17;
        _18 = <std::ops::Range<usize> as Iterator>::next(_19) -> bb7;
    }

    bb7: {
        _20 = discriminant(_18);
        switchInt(move _20) -> [0: bb10, 1: bb8, otherwise: bb9];
    }

    bb8: {
        _21 = ((_18 as Some).0: usize);
        _27 = Mul(const 2_usize, _21);
        _28 = Len((*_1));
        _29 = Lt(_27, _28);
        assert(move _29, "index out of bounds: the length is {} but the index is {}", move _28, _27) -> bb11;
    }

    bb9: {
        unreachable;
    }

    bb10: {
        return;
    }

    bb11: {
        _26 = (*_1)[_27];
        _32 = Mul(const 2_usize, _21);
        _31 = Add(move _32, const 1_usize);
        _33 = Len((*_1));
        _34 = Lt(_31, _33);
        assert(move _34, "index out of bounds: the length is {} but the index is {}", move _33, _31) -> bb12;
    }

    bb12: {
        _30 = (*_1)[_31];
        _35 = idx_to_size(_21) -> bb13;
    }

    bb13: {
        _25 = (move _26, move _30, move _35);
        _22 = (_25.0: *mut u8);
        _23 = (_25.1: *mut u8);
        _24 = (_25.2: usize);
        _38 = _2;
        _37 = Lt(_24, move _38);
        _36 = Not(move _37);
        switchInt(move _36) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _39 = core::panicking::panic(const "assertion failed: new_size < old_size");
    }

    bb15: {
        _43 = const {alloc2: &usize};
        _42 = (*_43);
        _41 = Layout::from_size_align(_24, move _42) -> bb16;
    }

    bb16: {
        _40 = Result::<Layout, LayoutError>::unwrap(move _41) -> bb17;
    }

    bb17: {
        _46 = &_6;
        _45 = <Layout as Clone>::clone(move _46) -> bb18;
    }

    bb18: {
        _48 = &_40;
        _47 = <Layout as Clone>::clone(move _48) -> bb19;
    }

    bb19: {
        _44 = reallocate(_22, move _45, move _47) -> bb20;
    }

    bb20: {
        _49 = Mul(const 2_usize, _21);
        _50 = Len((*_1));
        _51 = Lt(_49, _50);
        assert(move _51, "index out of bounds: the length is {} but the index is {}", move _50, _49) -> bb21;
    }

    bb21: {
        (*_1)[_49] = move _44;
        _53 = &(*_1);
        _52 = sanity_check(_53) -> bb22;
    }

    bb22: {
        _56 = &_6;
        _55 = <Layout as Clone>::clone(move _56) -> bb23;
    }

    bb23: {
        _58 = &_40;
        _57 = <Layout as Clone>::clone(move _58) -> bb24;
    }

    bb24: {
        _54 = reallocate(_23, move _55, move _57) -> bb25;
    }

    bb25: {
        _60 = Mul(const 2_usize, _21);
        _59 = Add(move _60, const 1_usize);
        _61 = Len((*_1));
        _62 = Lt(_59, _61);
        assert(move _62, "index out of bounds: the length is {} but the index is {}", move _61, _59) -> bb26;
    }

    bb26: {
        (*_1)[_59] = move _54;
        _64 = &(*_1);
        _63 = sanity_check(_64) -> bb6;
    }
}

alloc2 (static: ALIGN, size: 8, align: 8) {
    01 00 00 00 00 00 00 00                         │ ........
}

alloc1 (static: COUNT, size: 8, align: 8) {
    10 00 00 00 00 00 00 00                         │ ........
}

fn test_3(_1: &mut [*mut u8]) -> () {
    debug ascend => _1;
    let mut _0: ();
    let _2: usize;
    let mut _3: usize;
    let mut _4: usize;
    let mut _5: &usize;
    let mut _7: std::result::Result<std::alloc::Layout, std::alloc::LayoutError>;
    let mut _8: usize;
    let mut _9: usize;
    let mut _10: &usize;
    let mut _11: std::iter::Rev<std::ops::Range<usize>>;
    let mut _12: std::iter::Rev<std::ops::Range<usize>>;
    let mut _13: std::ops::Range<usize>;
    let mut _14: usize;
    let mut _15: usize;
    let mut _16: &usize;
    let mut _17: bool;
    let mut _19: std::option::Option<usize>;
    let mut _20: &mut std::iter::Rev<std::ops::Range<usize>>;
    let mut _21: isize;
    let mut _26: (*mut u8, *mut u8, usize);
    let mut _27: *mut u8;
    let _28: usize;
    let mut _29: usize;
    let mut _30: bool;
    let mut _31: *mut u8;
    let _32: usize;
    let mut _33: usize;
    let mut _34: usize;
    let mut _35: bool;
    let mut _36: usize;
    let mut _37: bool;
    let mut _38: bool;
    let mut _39: usize;
    let mut _40: !;
    let mut _42: std::result::Result<std::alloc::Layout, std::alloc::LayoutError>;
    let mut _43: usize;
    let mut _44: &usize;
    let mut _45: *mut u8;
    let mut _46: std::alloc::Layout;
    let mut _47: &std::alloc::Layout;
    let mut _48: std::alloc::Layout;
    let mut _49: &std::alloc::Layout;
    let _50: usize;
    let mut _51: usize;
    let mut _52: usize;
    let mut _53: bool;
    let _54: ();
    let _55: &[*mut u8];
    let mut _56: *mut u8;
    let mut _57: std::alloc::Layout;
    let mut _58: &std::alloc::Layout;
    let mut _59: std::alloc::Layout;
    let mut _60: &std::alloc::Layout;
    let _61: usize;
    let mut _62: usize;
    let mut _63: bool;
    let _64: ();
    let _65: &[*mut u8];
    scope 1 {
        debug new_size => _2;
        let _6: std::alloc::Layout;
        scope 2 {
            debug new => _6;
            let mut _18: std::iter::Rev<std::ops::Range<usize>>;
            scope 3 {
                debug iter => _18;
                let _22: usize;
                scope 4 {
                    debug i => _22;
                    let _23: *mut u8;
                    let _24: *mut u8;
                    let _25: usize;
                    scope 5 {
                        debug p0 => _23;
                        debug p1 => _24;
                        debug old_size => _25;
                        let _41: std::alloc::Layout;
                        scope 6 {
                            debug old => _41;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _5 = const {alloc1: &usize};
        _4 = (*_5);
        _3 = Sub(move _4, const 1_usize);
        _2 = idx_to_size(move _3) -> bb1;
    }

    bb1: {
        _8 = _2;
        _10 = const {alloc2: &usize};
        _9 = (*_10);
        _7 = Layout::from_size_align(move _8, move _9) -> bb2;
    }

    bb2: {
        _6 = Result::<Layout, LayoutError>::unwrap(move _7) -> bb3;
    }

    bb3: {
        _16 = const {alloc1: &usize};
        _15 = (*_16);
        _17 = Eq(const 2_usize, const 0_usize);
        assert(!move _17, "attempt to divide `{}` by zero", _15) -> bb4;
    }

    bb4: {
        _14 = Div(move _15, const 2_usize);
        _13 = std::ops::Range::<usize> { start: const 0_usize, end: move _14 };
        _12 = <std::ops::Range<usize> as Iterator>::rev(move _13) -> bb5;
    }

    bb5: {
        _11 = <Rev<std::ops::Range<usize>> as IntoIterator>::into_iter(move _12) -> bb6;
    }

    bb6: {
        _18 = move _11;
        goto -> bb7;
    }

    bb7: {
        _20 = &mut _18;
        _19 = <Rev<std::ops::Range<usize>> as Iterator>::next(_20) -> bb8;
    }

    bb8: {
        _21 = discriminant(_19);
        switchInt(move _21) -> [0: bb11, 1: bb9, otherwise: bb10];
    }

    bb9: {
        _22 = ((_19 as Some).0: usize);
        _28 = Mul(const 2_usize, _22);
        _29 = Len((*_1));
        _30 = Lt(_28, _29);
        assert(move _30, "index out of bounds: the length is {} but the index is {}", move _29, _28) -> bb12;
    }

    bb10: {
        unreachable;
    }

    bb11: {
        return;
    }

    bb12: {
        _27 = (*_1)[_28];
        _33 = Mul(const 2_usize, _22);
        _32 = Add(move _33, const 1_usize);
        _34 = Len((*_1));
        _35 = Lt(_32, _34);
        assert(move _35, "index out of bounds: the length is {} but the index is {}", move _34, _32) -> bb13;
    }

    bb13: {
        _31 = (*_1)[_32];
        _36 = idx_to_size(_22) -> bb14;
    }

    bb14: {
        _26 = (move _27, move _31, move _36);
        _23 = (_26.0: *mut u8);
        _24 = (_26.1: *mut u8);
        _25 = (_26.2: usize);
        _39 = _2;
        _38 = Lt(_25, move _39);
        _37 = Not(move _38);
        switchInt(move _37) -> [0: bb16, otherwise: bb15];
    }

    bb15: {
        _40 = core::panicking::panic(const "assertion failed: old_size < new_size");
    }

    bb16: {
        _44 = const {alloc2: &usize};
        _43 = (*_44);
        _42 = Layout::from_size_align(_25, move _43) -> bb17;
    }

    bb17: {
        _41 = Result::<Layout, LayoutError>::unwrap(move _42) -> bb18;
    }

    bb18: {
        _47 = &_41;
        _46 = <Layout as Clone>::clone(move _47) -> bb19;
    }

    bb19: {
        _49 = &_6;
        _48 = <Layout as Clone>::clone(move _49) -> bb20;
    }

    bb20: {
        _45 = reallocate(_24, move _46, move _48) -> bb21;
    }

    bb21: {
        _51 = Mul(const 2_usize, _22);
        _50 = Add(move _51, const 1_usize);
        _52 = Len((*_1));
        _53 = Lt(_50, _52);
        assert(move _53, "index out of bounds: the length is {} but the index is {}", move _52, _50) -> bb22;
    }

    bb22: {
        (*_1)[_50] = move _45;
        _55 = &(*_1);
        _54 = sanity_check(_55) -> bb23;
    }

    bb23: {
        _58 = &_41;
        _57 = <Layout as Clone>::clone(move _58) -> bb24;
    }

    bb24: {
        _60 = &_6;
        _59 = <Layout as Clone>::clone(move _60) -> bb25;
    }

    bb25: {
        _56 = reallocate(_23, move _57, move _59) -> bb26;
    }

    bb26: {
        _61 = Mul(const 2_usize, _22);
        _62 = Len((*_1));
        _63 = Lt(_61, _62);
        assert(move _63, "index out of bounds: the length is {} but the index is {}", move _62, _61) -> bb27;
    }

    bb27: {
        (*_1)[_61] = move _56;
        _65 = &(*_1);
        _64 = sanity_check(_65) -> bb7;
    }
}

alloc2 (static: ALIGN, size: 8, align: 8) {
    01 00 00 00 00 00 00 00                         │ ........
}

alloc1 (static: COUNT, size: 8, align: 8) {
    10 00 00 00 00 00 00 00                         │ ........
}

fn test_4(_1: &mut [*mut u8]) -> () {
    debug ascend => _1;
    let mut _0: ();
    let _2: usize;
    let mut _3: usize;
    let mut _4: usize;
    let mut _5: &usize;
    let mut _7: std::result::Result<std::alloc::Layout, std::alloc::LayoutError>;
    let mut _8: usize;
    let mut _9: usize;
    let mut _10: &usize;
    let mut _11: std::iter::Rev<std::ops::Range<usize>>;
    let mut _12: std::iter::Rev<std::ops::Range<usize>>;
    let mut _13: std::ops::Range<usize>;
    let mut _14: usize;
    let mut _15: usize;
    let mut _16: &usize;
    let mut _17: bool;
    let mut _19: std::option::Option<usize>;
    let mut _20: &mut std::iter::Rev<std::ops::Range<usize>>;
    let mut _21: isize;
    let mut _26: (*mut u8, *mut u8, usize);
    let mut _27: *mut u8;
    let _28: usize;
    let mut _29: usize;
    let mut _30: bool;
    let mut _31: *mut u8;
    let _32: usize;
    let mut _33: usize;
    let mut _34: usize;
    let mut _35: bool;
    let mut _36: usize;
    let mut _37: bool;
    let mut _38: bool;
    let mut _39: usize;
    let mut _40: !;
    let mut _42: std::result::Result<std::alloc::Layout, std::alloc::LayoutError>;
    let mut _43: usize;
    let mut _44: &usize;
    let mut _45: *mut u8;
    let mut _46: std::alloc::Layout;
    let mut _47: &std::alloc::Layout;
    let mut _48: std::alloc::Layout;
    let mut _49: &std::alloc::Layout;
    let _50: usize;
    let mut _51: usize;
    let mut _52: usize;
    let mut _53: bool;
    let _54: ();
    let _55: &[*mut u8];
    let mut _56: *mut u8;
    let mut _57: std::alloc::Layout;
    let mut _58: &std::alloc::Layout;
    let mut _59: std::alloc::Layout;
    let mut _60: &std::alloc::Layout;
    let _61: usize;
    let mut _62: usize;
    let mut _63: bool;
    let _64: ();
    let _65: &[*mut u8];
    scope 1 {
        debug old_size => _2;
        let _6: std::alloc::Layout;
        scope 2 {
            debug old => _6;
            let mut _18: std::iter::Rev<std::ops::Range<usize>>;
            scope 3 {
                debug iter => _18;
                let _22: usize;
                scope 4 {
                    debug i => _22;
                    let _23: *mut u8;
                    let _24: *mut u8;
                    let _25: usize;
                    scope 5 {
                        debug p0 => _23;
                        debug p1 => _24;
                        debug new_size => _25;
                        let _41: std::alloc::Layout;
                        scope 6 {
                            debug new => _41;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _5 = const {alloc1: &usize};
        _4 = (*_5);
        _3 = Sub(move _4, const 1_usize);
        _2 = idx_to_size(move _3) -> bb1;
    }

    bb1: {
        _8 = _2;
        _10 = const {alloc2: &usize};
        _9 = (*_10);
        _7 = Layout::from_size_align(move _8, move _9) -> bb2;
    }

    bb2: {
        _6 = Result::<Layout, LayoutError>::unwrap(move _7) -> bb3;
    }

    bb3: {
        _16 = const {alloc1: &usize};
        _15 = (*_16);
        _17 = Eq(const 2_usize, const 0_usize);
        assert(!move _17, "attempt to divide `{}` by zero", _15) -> bb4;
    }

    bb4: {
        _14 = Div(move _15, const 2_usize);
        _13 = std::ops::Range::<usize> { start: const 0_usize, end: move _14 };
        _12 = <std::ops::Range<usize> as Iterator>::rev(move _13) -> bb5;
    }

    bb5: {
        _11 = <Rev<std::ops::Range<usize>> as IntoIterator>::into_iter(move _12) -> bb6;
    }

    bb6: {
        _18 = move _11;
        goto -> bb7;
    }

    bb7: {
        _20 = &mut _18;
        _19 = <Rev<std::ops::Range<usize>> as Iterator>::next(_20) -> bb8;
    }

    bb8: {
        _21 = discriminant(_19);
        switchInt(move _21) -> [0: bb11, 1: bb9, otherwise: bb10];
    }

    bb9: {
        _22 = ((_19 as Some).0: usize);
        _28 = Mul(const 2_usize, _22);
        _29 = Len((*_1));
        _30 = Lt(_28, _29);
        assert(move _30, "index out of bounds: the length is {} but the index is {}", move _29, _28) -> bb12;
    }

    bb10: {
        unreachable;
    }

    bb11: {
        return;
    }

    bb12: {
        _27 = (*_1)[_28];
        _33 = Mul(const 2_usize, _22);
        _32 = Add(move _33, const 1_usize);
        _34 = Len((*_1));
        _35 = Lt(_32, _34);
        assert(move _35, "index out of bounds: the length is {} but the index is {}", move _34, _32) -> bb13;
    }

    bb13: {
        _31 = (*_1)[_32];
        _36 = idx_to_size(_22) -> bb14;
    }

    bb14: {
        _26 = (move _27, move _31, move _36);
        _23 = (_26.0: *mut u8);
        _24 = (_26.1: *mut u8);
        _25 = (_26.2: usize);
        _39 = _2;
        _38 = Lt(_25, move _39);
        _37 = Not(move _38);
        switchInt(move _37) -> [0: bb16, otherwise: bb15];
    }

    bb15: {
        _40 = core::panicking::panic(const "assertion failed: new_size < old_size");
    }

    bb16: {
        _44 = const {alloc2: &usize};
        _43 = (*_44);
        _42 = Layout::from_size_align(_25, move _43) -> bb17;
    }

    bb17: {
        _41 = Result::<Layout, LayoutError>::unwrap(move _42) -> bb18;
    }

    bb18: {
        _47 = &_6;
        _46 = <Layout as Clone>::clone(move _47) -> bb19;
    }

    bb19: {
        _49 = &_41;
        _48 = <Layout as Clone>::clone(move _49) -> bb20;
    }

    bb20: {
        _45 = reallocate(_24, move _46, move _48) -> bb21;
    }

    bb21: {
        _51 = Mul(const 2_usize, _22);
        _50 = Add(move _51, const 1_usize);
        _52 = Len((*_1));
        _53 = Lt(_50, _52);
        assert(move _53, "index out of bounds: the length is {} but the index is {}", move _52, _50) -> bb22;
    }

    bb22: {
        (*_1)[_50] = move _45;
        _55 = &(*_1);
        _54 = sanity_check(_55) -> bb23;
    }

    bb23: {
        _58 = &_6;
        _57 = <Layout as Clone>::clone(move _58) -> bb24;
    }

    bb24: {
        _60 = &_41;
        _59 = <Layout as Clone>::clone(move _60) -> bb25;
    }

    bb25: {
        _56 = reallocate(_23, move _57, move _59) -> bb26;
    }

    bb26: {
        _61 = Mul(const 2_usize, _22);
        _62 = Len((*_1));
        _63 = Lt(_61, _62);
        assert(move _63, "index out of bounds: the length is {} but the index is {}", move _62, _61) -> bb27;
    }

    bb27: {
        (*_1)[_61] = move _56;
        _65 = &(*_1);
        _64 = sanity_check(_65) -> bb7;
    }
}

alloc2 (static: ALIGN, size: 8, align: 8) {
    01 00 00 00 00 00 00 00                         │ ........
}

alloc1 (static: COUNT, size: 8, align: 8) {
    10 00 00 00 00 00 00 00                         │ ........
}
