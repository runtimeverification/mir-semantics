// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn Foo::foo(_1: &Self) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let _1: *const [i32];
    let mut _2: *const [i32; 3];
    let _3: &[i32; 3];
    let _4: [i32; 3];
    let mut _6: (&[i32; 2], &[i32; 2]);
    let mut _7: &[i32; 2];
    let mut _8: &[i32; 2];
    let _9: [i32; 2];
    let mut _12: bool;
    let mut _13: bool;
    let _15: !;
    let mut _16: std::option::Option<std::fmt::Arguments<'_>>;
    let _18: &[i32; 3];
    let _19: [i32; 3];
    let mut _21: (&usize, &usize);
    let mut _22: &usize;
    let _23: usize;
    let mut _24: &usize;
    let _25: usize;
    let mut _26: *const ();
    let mut _29: bool;
    let mut _30: bool;
    let mut _31: usize;
    let mut _32: usize;
    let _34: !;
    let mut _35: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _37: *mut Bar;
    let mut _38: &mut Bar;
    let mut _39: Bar;
    let mut _41: *mut ();
    let mut _43: *const ();
    let mut _45: *mut ();
    let mut _46: (*mut (), std::ptr::DynMetadata<dyn Foo>);
    let mut _47: (&usize, &usize);
    let mut _48: &usize;
    let mut _49: &usize;
    let mut _52: bool;
    let mut _53: bool;
    let mut _54: usize;
    let mut _55: usize;
    let _57: !;
    let mut _58: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _59: (&usize, &usize);
    let mut _60: &usize;
    let mut _61: &usize;
    let mut _64: bool;
    let mut _65: bool;
    let mut _66: usize;
    let mut _67: usize;
    let _69: !;
    let mut _70: std::option::Option<std::fmt::Arguments<'_>>;
    scope 1 {
        debug a => _1;
        let _5: *const [i32; 2];
        scope 2 {
            debug b => _5;
            let _17: *const [i32; 3];
            scope 3 {
                let _10: &[i32; 2];
                let _11: &[i32; 2];
                let mut _71: *const ();
                let mut _72: usize;
                let mut _73: usize;
                let mut _74: usize;
                let mut _75: usize;
                let mut _76: bool;
                scope 4 {
                    debug left_val => _10;
                    debug right_val => _11;
                    let _14: core::panicking::AssertKind;
                    scope 5 {
                        debug kind => _14;
                    }
                }
            }
            scope 6 {
                debug a => _17;
                let _20: *const [i32];
                scope 7 {
                    debug b => _20;
                    let _27: &usize;
                    let _28: &usize;
                    let _36: *mut dyn Foo;
                    scope 8 {
                        debug left_val => _27;
                        debug right_val => _28;
                        let _33: core::panicking::AssertKind;
                        scope 9 {
                            debug kind => _33;
                        }
                    }
                    scope 10 {
                        debug a => _36;
                        let _40: usize;
                        scope 11 {
                            debug b => _40;
                            let _42: usize;
                            scope 12 {
                                debug c => _42;
                                let _44: usize;
                                scope 13 {
                                    debug d => _44;
                                    let _50: &usize;
                                    let _51: &usize;
                                    let _62: &usize;
                                    let _63: &usize;
                                    scope 14 {
                                        debug left_val => _50;
                                        debug right_val => _51;
                                        let _56: core::panicking::AssertKind;
                                        scope 15 {
                                            debug kind => _56;
                                        }
                                    }
                                    scope 16 {
                                        debug left_val => _62;
                                        debug right_val => _63;
                                        let _68: core::panicking::AssertKind;
                                        scope 17 {
                                            debug kind => _68;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _4 = [const 1_i32, const 2_i32, const 3_i32];
        _3 = &_4;
        _2 = &raw const (*_3);
        _1 = move _2 as *const [i32] (Pointer(Unsize));
        _5 = _1 as *const [i32; 2] (PtrToPtr);
        _71 = _5 as *const () (PtrToPtr);
        _72 = _71 as usize (Transmute);
        _73 = AlignOf(i32);
        _74 = Sub(_73, const 1_usize);
        _75 = BitAnd(_72, _74);
        _76 = Eq(_75, const 0_usize);
        assert(_76, "misaligned pointer dereference: address must be a multiple of {} but is {}", _73, _72) -> [success: bb11, unwind unreachable];
    }

    bb1: {
        _12 = Not(move _13);
        switchInt(move _12) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _14 = core::panicking::AssertKind::Eq;
        _16 = Option::<Arguments<'_>>::None;
        _15 = core::panicking::assert_failed::<[i32; 2], [i32; 2]>(move _14, _10, _11, move _16);
    }

    bb3: {
        _19 = [const 1_i32, const 2_i32, const 3_i32];
        _18 = &_19;
        _17 = &raw const (*_18);
        _20 = _17 as *const [i32] (Pointer(Unsize));
        _23 = _17 as usize (PointerExposeAddress);
        _22 = &_23;
        _26 = _20 as *const () (PtrToPtr);
        _25 = move _26 as usize (PointerExposeAddress);
        _24 = &_25;
        _21 = (move _22, move _24);
        _27 = (_21.0: &usize);
        _28 = (_21.1: &usize);
        _31 = (*_27);
        _32 = (*_28);
        _30 = Eq(move _31, move _32);
        _29 = Not(move _30);
        switchInt(move _29) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _33 = core::panicking::AssertKind::Eq;
        _35 = Option::<Arguments<'_>>::None;
        _34 = core::panicking::assert_failed::<usize, usize>(move _33, _27, _28, move _35);
    }

    bb5: {
        _38 = &mut _39;
        _37 = &raw mut (*_38);
        _36 = move _37 as *mut dyn Foo (Pointer(Unsize));
        _41 = _36 as *mut () (PtrToPtr);
        _40 = move _41 as usize (PointerExposeAddress);
        _43 = _36 as *const () (PtrToPtr);
        _42 = move _43 as usize (PointerExposeAddress);
        _46 = ptr::mut_ptr::<impl *mut dyn Foo>::to_raw_parts(_36) -> bb6;
    }

    bb6: {
        _45 = (_46.0: *mut ());
        _44 = move _45 as usize (PointerExposeAddress);
        _48 = &_40;
        _49 = &_44;
        _47 = (move _48, move _49);
        _50 = (_47.0: &usize);
        _51 = (_47.1: &usize);
        _54 = (*_50);
        _55 = (*_51);
        _53 = Eq(move _54, move _55);
        _52 = Not(move _53);
        switchInt(move _52) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _56 = core::panicking::AssertKind::Eq;
        _58 = Option::<Arguments<'_>>::None;
        _57 = core::panicking::assert_failed::<usize, usize>(move _56, _50, _51, move _58);
    }

    bb8: {
        _60 = &_42;
        _61 = &_44;
        _59 = (move _60, move _61);
        _62 = (_59.0: &usize);
        _63 = (_59.1: &usize);
        _66 = (*_62);
        _67 = (*_63);
        _65 = Eq(move _66, move _67);
        _64 = Not(move _65);
        switchInt(move _64) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _68 = core::panicking::AssertKind::Eq;
        _70 = Option::<Arguments<'_>>::None;
        _69 = core::panicking::assert_failed::<usize, usize>(move _68, _62, _63, move _70);
    }

    bb10: {
        return;
    }

    bb11: {
        _7 = &(*_5);
        _9 = [const 1_i32, const 2_i32];
        _8 = &_9;
        _6 = (move _7, move _8);
        _10 = (_6.0: &[i32; 2]);
        _11 = (_6.1: &[i32; 2]);
        _13 = <[i32; 2] as PartialEq>::eq(_10, _11) -> bb1;
    }
}

main::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 2_usize;
        return;
    }
}

main::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 3_usize;
        return;
    }
}
