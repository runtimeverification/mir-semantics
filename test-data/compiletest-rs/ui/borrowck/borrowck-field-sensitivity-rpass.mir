// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn move_after_copy() -> () {
    let mut _0: ();
    let _1: A;
    let mut _2: std::boxed::Box<isize>;
    let _3: ();
    let mut _4: isize;
    let _5: ();
    let mut _6: std::boxed::Box<isize>;
    let mut _7: bool;
    scope 1 {
        debug x => _1;
    }

    bb0: {
        _7 = const false;
        _2 = Box::<isize>::new(const 2_isize) -> bb1;
    }

    bb1: {
        _7 = const true;
        _1 = A { a: const 1_isize, b: move _2 };
        _4 = (_1.0: isize);
        _3 = std::mem::drop::<isize>(move _4) -> [return: bb2, unwind: bb6];
    }

    bb2: {
        _7 = const false;
        _6 = move (_1.1: std::boxed::Box<isize>);
        _5 = std::mem::drop::<Box<isize>>(move _6) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        _7 = const false;
        return;
    }

    bb4 (cleanup): {
        resume;
    }

    bb5 (cleanup): {
        drop((_1.1: std::boxed::Box<isize>)) -> [return: bb4, unwind terminate];
    }

    bb6 (cleanup): {
        switchInt(_7) -> [0: bb4, otherwise: bb5];
    }
}

fn move_after_fu_copy() -> () {
    let mut _0: ();
    let _1: A;
    let mut _2: std::boxed::Box<isize>;
    let mut _4: std::boxed::Box<isize>;
    let _5: ();
    let mut _6: std::boxed::Box<isize>;
    let mut _7: bool;
    scope 1 {
        debug x => _1;
        let _3: A;
        scope 2 {
            debug _y => _3;
        }
    }

    bb0: {
        _7 = const false;
        _2 = Box::<isize>::new(const 2_isize) -> bb1;
    }

    bb1: {
        _7 = const true;
        _1 = A { a: const 1_isize, b: move _2 };
        _4 = Box::<isize>::new(const 3_isize) -> [return: bb2, unwind: bb8];
    }

    bb2: {
        _3 = A { a: (_1.0: isize), b: move _4 };
        _7 = const false;
        _6 = move (_1.1: std::boxed::Box<isize>);
        _5 = std::mem::drop::<Box<isize>>(move _6) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        drop(_3) -> [return: bb4, unwind: bb8];
    }

    bb4: {
        _7 = const false;
        return;
    }

    bb5 (cleanup): {
        drop(_3) -> [return: bb8, unwind terminate];
    }

    bb6 (cleanup): {
        resume;
    }

    bb7 (cleanup): {
        drop((_1.1: std::boxed::Box<isize>)) -> [return: bb6, unwind terminate];
    }

    bb8 (cleanup): {
        switchInt(_7) -> [0: bb6, otherwise: bb7];
    }
}

fn fu_move_after_copy() -> () {
    let mut _0: ();
    let _1: A;
    let mut _2: std::boxed::Box<isize>;
    let _3: ();
    let mut _4: isize;
    let mut _6: bool;
    scope 1 {
        debug x => _1;
        let _5: A;
        scope 2 {
            debug _y => _5;
        }
    }

    bb0: {
        _6 = const false;
        _2 = Box::<isize>::new(const 2_isize) -> bb1;
    }

    bb1: {
        _6 = const true;
        _1 = A { a: const 1_isize, b: move _2 };
        _4 = (_1.0: isize);
        _3 = std::mem::drop::<isize>(move _4) -> [return: bb2, unwind: bb6];
    }

    bb2: {
        _6 = const false;
        _5 = A { a: const 3_isize, b: move (_1.1: std::boxed::Box<isize>) };
        drop(_5) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        _6 = const false;
        return;
    }

    bb4 (cleanup): {
        resume;
    }

    bb5 (cleanup): {
        drop((_1.1: std::boxed::Box<isize>)) -> [return: bb4, unwind terminate];
    }

    bb6 (cleanup): {
        switchInt(_6) -> [0: bb4, otherwise: bb5];
    }
}

fn fu_move_after_fu_copy() -> () {
    let mut _0: ();
    let _1: A;
    let mut _2: std::boxed::Box<isize>;
    let mut _4: std::boxed::Box<isize>;
    let mut _6: bool;
    scope 1 {
        debug x => _1;
        let _3: A;
        scope 2 {
            debug _y => _3;
            let _5: A;
            scope 3 {
                debug _z => _5;
            }
        }
    }

    bb0: {
        _6 = const false;
        _2 = Box::<isize>::new(const 2_isize) -> bb1;
    }

    bb1: {
        _6 = const true;
        _1 = A { a: const 1_isize, b: move _2 };
        _4 = Box::<isize>::new(const 3_isize) -> [return: bb2, unwind: bb8];
    }

    bb2: {
        _3 = A { a: (_1.0: isize), b: move _4 };
        _6 = const false;
        _5 = A { a: const 4_isize, b: move (_1.1: std::boxed::Box<isize>) };
        drop(_5) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        drop(_3) -> [return: bb4, unwind: bb8];
    }

    bb4: {
        _6 = const false;
        return;
    }

    bb5 (cleanup): {
        drop(_3) -> [return: bb8, unwind terminate];
    }

    bb6 (cleanup): {
        resume;
    }

    bb7 (cleanup): {
        drop((_1.1: std::boxed::Box<isize>)) -> [return: bb6, unwind terminate];
    }

    bb8 (cleanup): {
        switchInt(_6) -> [0: bb6, otherwise: bb7];
    }
}

fn copy_after_move() -> () {
    let mut _0: ();
    let _1: A;
    let mut _2: std::boxed::Box<isize>;
    let _3: ();
    let mut _4: std::boxed::Box<isize>;
    let _5: ();
    let mut _6: isize;
    scope 1 {
        debug x => _1;
    }

    bb0: {
        _2 = Box::<isize>::new(const 2_isize) -> bb1;
    }

    bb1: {
        _1 = A { a: const 1_isize, b: move _2 };
        _4 = move (_1.1: std::boxed::Box<isize>);
        _3 = std::mem::drop::<Box<isize>>(move _4) -> bb2;
    }

    bb2: {
        _6 = (_1.0: isize);
        _5 = std::mem::drop::<isize>(move _6) -> bb3;
    }

    bb3: {
        return;
    }
}

fn copy_after_fu_move() -> () {
    let mut _0: ();
    let _1: A;
    let mut _2: std::boxed::Box<isize>;
    let _4: ();
    let mut _5: isize;
    scope 1 {
        debug x => _1;
        let _3: A;
        scope 2 {
            debug y => _3;
        }
    }

    bb0: {
        _2 = Box::<isize>::new(const 2_isize) -> bb1;
    }

    bb1: {
        _1 = A { a: const 1_isize, b: move _2 };
        _3 = A { a: const 3_isize, b: move (_1.1: std::boxed::Box<isize>) };
        _5 = (_1.0: isize);
        _4 = std::mem::drop::<isize>(move _5) -> [return: bb2, unwind: bb4];
    }

    bb2: {
        drop(_3) -> bb3;
    }

    bb3: {
        return;
    }

    bb4 (cleanup): {
        drop(_3) -> [return: bb5, unwind terminate];
    }

    bb5 (cleanup): {
        resume;
    }
}

fn fu_copy_after_move() -> () {
    let mut _0: ();
    let _1: A;
    let mut _2: std::boxed::Box<isize>;
    let _3: ();
    let mut _4: std::boxed::Box<isize>;
    let mut _6: std::boxed::Box<isize>;
    scope 1 {
        debug x => _1;
        let _5: A;
        scope 2 {
            debug _y => _5;
        }
    }

    bb0: {
        _2 = Box::<isize>::new(const 2_isize) -> bb1;
    }

    bb1: {
        _1 = A { a: const 1_isize, b: move _2 };
        _4 = move (_1.1: std::boxed::Box<isize>);
        _3 = std::mem::drop::<Box<isize>>(move _4) -> bb2;
    }

    bb2: {
        _6 = Box::<isize>::new(const 3_isize) -> bb3;
    }

    bb3: {
        _5 = A { a: (_1.0: isize), b: move _6 };
        drop(_5) -> bb4;
    }

    bb4: {
        return;
    }
}

fn fu_copy_after_fu_move() -> () {
    let mut _0: ();
    let _1: A;
    let mut _2: std::boxed::Box<isize>;
    let mut _5: std::boxed::Box<isize>;
    scope 1 {
        debug x => _1;
        let _3: A;
        scope 2 {
            debug _y => _3;
            let _4: A;
            scope 3 {
                debug _z => _4;
            }
        }
    }

    bb0: {
        _2 = Box::<isize>::new(const 2_isize) -> bb1;
    }

    bb1: {
        _1 = A { a: const 1_isize, b: move _2 };
        _3 = A { a: const 3_isize, b: move (_1.1: std::boxed::Box<isize>) };
        _5 = Box::<isize>::new(const 3_isize) -> [return: bb2, unwind: bb5];
    }

    bb2: {
        _4 = A { a: (_1.0: isize), b: move _5 };
        drop(_4) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        drop(_3) -> bb4;
    }

    bb4: {
        return;
    }

    bb5 (cleanup): {
        drop(_3) -> [return: bb6, unwind terminate];
    }

    bb6 (cleanup): {
        resume;
    }
}

fn borrow_after_move() -> () {
    let mut _0: ();
    let _1: A;
    let mut _2: std::boxed::Box<isize>;
    let _3: ();
    let mut _4: std::boxed::Box<isize>;
    let _6: ();
    let mut _7: isize;
    scope 1 {
        debug x => _1;
        let _5: &isize;
        scope 2 {
            debug p => _5;
        }
    }

    bb0: {
        _2 = Box::<isize>::new(const 2_isize) -> bb1;
    }

    bb1: {
        _1 = A { a: const 1_isize, b: move _2 };
        _4 = move (_1.1: std::boxed::Box<isize>);
        _3 = std::mem::drop::<Box<isize>>(move _4) -> bb2;
    }

    bb2: {
        _5 = &(_1.0: isize);
        _7 = (*_5);
        _6 = std::mem::drop::<isize>(move _7) -> bb3;
    }

    bb3: {
        return;
    }
}

fn borrow_after_fu_move() -> () {
    let mut _0: ();
    let _1: A;
    let mut _2: std::boxed::Box<isize>;
    let _5: ();
    let mut _6: isize;
    scope 1 {
        debug x => _1;
        let _3: A;
        scope 2 {
            debug _y => _3;
            let _4: &isize;
            scope 3 {
                debug p => _4;
            }
        }
    }

    bb0: {
        _2 = Box::<isize>::new(const 2_isize) -> bb1;
    }

    bb1: {
        _1 = A { a: const 1_isize, b: move _2 };
        _3 = A { a: const 3_isize, b: move (_1.1: std::boxed::Box<isize>) };
        _4 = &(_1.0: isize);
        _6 = (*_4);
        _5 = std::mem::drop::<isize>(move _6) -> [return: bb2, unwind: bb4];
    }

    bb2: {
        drop(_3) -> bb3;
    }

    bb3: {
        return;
    }

    bb4 (cleanup): {
        drop(_3) -> [return: bb5, unwind terminate];
    }

    bb5 (cleanup): {
        resume;
    }
}

fn move_after_borrow() -> () {
    let mut _0: ();
    let _1: A;
    let mut _2: std::boxed::Box<isize>;
    let _4: ();
    let mut _5: std::boxed::Box<isize>;
    let _6: ();
    let mut _7: isize;
    scope 1 {
        debug x => _1;
        let _3: &isize;
        scope 2 {
            debug p => _3;
        }
    }

    bb0: {
        _2 = Box::<isize>::new(const 2_isize) -> bb1;
    }

    bb1: {
        _1 = A { a: const 1_isize, b: move _2 };
        _3 = &(_1.0: isize);
        _5 = move (_1.1: std::boxed::Box<isize>);
        _4 = std::mem::drop::<Box<isize>>(move _5) -> bb2;
    }

    bb2: {
        _7 = (*_3);
        _6 = std::mem::drop::<isize>(move _7) -> bb3;
    }

    bb3: {
        return;
    }
}

fn fu_move_after_borrow() -> () {
    let mut _0: ();
    let _1: A;
    let mut _2: std::boxed::Box<isize>;
    let _5: ();
    let mut _6: isize;
    scope 1 {
        debug x => _1;
        let _3: &isize;
        scope 2 {
            debug p => _3;
            let _4: A;
            scope 3 {
                debug _y => _4;
            }
        }
    }

    bb0: {
        _2 = Box::<isize>::new(const 2_isize) -> bb1;
    }

    bb1: {
        _1 = A { a: const 1_isize, b: move _2 };
        _3 = &(_1.0: isize);
        _4 = A { a: const 3_isize, b: move (_1.1: std::boxed::Box<isize>) };
        _6 = (*_3);
        _5 = std::mem::drop::<isize>(move _6) -> [return: bb2, unwind: bb4];
    }

    bb2: {
        drop(_4) -> bb3;
    }

    bb3: {
        return;
    }

    bb4 (cleanup): {
        drop(_4) -> [return: bb5, unwind terminate];
    }

    bb5 (cleanup): {
        resume;
    }
}

fn mut_borrow_after_mut_borrow() -> () {
    let mut _0: ();
    let mut _1: A;
    let mut _2: std::boxed::Box<isize>;
    let _5: ();
    let mut _6: isize;
    let _7: ();
    let mut _8: isize;
    let mut _9: std::boxed::Box<isize>;
    let mut _10: *const isize;
    scope 1 {
        debug x => _1;
        let _3: &mut isize;
        scope 2 {
            debug p => _3;
            let _4: &mut std::boxed::Box<isize>;
            scope 3 {
                debug q => _4;
                let mut _11: *const ();
                let mut _12: usize;
                let mut _13: usize;
                let mut _14: usize;
                let mut _15: usize;
                let mut _16: bool;
            }
        }
    }

    bb0: {
        _2 = Box::<isize>::new(const 2_isize) -> bb1;
    }

    bb1: {
        _1 = A { a: const 1_isize, b: move _2 };
        _3 = &mut (_1.0: isize);
        _4 = &mut (_1.1: std::boxed::Box<isize>);
        _6 = (*_3);
        _5 = std::mem::drop::<isize>(move _6) -> [return: bb2, unwind: bb5];
    }

    bb2: {
        _9 = deref_copy (*_4);
        _10 = (((_9.0: std::ptr::Unique<isize>).0: std::ptr::NonNull<isize>).0: *const isize);
        _11 = _10 as *const () (PtrToPtr);
        _12 = _11 as usize (Transmute);
        _13 = AlignOf(isize);
        _14 = Sub(_13, const 1_usize);
        _15 = BitAnd(_12, _14);
        _16 = Eq(_15, const 0_usize);
        assert(_16, "misaligned pointer dereference: address must be a multiple of {} but is {}", _13, _12) -> [success: bb7, unwind unreachable];
    }

    bb3: {
        drop(_1) -> bb4;
    }

    bb4: {
        return;
    }

    bb5 (cleanup): {
        drop(_1) -> [return: bb6, unwind terminate];
    }

    bb6 (cleanup): {
        resume;
    }

    bb7: {
        _8 = (*_10);
        _7 = std::mem::drop::<isize>(move _8) -> [return: bb3, unwind: bb5];
    }
}

fn move_after_move() -> () {
    let mut _0: ();
    let _1: B;
    let mut _2: std::boxed::Box<isize>;
    let mut _3: std::boxed::Box<isize>;
    let _4: ();
    let mut _5: std::boxed::Box<isize>;
    let _6: ();
    let mut _7: std::boxed::Box<isize>;
    let mut _8: bool;
    scope 1 {
        debug x => _1;
    }

    bb0: {
        _8 = const false;
        _2 = Box::<isize>::new(const 1_isize) -> bb1;
    }

    bb1: {
        _3 = Box::<isize>::new(const 2_isize) -> [return: bb2, unwind: bb5];
    }

    bb2: {
        _8 = const true;
        _1 = B { a: move _2, b: move _3 };
        _5 = move (_1.0: std::boxed::Box<isize>);
        _4 = std::mem::drop::<Box<isize>>(move _5) -> [return: bb3, unwind: bb8];
    }

    bb3: {
        _8 = const false;
        _7 = move (_1.1: std::boxed::Box<isize>);
        _6 = std::mem::drop::<Box<isize>>(move _7) -> [return: bb4, unwind: bb8];
    }

    bb4: {
        _8 = const false;
        return;
    }

    bb5 (cleanup): {
        drop(_2) -> [return: bb6, unwind terminate];
    }

    bb6 (cleanup): {
        resume;
    }

    bb7 (cleanup): {
        drop((_1.1: std::boxed::Box<isize>)) -> [return: bb6, unwind terminate];
    }

    bb8 (cleanup): {
        switchInt(_8) -> [0: bb6, otherwise: bb7];
    }
}

fn move_after_fu_move() -> () {
    let mut _0: ();
    let _1: B;
    let mut _2: std::boxed::Box<isize>;
    let mut _3: std::boxed::Box<isize>;
    let mut _5: std::boxed::Box<isize>;
    let _6: ();
    let mut _7: std::boxed::Box<isize>;
    let mut _8: bool;
    let mut _9: bool;
    scope 1 {
        debug x => _1;
        let _4: B;
        scope 2 {
            debug y => _4;
        }
    }

    bb0: {
        _9 = const false;
        _8 = const false;
        _2 = Box::<isize>::new(const 1_isize) -> bb1;
    }

    bb1: {
        _3 = Box::<isize>::new(const 2_isize) -> [return: bb2, unwind: bb7];
    }

    bb2: {
        _8 = const true;
        _9 = const true;
        _1 = B { a: move _2, b: move _3 };
        _5 = Box::<isize>::new(const 3_isize) -> [return: bb3, unwind: bb12];
    }

    bb3: {
        _9 = const false;
        _4 = B { a: move _5, b: move (_1.1: std::boxed::Box<isize>) };
        _8 = const false;
        _7 = move (_1.0: std::boxed::Box<isize>);
        _6 = std::mem::drop::<Box<isize>>(move _7) -> [return: bb4, unwind: bb6];
    }

    bb4: {
        drop(_4) -> [return: bb5, unwind: bb12];
    }

    bb5: {
        _8 = const false;
        _9 = const false;
        return;
    }

    bb6 (cleanup): {
        drop(_4) -> [return: bb12, unwind terminate];
    }

    bb7 (cleanup): {
        drop(_2) -> [return: bb8, unwind terminate];
    }

    bb8 (cleanup): {
        resume;
    }

    bb9 (cleanup): {
        switchInt(_9) -> [0: bb8, otherwise: bb10];
    }

    bb10 (cleanup): {
        drop((_1.1: std::boxed::Box<isize>)) -> [return: bb8, unwind terminate];
    }

    bb11 (cleanup): {
        drop((_1.0: std::boxed::Box<isize>)) -> [return: bb9, unwind terminate];
    }

    bb12 (cleanup): {
        switchInt(_8) -> [0: bb9, otherwise: bb11];
    }
}

fn fu_move_after_move() -> () {
    let mut _0: ();
    let _1: B;
    let mut _2: std::boxed::Box<isize>;
    let mut _3: std::boxed::Box<isize>;
    let _4: ();
    let mut _5: std::boxed::Box<isize>;
    let mut _7: std::boxed::Box<isize>;
    let _8: ();
    let mut _9: std::boxed::Box<isize>;
    let mut _10: bool;
    scope 1 {
        debug x => _1;
        let _6: B;
        scope 2 {
            debug z => _6;
        }
    }

    bb0: {
        _10 = const false;
        _2 = Box::<isize>::new(const 1_isize) -> bb1;
    }

    bb1: {
        _3 = Box::<isize>::new(const 2_isize) -> [return: bb2, unwind: bb7];
    }

    bb2: {
        _10 = const true;
        _1 = B { a: move _2, b: move _3 };
        _5 = move (_1.0: std::boxed::Box<isize>);
        _4 = std::mem::drop::<Box<isize>>(move _5) -> [return: bb3, unwind: bb11];
    }

    bb3: {
        _7 = Box::<isize>::new(const 3_isize) -> [return: bb4, unwind: bb11];
    }

    bb4: {
        _10 = const false;
        _6 = B { a: move _7, b: move (_1.1: std::boxed::Box<isize>) };
        _9 = move (_6.1: std::boxed::Box<isize>);
        _8 = std::mem::drop::<Box<isize>>(move _9) -> [return: bb5, unwind: bb6];
    }

    bb5: {
        drop((_6.0: std::boxed::Box<isize>)) -> [return: bb9, unwind: bb11];
    }

    bb6 (cleanup): {
        drop((_6.0: std::boxed::Box<isize>)) -> [return: bb11, unwind terminate];
    }

    bb7 (cleanup): {
        drop(_2) -> [return: bb8, unwind terminate];
    }

    bb8 (cleanup): {
        resume;
    }

    bb9: {
        _10 = const false;
        return;
    }

    bb10 (cleanup): {
        drop((_1.1: std::boxed::Box<isize>)) -> [return: bb8, unwind terminate];
    }

    bb11 (cleanup): {
        switchInt(_10) -> [0: bb8, otherwise: bb10];
    }
}

fn fu_move_after_fu_move() -> () {
    let mut _0: ();
    let _1: B;
    let mut _2: std::boxed::Box<isize>;
    let mut _3: std::boxed::Box<isize>;
    let mut _5: std::boxed::Box<isize>;
    let mut _7: std::boxed::Box<isize>;
    let mut _8: bool;
    let mut _9: bool;
    scope 1 {
        debug x => _1;
        let _4: B;
        scope 2 {
            debug _y => _4;
            let _6: B;
            scope 3 {
                debug _z => _6;
            }
        }
    }

    bb0: {
        _9 = const false;
        _8 = const false;
        _2 = Box::<isize>::new(const 1_isize) -> bb1;
    }

    bb1: {
        _3 = Box::<isize>::new(const 2_isize) -> [return: bb2, unwind: bb8];
    }

    bb2: {
        _8 = const true;
        _9 = const true;
        _1 = B { a: move _2, b: move _3 };
        _5 = Box::<isize>::new(const 3_isize) -> [return: bb3, unwind: bb13];
    }

    bb3: {
        _9 = const false;
        _4 = B { a: move (_1.0: std::boxed::Box<isize>), b: move _5 };
        _7 = Box::<isize>::new(const 4_isize) -> [return: bb4, unwind: bb7];
    }

    bb4: {
        _8 = const false;
        _6 = B { a: move _7, b: move (_1.1: std::boxed::Box<isize>) };
        drop(_6) -> [return: bb5, unwind: bb7];
    }

    bb5: {
        drop(_4) -> [return: bb6, unwind: bb13];
    }

    bb6: {
        _8 = const false;
        _9 = const false;
        return;
    }

    bb7 (cleanup): {
        drop(_4) -> [return: bb13, unwind terminate];
    }

    bb8 (cleanup): {
        drop(_2) -> [return: bb9, unwind terminate];
    }

    bb9 (cleanup): {
        resume;
    }

    bb10 (cleanup): {
        switchInt(_8) -> [0: bb9, otherwise: bb11];
    }

    bb11 (cleanup): {
        drop((_1.1: std::boxed::Box<isize>)) -> [return: bb9, unwind terminate];
    }

    bb12 (cleanup): {
        drop((_1.0: std::boxed::Box<isize>)) -> [return: bb10, unwind terminate];
    }

    bb13 (cleanup): {
        switchInt(_9) -> [0: bb10, otherwise: bb12];
    }
}

fn copy_after_assign_after_move() -> () {
    let mut _0: ();
    let mut _1: A;
    let mut _2: std::boxed::Box<isize>;
    let _3: ();
    let mut _4: std::boxed::Box<isize>;
    let mut _5: A;
    let mut _6: std::boxed::Box<isize>;
    let _7: ();
    let mut _8: isize;
    let mut _9: std::boxed::Box<isize>;
    let mut _10: bool;
    let mut _11: *const isize;
    scope 1 {
        debug x => _1;
        let mut _12: *const ();
        let mut _13: usize;
        let mut _14: usize;
        let mut _15: usize;
        let mut _16: usize;
        let mut _17: bool;
    }

    bb0: {
        _10 = const false;
        _2 = Box::<isize>::new(const 2_isize) -> bb1;
    }

    bb1: {
        _10 = const true;
        _1 = A { a: const 1_isize, b: move _2 };
        _10 = const false;
        _4 = move (_1.1: std::boxed::Box<isize>);
        _3 = std::mem::drop::<Box<isize>>(move _4) -> [return: bb2, unwind: bb8];
    }

    bb2: {
        _6 = Box::<isize>::new(const 4_isize) -> [return: bb3, unwind: bb8];
    }

    bb3: {
        _5 = A { a: const 3_isize, b: move _6 };
        _10 = const true;
        _1 = move _5;
        _9 = deref_copy (_1.1: std::boxed::Box<isize>);
        _11 = (((_9.0: std::ptr::Unique<isize>).0: std::ptr::NonNull<isize>).0: *const isize);
        _12 = _11 as *const () (PtrToPtr);
        _13 = _12 as usize (Transmute);
        _14 = AlignOf(isize);
        _15 = Sub(_14, const 1_usize);
        _16 = BitAnd(_13, _15);
        _17 = Eq(_16, const 0_usize);
        assert(_17, "misaligned pointer dereference: address must be a multiple of {} but is {}", _14, _13) -> [success: bb9, unwind unreachable];
    }

    bb4: {
        drop(_1) -> bb5;
    }

    bb5: {
        _10 = const false;
        return;
    }

    bb6 (cleanup): {
        resume;
    }

    bb7 (cleanup): {
        drop((_1.1: std::boxed::Box<isize>)) -> [return: bb6, unwind terminate];
    }

    bb8 (cleanup): {
        switchInt(_10) -> [0: bb6, otherwise: bb7];
    }

    bb9: {
        _8 = (*_11);
        _7 = std::mem::drop::<isize>(move _8) -> [return: bb4, unwind: bb8];
    }
}

fn copy_after_assign_after_fu_move() -> () {
    let mut _0: ();
    let mut _1: A;
    let mut _2: std::boxed::Box<isize>;
    let mut _4: A;
    let mut _5: std::boxed::Box<isize>;
    let _6: ();
    let mut _7: isize;
    let mut _8: std::boxed::Box<isize>;
    let mut _9: bool;
    let mut _10: *const isize;
    scope 1 {
        debug x => _1;
        let _3: A;
        scope 2 {
            debug _y => _3;
            let mut _11: *const ();
            let mut _12: usize;
            let mut _13: usize;
            let mut _14: usize;
            let mut _15: usize;
            let mut _16: bool;
        }
    }

    bb0: {
        _9 = const false;
        _2 = Box::<isize>::new(const 2_isize) -> bb1;
    }

    bb1: {
        _9 = const true;
        _1 = A { a: const 1_isize, b: move _2 };
        _9 = const false;
        _3 = A { a: const 3_isize, b: move (_1.1: std::boxed::Box<isize>) };
        _5 = Box::<isize>::new(const 4_isize) -> [return: bb2, unwind: bb6];
    }

    bb2: {
        _4 = A { a: const 3_isize, b: move _5 };
        _9 = const true;
        _1 = move _4;
        _8 = deref_copy (_1.1: std::boxed::Box<isize>);
        _10 = (((_8.0: std::ptr::Unique<isize>).0: std::ptr::NonNull<isize>).0: *const isize);
        _11 = _10 as *const () (PtrToPtr);
        _12 = _11 as usize (Transmute);
        _13 = AlignOf(isize);
        _14 = Sub(_13, const 1_usize);
        _15 = BitAnd(_12, _14);
        _16 = Eq(_15, const 0_usize);
        assert(_16, "misaligned pointer dereference: address must be a multiple of {} but is {}", _13, _12) -> [success: bb10, unwind unreachable];
    }

    bb3: {
        drop(_3) -> [return: bb4, unwind: bb9];
    }

    bb4: {
        drop(_1) -> bb5;
    }

    bb5: {
        _9 = const false;
        return;
    }

    bb6 (cleanup): {
        drop(_3) -> [return: bb9, unwind terminate];
    }

    bb7 (cleanup): {
        resume;
    }

    bb8 (cleanup): {
        drop((_1.1: std::boxed::Box<isize>)) -> [return: bb7, unwind terminate];
    }

    bb9 (cleanup): {
        switchInt(_9) -> [0: bb7, otherwise: bb8];
    }

    bb10: {
        _7 = (*_10);
        _6 = std::mem::drop::<isize>(move _7) -> [return: bb3, unwind: bb6];
    }
}

fn copy_after_field_assign_after_move() -> () {
    let mut _0: ();
    let mut _1: A;
    let mut _2: std::boxed::Box<isize>;
    let _3: ();
    let mut _4: std::boxed::Box<isize>;
    let mut _5: std::boxed::Box<isize>;
    let _6: ();
    let mut _7: isize;
    let mut _8: std::boxed::Box<isize>;
    let mut _9: bool;
    let mut _10: *const isize;
    scope 1 {
        debug x => _1;
        let mut _11: *const ();
        let mut _12: usize;
        let mut _13: usize;
        let mut _14: usize;
        let mut _15: usize;
        let mut _16: bool;
    }

    bb0: {
        _9 = const false;
        _2 = Box::<isize>::new(const 2_isize) -> bb1;
    }

    bb1: {
        _9 = const true;
        _1 = A { a: const 1_isize, b: move _2 };
        _9 = const false;
        _4 = move (_1.1: std::boxed::Box<isize>);
        _3 = std::mem::drop::<Box<isize>>(move _4) -> [return: bb2, unwind: bb8];
    }

    bb2: {
        _5 = Box::<isize>::new(const 3_isize) -> [return: bb3, unwind: bb8];
    }

    bb3: {
        _9 = const true;
        (_1.1: std::boxed::Box<isize>) = move _5;
        _8 = deref_copy (_1.1: std::boxed::Box<isize>);
        _10 = (((_8.0: std::ptr::Unique<isize>).0: std::ptr::NonNull<isize>).0: *const isize);
        _11 = _10 as *const () (PtrToPtr);
        _12 = _11 as usize (Transmute);
        _13 = AlignOf(isize);
        _14 = Sub(_13, const 1_usize);
        _15 = BitAnd(_12, _14);
        _16 = Eq(_15, const 0_usize);
        assert(_16, "misaligned pointer dereference: address must be a multiple of {} but is {}", _13, _12) -> [success: bb9, unwind unreachable];
    }

    bb4: {
        drop(_1) -> bb5;
    }

    bb5: {
        _9 = const false;
        return;
    }

    bb6 (cleanup): {
        resume;
    }

    bb7 (cleanup): {
        drop((_1.1: std::boxed::Box<isize>)) -> [return: bb6, unwind terminate];
    }

    bb8 (cleanup): {
        switchInt(_9) -> [0: bb6, otherwise: bb7];
    }

    bb9: {
        _7 = (*_10);
        _6 = std::mem::drop::<isize>(move _7) -> [return: bb4, unwind: bb8];
    }
}

fn copy_after_field_assign_after_fu_move() -> () {
    let mut _0: ();
    let mut _1: A;
    let mut _2: std::boxed::Box<isize>;
    let mut _4: std::boxed::Box<isize>;
    let _5: ();
    let mut _6: isize;
    let mut _7: std::boxed::Box<isize>;
    let mut _8: bool;
    let mut _9: *const isize;
    scope 1 {
        debug x => _1;
        let _3: A;
        scope 2 {
            debug _y => _3;
            let mut _10: *const ();
            let mut _11: usize;
            let mut _12: usize;
            let mut _13: usize;
            let mut _14: usize;
            let mut _15: bool;
        }
    }

    bb0: {
        _8 = const false;
        _2 = Box::<isize>::new(const 2_isize) -> bb1;
    }

    bb1: {
        _8 = const true;
        _1 = A { a: const 1_isize, b: move _2 };
        _8 = const false;
        _3 = A { a: const 3_isize, b: move (_1.1: std::boxed::Box<isize>) };
        _4 = Box::<isize>::new(const 3_isize) -> [return: bb2, unwind: bb6];
    }

    bb2: {
        _8 = const true;
        (_1.1: std::boxed::Box<isize>) = move _4;
        _7 = deref_copy (_1.1: std::boxed::Box<isize>);
        _9 = (((_7.0: std::ptr::Unique<isize>).0: std::ptr::NonNull<isize>).0: *const isize);
        _10 = _9 as *const () (PtrToPtr);
        _11 = _10 as usize (Transmute);
        _12 = AlignOf(isize);
        _13 = Sub(_12, const 1_usize);
        _14 = BitAnd(_11, _13);
        _15 = Eq(_14, const 0_usize);
        assert(_15, "misaligned pointer dereference: address must be a multiple of {} but is {}", _12, _11) -> [success: bb10, unwind unreachable];
    }

    bb3: {
        drop(_3) -> [return: bb4, unwind: bb9];
    }

    bb4: {
        drop(_1) -> bb5;
    }

    bb5: {
        _8 = const false;
        return;
    }

    bb6 (cleanup): {
        drop(_3) -> [return: bb9, unwind terminate];
    }

    bb7 (cleanup): {
        resume;
    }

    bb8 (cleanup): {
        drop((_1.1: std::boxed::Box<isize>)) -> [return: bb7, unwind terminate];
    }

    bb9 (cleanup): {
        switchInt(_8) -> [0: bb7, otherwise: bb8];
    }

    bb10: {
        _6 = (*_9);
        _5 = std::mem::drop::<isize>(move _6) -> [return: bb3, unwind: bb6];
    }
}

fn borrow_after_assign_after_move() -> () {
    let mut _0: ();
    let mut _1: A;
    let mut _2: std::boxed::Box<isize>;
    let _3: ();
    let mut _4: std::boxed::Box<isize>;
    let mut _5: A;
    let mut _6: std::boxed::Box<isize>;
    let _8: ();
    let mut _9: isize;
    let mut _10: std::boxed::Box<isize>;
    let mut _11: bool;
    let mut _12: *const isize;
    scope 1 {
        debug x => _1;
        let _7: &std::boxed::Box<isize>;
        scope 2 {
            debug p => _7;
            let mut _13: *const ();
            let mut _14: usize;
            let mut _15: usize;
            let mut _16: usize;
            let mut _17: usize;
            let mut _18: bool;
        }
    }

    bb0: {
        _11 = const false;
        _2 = Box::<isize>::new(const 2_isize) -> bb1;
    }

    bb1: {
        _11 = const true;
        _1 = A { a: const 1_isize, b: move _2 };
        _11 = const false;
        _4 = move (_1.1: std::boxed::Box<isize>);
        _3 = std::mem::drop::<Box<isize>>(move _4) -> [return: bb2, unwind: bb8];
    }

    bb2: {
        _6 = Box::<isize>::new(const 4_isize) -> [return: bb3, unwind: bb8];
    }

    bb3: {
        _5 = A { a: const 3_isize, b: move _6 };
        _11 = const true;
        _1 = move _5;
        _7 = &(_1.1: std::boxed::Box<isize>);
        _10 = deref_copy (*_7);
        _12 = (((_10.0: std::ptr::Unique<isize>).0: std::ptr::NonNull<isize>).0: *const isize);
        _13 = _12 as *const () (PtrToPtr);
        _14 = _13 as usize (Transmute);
        _15 = AlignOf(isize);
        _16 = Sub(_15, const 1_usize);
        _17 = BitAnd(_14, _16);
        _18 = Eq(_17, const 0_usize);
        assert(_18, "misaligned pointer dereference: address must be a multiple of {} but is {}", _15, _14) -> [success: bb9, unwind unreachable];
    }

    bb4: {
        drop(_1) -> bb5;
    }

    bb5: {
        _11 = const false;
        return;
    }

    bb6 (cleanup): {
        resume;
    }

    bb7 (cleanup): {
        drop((_1.1: std::boxed::Box<isize>)) -> [return: bb6, unwind terminate];
    }

    bb8 (cleanup): {
        switchInt(_11) -> [0: bb6, otherwise: bb7];
    }

    bb9: {
        _9 = (*_12);
        _8 = std::mem::drop::<isize>(move _9) -> [return: bb4, unwind: bb8];
    }
}

fn borrow_after_assign_after_fu_move() -> () {
    let mut _0: ();
    let mut _1: A;
    let mut _2: std::boxed::Box<isize>;
    let mut _4: A;
    let mut _5: std::boxed::Box<isize>;
    let _7: ();
    let mut _8: isize;
    let mut _9: std::boxed::Box<isize>;
    let mut _10: bool;
    let mut _11: *const isize;
    scope 1 {
        debug x => _1;
        let _3: A;
        scope 2 {
            debug _y => _3;
            let _6: &std::boxed::Box<isize>;
            scope 3 {
                debug p => _6;
                let mut _12: *const ();
                let mut _13: usize;
                let mut _14: usize;
                let mut _15: usize;
                let mut _16: usize;
                let mut _17: bool;
            }
        }
    }

    bb0: {
        _10 = const false;
        _2 = Box::<isize>::new(const 2_isize) -> bb1;
    }

    bb1: {
        _10 = const true;
        _1 = A { a: const 1_isize, b: move _2 };
        _10 = const false;
        _3 = A { a: const 3_isize, b: move (_1.1: std::boxed::Box<isize>) };
        _5 = Box::<isize>::new(const 4_isize) -> [return: bb2, unwind: bb6];
    }

    bb2: {
        _4 = A { a: const 3_isize, b: move _5 };
        _10 = const true;
        _1 = move _4;
        _6 = &(_1.1: std::boxed::Box<isize>);
        _9 = deref_copy (*_6);
        _11 = (((_9.0: std::ptr::Unique<isize>).0: std::ptr::NonNull<isize>).0: *const isize);
        _12 = _11 as *const () (PtrToPtr);
        _13 = _12 as usize (Transmute);
        _14 = AlignOf(isize);
        _15 = Sub(_14, const 1_usize);
        _16 = BitAnd(_13, _15);
        _17 = Eq(_16, const 0_usize);
        assert(_17, "misaligned pointer dereference: address must be a multiple of {} but is {}", _14, _13) -> [success: bb10, unwind unreachable];
    }

    bb3: {
        drop(_3) -> [return: bb4, unwind: bb9];
    }

    bb4: {
        drop(_1) -> bb5;
    }

    bb5: {
        _10 = const false;
        return;
    }

    bb6 (cleanup): {
        drop(_3) -> [return: bb9, unwind terminate];
    }

    bb7 (cleanup): {
        resume;
    }

    bb8 (cleanup): {
        drop((_1.1: std::boxed::Box<isize>)) -> [return: bb7, unwind terminate];
    }

    bb9 (cleanup): {
        switchInt(_10) -> [0: bb7, otherwise: bb8];
    }

    bb10: {
        _8 = (*_11);
        _7 = std::mem::drop::<isize>(move _8) -> [return: bb3, unwind: bb6];
    }
}

fn borrow_after_field_assign_after_move() -> () {
    let mut _0: ();
    let mut _1: A;
    let mut _2: std::boxed::Box<isize>;
    let _3: ();
    let mut _4: std::boxed::Box<isize>;
    let mut _5: std::boxed::Box<isize>;
    let _7: ();
    let mut _8: isize;
    let mut _9: std::boxed::Box<isize>;
    let mut _10: bool;
    let mut _11: *const isize;
    scope 1 {
        debug x => _1;
        let _6: &std::boxed::Box<isize>;
        scope 2 {
            debug p => _6;
            let mut _12: *const ();
            let mut _13: usize;
            let mut _14: usize;
            let mut _15: usize;
            let mut _16: usize;
            let mut _17: bool;
        }
    }

    bb0: {
        _10 = const false;
        _2 = Box::<isize>::new(const 2_isize) -> bb1;
    }

    bb1: {
        _10 = const true;
        _1 = A { a: const 1_isize, b: move _2 };
        _10 = const false;
        _4 = move (_1.1: std::boxed::Box<isize>);
        _3 = std::mem::drop::<Box<isize>>(move _4) -> [return: bb2, unwind: bb8];
    }

    bb2: {
        _5 = Box::<isize>::new(const 3_isize) -> [return: bb3, unwind: bb8];
    }

    bb3: {
        _10 = const true;
        (_1.1: std::boxed::Box<isize>) = move _5;
        _6 = &(_1.1: std::boxed::Box<isize>);
        _9 = deref_copy (*_6);
        _11 = (((_9.0: std::ptr::Unique<isize>).0: std::ptr::NonNull<isize>).0: *const isize);
        _12 = _11 as *const () (PtrToPtr);
        _13 = _12 as usize (Transmute);
        _14 = AlignOf(isize);
        _15 = Sub(_14, const 1_usize);
        _16 = BitAnd(_13, _15);
        _17 = Eq(_16, const 0_usize);
        assert(_17, "misaligned pointer dereference: address must be a multiple of {} but is {}", _14, _13) -> [success: bb9, unwind unreachable];
    }

    bb4: {
        drop(_1) -> bb5;
    }

    bb5: {
        _10 = const false;
        return;
    }

    bb6 (cleanup): {
        resume;
    }

    bb7 (cleanup): {
        drop((_1.1: std::boxed::Box<isize>)) -> [return: bb6, unwind terminate];
    }

    bb8 (cleanup): {
        switchInt(_10) -> [0: bb6, otherwise: bb7];
    }

    bb9: {
        _8 = (*_11);
        _7 = std::mem::drop::<isize>(move _8) -> [return: bb4, unwind: bb8];
    }
}

fn borrow_after_field_assign_after_fu_move() -> () {
    let mut _0: ();
    let mut _1: A;
    let mut _2: std::boxed::Box<isize>;
    let mut _4: std::boxed::Box<isize>;
    let _6: ();
    let mut _7: isize;
    let mut _8: std::boxed::Box<isize>;
    let mut _9: bool;
    let mut _10: *const isize;
    scope 1 {
        debug x => _1;
        let _3: A;
        scope 2 {
            debug _y => _3;
            let _5: &std::boxed::Box<isize>;
            scope 3 {
                debug p => _5;
                let mut _11: *const ();
                let mut _12: usize;
                let mut _13: usize;
                let mut _14: usize;
                let mut _15: usize;
                let mut _16: bool;
            }
        }
    }

    bb0: {
        _9 = const false;
        _2 = Box::<isize>::new(const 2_isize) -> bb1;
    }

    bb1: {
        _9 = const true;
        _1 = A { a: const 1_isize, b: move _2 };
        _9 = const false;
        _3 = A { a: const 3_isize, b: move (_1.1: std::boxed::Box<isize>) };
        _4 = Box::<isize>::new(const 3_isize) -> [return: bb2, unwind: bb6];
    }

    bb2: {
        _9 = const true;
        (_1.1: std::boxed::Box<isize>) = move _4;
        _5 = &(_1.1: std::boxed::Box<isize>);
        _8 = deref_copy (*_5);
        _10 = (((_8.0: std::ptr::Unique<isize>).0: std::ptr::NonNull<isize>).0: *const isize);
        _11 = _10 as *const () (PtrToPtr);
        _12 = _11 as usize (Transmute);
        _13 = AlignOf(isize);
        _14 = Sub(_13, const 1_usize);
        _15 = BitAnd(_12, _14);
        _16 = Eq(_15, const 0_usize);
        assert(_16, "misaligned pointer dereference: address must be a multiple of {} but is {}", _13, _12) -> [success: bb10, unwind unreachable];
    }

    bb3: {
        drop(_3) -> [return: bb4, unwind: bb9];
    }

    bb4: {
        drop(_1) -> bb5;
    }

    bb5: {
        _9 = const false;
        return;
    }

    bb6 (cleanup): {
        drop(_3) -> [return: bb9, unwind terminate];
    }

    bb7 (cleanup): {
        resume;
    }

    bb8 (cleanup): {
        drop((_1.1: std::boxed::Box<isize>)) -> [return: bb7, unwind terminate];
    }

    bb9 (cleanup): {
        switchInt(_9) -> [0: bb7, otherwise: bb8];
    }

    bb10: {
        _7 = (*_10);
        _6 = std::mem::drop::<isize>(move _7) -> [return: bb3, unwind: bb6];
    }
}

fn move_after_assign_after_move() -> () {
    let mut _0: ();
    let mut _1: A;
    let mut _2: std::boxed::Box<isize>;
    let mut _4: A;
    let mut _5: std::boxed::Box<isize>;
    let _6: ();
    let mut _7: std::boxed::Box<isize>;
    let mut _8: bool;
    scope 1 {
        debug x => _1;
        let _3: std::boxed::Box<isize>;
        scope 2 {
            debug _y => _3;
        }
    }

    bb0: {
        _8 = const false;
        _2 = Box::<isize>::new(const 2_isize) -> bb1;
    }

    bb1: {
        _8 = const true;
        _1 = A { a: const 1_isize, b: move _2 };
        _8 = const false;
        _3 = move (_1.1: std::boxed::Box<isize>);
        _5 = Box::<isize>::new(const 4_isize) -> [return: bb2, unwind: bb5];
    }

    bb2: {
        _4 = A { a: const 3_isize, b: move _5 };
        _8 = const true;
        _1 = move _4;
        _8 = const false;
        _7 = move (_1.1: std::boxed::Box<isize>);
        _6 = std::mem::drop::<Box<isize>>(move _7) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        drop(_3) -> [return: bb4, unwind: bb8];
    }

    bb4: {
        _8 = const false;
        return;
    }

    bb5 (cleanup): {
        drop(_3) -> [return: bb8, unwind terminate];
    }

    bb6 (cleanup): {
        resume;
    }

    bb7 (cleanup): {
        drop((_1.1: std::boxed::Box<isize>)) -> [return: bb6, unwind terminate];
    }

    bb8 (cleanup): {
        switchInt(_8) -> [0: bb6, otherwise: bb7];
    }
}

fn move_after_assign_after_fu_move() -> () {
    let mut _0: ();
    let mut _1: A;
    let mut _2: std::boxed::Box<isize>;
    let mut _4: A;
    let mut _5: std::boxed::Box<isize>;
    let _6: ();
    let mut _7: std::boxed::Box<isize>;
    let mut _8: bool;
    scope 1 {
        debug x => _1;
        let _3: A;
        scope 2 {
            debug _y => _3;
        }
    }

    bb0: {
        _8 = const false;
        _2 = Box::<isize>::new(const 2_isize) -> bb1;
    }

    bb1: {
        _8 = const true;
        _1 = A { a: const 1_isize, b: move _2 };
        _8 = const false;
        _3 = A { a: const 3_isize, b: move (_1.1: std::boxed::Box<isize>) };
        _5 = Box::<isize>::new(const 4_isize) -> [return: bb2, unwind: bb5];
    }

    bb2: {
        _4 = A { a: const 3_isize, b: move _5 };
        _8 = const true;
        _1 = move _4;
        _8 = const false;
        _7 = move (_1.1: std::boxed::Box<isize>);
        _6 = std::mem::drop::<Box<isize>>(move _7) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        drop(_3) -> [return: bb4, unwind: bb8];
    }

    bb4: {
        _8 = const false;
        return;
    }

    bb5 (cleanup): {
        drop(_3) -> [return: bb8, unwind terminate];
    }

    bb6 (cleanup): {
        resume;
    }

    bb7 (cleanup): {
        drop((_1.1: std::boxed::Box<isize>)) -> [return: bb6, unwind terminate];
    }

    bb8 (cleanup): {
        switchInt(_8) -> [0: bb6, otherwise: bb7];
    }
}

fn move_after_field_assign_after_move() -> () {
    let mut _0: ();
    let mut _1: A;
    let mut _2: std::boxed::Box<isize>;
    let _3: ();
    let mut _4: std::boxed::Box<isize>;
    let mut _5: std::boxed::Box<isize>;
    let _6: ();
    let mut _7: std::boxed::Box<isize>;
    scope 1 {
        debug x => _1;
    }

    bb0: {
        _2 = Box::<isize>::new(const 2_isize) -> bb1;
    }

    bb1: {
        _1 = A { a: const 1_isize, b: move _2 };
        _4 = move (_1.1: std::boxed::Box<isize>);
        _3 = std::mem::drop::<Box<isize>>(move _4) -> bb2;
    }

    bb2: {
        _5 = Box::<isize>::new(const 3_isize) -> bb3;
    }

    bb3: {
        (_1.1: std::boxed::Box<isize>) = move _5;
        _7 = move (_1.1: std::boxed::Box<isize>);
        _6 = std::mem::drop::<Box<isize>>(move _7) -> bb4;
    }

    bb4: {
        return;
    }
}

fn move_after_field_assign_after_fu_move() -> () {
    let mut _0: ();
    let mut _1: A;
    let mut _2: std::boxed::Box<isize>;
    let mut _4: std::boxed::Box<isize>;
    let _5: ();
    let mut _6: std::boxed::Box<isize>;
    scope 1 {
        debug x => _1;
        let _3: A;
        scope 2 {
            debug _y => _3;
        }
    }

    bb0: {
        _2 = Box::<isize>::new(const 2_isize) -> bb1;
    }

    bb1: {
        _1 = A { a: const 1_isize, b: move _2 };
        _3 = A { a: const 3_isize, b: move (_1.1: std::boxed::Box<isize>) };
        _4 = Box::<isize>::new(const 3_isize) -> [return: bb2, unwind: bb5];
    }

    bb2: {
        (_1.1: std::boxed::Box<isize>) = move _4;
        _6 = move (_1.1: std::boxed::Box<isize>);
        _5 = std::mem::drop::<Box<isize>>(move _6) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        drop(_3) -> bb4;
    }

    bb4: {
        return;
    }

    bb5 (cleanup): {
        drop(_3) -> [return: bb6, unwind terminate];
    }

    bb6 (cleanup): {
        resume;
    }
}

fn copy_after_assign_after_uninit() -> () {
    let mut _0: ();
    let mut _1: A;
    let mut _2: A;
    let mut _3: std::boxed::Box<isize>;
    let _4: ();
    let mut _5: isize;
    let mut _6: bool;
    scope 1 {
        debug x => _1;
    }

    bb0: {
        _6 = const false;
        _3 = Box::<isize>::new(const 2_isize) -> [return: bb1, unwind: bb6];
    }

    bb1: {
        _2 = A { a: const 1_isize, b: move _3 };
        _6 = const true;
        _1 = move _2;
        _5 = (_1.0: isize);
        _4 = std::mem::drop::<isize>(move _5) -> [return: bb2, unwind: bb6];
    }

    bb2: {
        drop(_1) -> bb3;
    }

    bb3: {
        _6 = const false;
        return;
    }

    bb4 (cleanup): {
        resume;
    }

    bb5 (cleanup): {
        drop(_1) -> [return: bb4, unwind terminate];
    }

    bb6 (cleanup): {
        switchInt(_6) -> [0: bb4, otherwise: bb5];
    }
}

fn borrow_after_assign_after_uninit() -> () {
    let mut _0: ();
    let mut _1: A;
    let mut _2: A;
    let mut _3: std::boxed::Box<isize>;
    let _5: ();
    let mut _6: isize;
    let mut _7: bool;
    scope 1 {
        debug x => _1;
        let _4: &isize;
        scope 2 {
            debug p => _4;
        }
    }

    bb0: {
        _7 = const false;
        _3 = Box::<isize>::new(const 2_isize) -> [return: bb1, unwind: bb6];
    }

    bb1: {
        _2 = A { a: const 1_isize, b: move _3 };
        _7 = const true;
        _1 = move _2;
        _4 = &(_1.0: isize);
        _6 = (*_4);
        _5 = std::mem::drop::<isize>(move _6) -> [return: bb2, unwind: bb6];
    }

    bb2: {
        drop(_1) -> bb3;
    }

    bb3: {
        _7 = const false;
        return;
    }

    bb4 (cleanup): {
        resume;
    }

    bb5 (cleanup): {
        drop(_1) -> [return: bb4, unwind terminate];
    }

    bb6 (cleanup): {
        switchInt(_7) -> [0: bb4, otherwise: bb5];
    }
}

fn move_after_assign_after_uninit() -> () {
    let mut _0: ();
    let mut _1: A;
    let mut _2: std::boxed::Box<isize>;
    let _3: ();
    let mut _4: std::boxed::Box<isize>;
    scope 1 {
        debug x => _1;
    }

    bb0: {
        _2 = Box::<isize>::new(const 2_isize) -> bb1;
    }

    bb1: {
        _1 = A { a: const 1_isize, b: move _2 };
        _4 = move (_1.1: std::boxed::Box<isize>);
        _3 = std::mem::drop::<Box<isize>>(move _4) -> bb2;
    }

    bb2: {
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let _1: ();
    let _2: ();
    let _3: ();
    let _4: ();
    let _5: ();
    let _6: ();
    let _7: ();
    let _8: ();
    let _9: ();
    let _10: ();
    let _11: ();
    let _12: ();
    let _13: ();
    let _14: ();
    let _15: ();
    let _16: ();
    let _17: ();
    let _18: ();
    let _19: ();
    let _20: ();
    let _21: ();
    let _22: ();
    let _23: ();
    let _24: ();
    let _25: ();
    let _26: ();
    let _27: ();
    let _28: ();
    let _29: ();
    let _30: ();
    let _31: ();
    let _32: ();

    bb0: {
        _1 = move_after_copy() -> bb1;
    }

    bb1: {
        _2 = move_after_fu_copy() -> bb2;
    }

    bb2: {
        _3 = fu_move_after_copy() -> bb3;
    }

    bb3: {
        _4 = fu_move_after_fu_copy() -> bb4;
    }

    bb4: {
        _5 = copy_after_move() -> bb5;
    }

    bb5: {
        _6 = copy_after_fu_move() -> bb6;
    }

    bb6: {
        _7 = fu_copy_after_move() -> bb7;
    }

    bb7: {
        _8 = fu_copy_after_fu_move() -> bb8;
    }

    bb8: {
        _9 = borrow_after_move() -> bb9;
    }

    bb9: {
        _10 = borrow_after_fu_move() -> bb10;
    }

    bb10: {
        _11 = move_after_borrow() -> bb11;
    }

    bb11: {
        _12 = fu_move_after_borrow() -> bb12;
    }

    bb12: {
        _13 = mut_borrow_after_mut_borrow() -> bb13;
    }

    bb13: {
        _14 = move_after_move() -> bb14;
    }

    bb14: {
        _15 = move_after_fu_move() -> bb15;
    }

    bb15: {
        _16 = fu_move_after_move() -> bb16;
    }

    bb16: {
        _17 = fu_move_after_fu_move() -> bb17;
    }

    bb17: {
        _18 = copy_after_assign_after_move() -> bb18;
    }

    bb18: {
        _19 = copy_after_assign_after_fu_move() -> bb19;
    }

    bb19: {
        _20 = copy_after_field_assign_after_move() -> bb20;
    }

    bb20: {
        _21 = copy_after_field_assign_after_fu_move() -> bb21;
    }

    bb21: {
        _22 = borrow_after_assign_after_move() -> bb22;
    }

    bb22: {
        _23 = borrow_after_assign_after_fu_move() -> bb23;
    }

    bb23: {
        _24 = borrow_after_field_assign_after_move() -> bb24;
    }

    bb24: {
        _25 = borrow_after_field_assign_after_fu_move() -> bb25;
    }

    bb25: {
        _26 = move_after_assign_after_move() -> bb26;
    }

    bb26: {
        _27 = move_after_assign_after_fu_move() -> bb27;
    }

    bb27: {
        _28 = move_after_field_assign_after_move() -> bb28;
    }

    bb28: {
        _29 = move_after_field_assign_after_fu_move() -> bb29;
    }

    bb29: {
        _30 = copy_after_assign_after_uninit() -> bb30;
    }

    bb30: {
        _31 = borrow_after_assign_after_uninit() -> bb31;
    }

    bb31: {
        _32 = move_after_assign_after_uninit() -> bb32;
    }

    bb32: {
        return;
    }
}
