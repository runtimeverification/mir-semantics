// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
const PRINT: bool = {
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let _1: ContextData;
    let mut _3: std::boxed::Box<[S2<'_>]>;
    let mut _4: std::boxed::Box<[S2<'_>; 4]>;
    let mut _5: usize;
    let mut _6: usize;
    let mut _7: *mut u8;
    let mut _8: std::boxed::Box<[S2<'_>; 4]>;
    let mut _9: S2<'_>;
    let mut _10: S2<'_>;
    let mut _11: S2<'_>;
    let mut _12: S2<'_>;
    let _13: ();
    let mut _14: &std::cell::Cell<(std::option::Option<&S2<'_>>, std::option::Option<&S2<'_>>)>;
    let _15: &S2<'_>;
    let mut _16: &std::vec::Vec<S2<'_>>;
    let mut _17: (std::option::Option<&S2<'_>>, std::option::Option<&S2<'_>>);
    let mut _18: std::option::Option<&S2<'_>>;
    let _19: &S2<'_>;
    let _20: &S2<'_>;
    let mut _21: &std::vec::Vec<S2<'_>>;
    let mut _22: std::option::Option<&S2<'_>>;
    let _23: &S2<'_>;
    let _24: &S2<'_>;
    let mut _25: &std::vec::Vec<S2<'_>>;
    let _26: ();
    let mut _27: &std::cell::Cell<(std::option::Option<&S2<'_>>, std::option::Option<&S2<'_>>)>;
    let _28: &S2<'_>;
    let mut _29: &std::vec::Vec<S2<'_>>;
    let mut _30: (std::option::Option<&S2<'_>>, std::option::Option<&S2<'_>>);
    let mut _31: std::option::Option<&S2<'_>>;
    let _32: &S2<'_>;
    let _33: &S2<'_>;
    let mut _34: &std::vec::Vec<S2<'_>>;
    let mut _35: std::option::Option<&S2<'_>>;
    let _36: ();
    let mut _37: &std::cell::Cell<(std::option::Option<&S2<'_>>, std::option::Option<&S2<'_>>)>;
    let _38: &S2<'_>;
    let mut _39: &std::vec::Vec<S2<'_>>;
    let mut _40: (std::option::Option<&S2<'_>>, std::option::Option<&S2<'_>>);
    let mut _41: std::option::Option<&S2<'_>>;
    let _42: &S2<'_>;
    let _43: &S2<'_>;
    let mut _44: &std::vec::Vec<S2<'_>>;
    let mut _45: std::option::Option<&S2<'_>>;
    let _46: ();
    let mut _47: &std::cell::Cell<(std::option::Option<&S2<'_>>, std::option::Option<&S2<'_>>)>;
    let _48: &S2<'_>;
    let mut _49: &std::vec::Vec<S2<'_>>;
    let mut _50: (std::option::Option<&S2<'_>>, std::option::Option<&S2<'_>>);
    let mut _51: std::option::Option<&S2<'_>>;
    let mut _52: std::option::Option<&S2<'_>>;
    let mut _54: &ContextData;
    let mut _55: bool;
    let mut _56: bool;
    let mut _57: bool;
    let mut _58: !;
    let _59: ();
    let mut _60: &S2<'_>;
    let _61: &S2<'_>;
    let mut _62: &std::vec::Vec<S2<'_>>;
    let mut _63: &mut ContextData;
    let mut _64: bool;
    let mut _65: bool;
    let mut _66: bool;
    let mut _67: !;
    let mut _68: bool;
    let _69: ();
    let mut _70: std::fmt::Arguments<'_>;
    let mut _71: &[&str];
    let _72: &[&str; 1];
    let _73: [&str; 1];
    let mut _75: std::boxed::Box<[S<'_>]>;
    let mut _76: std::boxed::Box<[S<'_>; 2]>;
    let mut _77: usize;
    let mut _78: usize;
    let mut _79: *mut u8;
    let mut _80: std::boxed::Box<[S<'_>; 2]>;
    let mut _81: S<'_>;
    let mut _82: S<'_>;
    let _83: ();
    let mut _84: &std::cell::Cell<std::option::Option<&S<'_>>>;
    let _85: &S<'_>;
    let mut _86: &std::vec::Vec<S<'_>>;
    let mut _87: std::option::Option<&S<'_>>;
    let _88: &S<'_>;
    let _89: &S<'_>;
    let mut _90: &std::vec::Vec<S<'_>>;
    let _91: ();
    let mut _92: &std::cell::Cell<std::option::Option<&S<'_>>>;
    let _93: &S<'_>;
    let mut _94: &std::vec::Vec<S<'_>>;
    let mut _95: std::option::Option<&S<'_>>;
    let _96: &S<'_>;
    let _97: &S<'_>;
    let mut _98: &std::vec::Vec<S<'_>>;
    let mut _100: &ContextData;
    let mut _101: bool;
    let mut _102: bool;
    let mut _103: bool;
    let mut _104: !;
    let _105: ();
    let mut _106: &S<'_>;
    let _107: &S<'_>;
    let mut _108: &std::vec::Vec<S<'_>>;
    let mut _109: &mut ContextData;
    let mut _110: bool;
    let mut _111: bool;
    let mut _112: !;
    let mut _113: bool;
    let _114: ();
    let mut _115: std::fmt::Arguments<'_>;
    let mut _116: &[&str];
    let _117: &[&str; 1];
    let _118: [&str; 1];
    let _120: ();
    let mut _121: &std::cell::Cell<std::option::Option<&V<'_>>>;
    let _122: &std::cell::Cell<std::option::Option<&V<'_>>>;
    let mut _123: &std::vec::Vec<std::cell::Cell<std::option::Option<&V<'_>>>>;
    let mut _124: std::option::Option<&V<'_>>;
    let _125: &V<'_>;
    let _126: ();
    let mut _127: &std::cell::Cell<std::option::Option<&V<'_>>>;
    let _128: &std::cell::Cell<std::option::Option<&V<'_>>>;
    let mut _129: &std::vec::Vec<std::cell::Cell<std::option::Option<&V<'_>>>>;
    let mut _130: std::option::Option<&V<'_>>;
    let _131: &V<'_>;
    let mut _133: &ContextData;
    let mut _134: bool;
    let mut _135: bool;
    let mut _136: bool;
    let mut _137: !;
    let _138: ();
    let mut _139: &V<'_>;
    let mut _140: &mut ContextData;
    let mut _141: bool;
    let mut _142: bool;
    let mut _143: !;
    let mut _144: bool;
    let _145: ();
    let mut _146: std::fmt::Arguments<'_>;
    let mut _147: &[&str];
    let _148: &[&str; 1];
    let _149: [&str; 1];
    let _151: std::option::Option<H<'_>>;
    let mut _152: &mut std::collections::HashMap<H<'_>, H<'_>>;
    let mut _153: H<'_>;
    let mut _154: H<'_>;
    let _155: std::option::Option<H<'_>>;
    let mut _156: &mut std::collections::HashMap<H<'_>, H<'_>>;
    let mut _157: H<'_>;
    let mut _158: H<'_>;
    let mut _159: std::collections::hash_map::Iter<'_, H<'_>, H<'_>>;
    let mut _160: std::collections::hash_map::Iter<'_, H<'_>, H<'_>>;
    let mut _161: &std::collections::HashMap<H<'_>, H<'_>>;
    let mut _163: std::option::Option<(&H<'_>, &H<'_>)>;
    let mut _164: &mut std::collections::hash_map::Iter<'_, H<'_>, H<'_>>;
    let mut _165: isize;
    let _168: ();
    let mut _169: &std::cell::Cell<std::option::Option<&H<'_>>>;
    let mut _170: std::option::Option<&H<'_>>;
    let _171: ();
    let mut _172: &std::cell::Cell<std::option::Option<&H<'_>>>;
    let mut _173: std::option::Option<&H<'_>>;
    let mut _175: &ContextData;
    let mut _176: std::collections::hash_map::Iter<'_, H<'_>, H<'_>>;
    let mut _177: std::collections::hash_map::Iter<'_, H<'_>, H<'_>>;
    let mut _178: &std::collections::HashMap<H<'_>, H<'_>>;
    let mut _180: std::option::Option<(&H<'_>, &H<'_>)>;
    let mut _181: &mut std::collections::hash_map::Iter<'_, H<'_>, H<'_>>;
    let mut _182: isize;
    let _184: ();
    let mut _185: &mut ContextData;
    let mut _186: bool;
    let mut _187: bool;
    let mut _188: !;
    let mut _189: bool;
    let _190: ();
    let mut _191: std::fmt::Arguments<'_>;
    let mut _192: &[&str];
    let _193: &[&str; 1];
    let _194: [&str; 1];
    let _196: std::option::Option<HM<'_>>;
    let mut _197: &mut std::collections::HashMap<HM<'_>, HM<'_>>;
    let mut _198: HM<'_>;
    let mut _199: HM<'_>;
    let _200: std::option::Option<HM<'_>>;
    let mut _201: &mut std::collections::HashMap<HM<'_>, HM<'_>>;
    let mut _202: HM<'_>;
    let mut _203: HM<'_>;
    let mut _204: std::collections::hash_map::Iter<'_, HM<'_>, HM<'_>>;
    let mut _205: std::collections::hash_map::Iter<'_, HM<'_>, HM<'_>>;
    let mut _206: &std::collections::HashMap<HM<'_>, HM<'_>>;
    let mut _208: std::option::Option<(&HM<'_>, &HM<'_>)>;
    let mut _209: &mut std::collections::hash_map::Iter<'_, HM<'_>, HM<'_>>;
    let mut _210: isize;
    let _213: ();
    let mut _214: &std::cell::Cell<std::option::Option<&std::collections::HashMap<HM<'_>, HM<'_>>>>;
    let mut _215: std::option::Option<&std::collections::HashMap<HM<'_>, HM<'_>>>;
    let _216: &std::collections::HashMap<HM<'_>, HM<'_>>;
    let _217: ();
    let mut _218: &std::cell::Cell<std::option::Option<&std::collections::HashMap<HM<'_>, HM<'_>>>>;
    let mut _219: std::option::Option<&std::collections::HashMap<HM<'_>, HM<'_>>>;
    let _220: &std::collections::HashMap<HM<'_>, HM<'_>>;
    let mut _222: &ContextData;
    let mut _223: std::collections::hash_map::Iter<'_, HM<'_>, HM<'_>>;
    let mut _224: std::collections::hash_map::Iter<'_, HM<'_>, HM<'_>>;
    let mut _225: &std::collections::HashMap<HM<'_>, HM<'_>>;
    let mut _227: std::option::Option<(&HM<'_>, &HM<'_>)>;
    let mut _228: &mut std::collections::hash_map::Iter<'_, HM<'_>, HM<'_>>;
    let mut _229: isize;
    let _231: ();
    let mut _232: &mut ContextData;
    let mut _233: bool;
    let mut _234: bool;
    let mut _235: !;
    let mut _236: bool;
    let _237: ();
    let mut _238: std::fmt::Arguments<'_>;
    let mut _239: &[&str];
    let _240: &[&str; 1];
    let _241: [&str; 1];
    let _243: ();
    let mut _244: &mut std::collections::VecDeque<S<'_>>;
    let mut _245: S<'_>;
    let _246: ();
    let mut _247: &mut std::collections::VecDeque<S<'_>>;
    let mut _248: S<'_>;
    let _249: ();
    let mut _250: &std::cell::Cell<std::option::Option<&S<'_>>>;
    let _251: &S<'_>;
    let mut _252: &std::collections::VecDeque<S<'_>>;
    let mut _253: std::option::Option<&S<'_>>;
    let _254: &S<'_>;
    let _255: &S<'_>;
    let mut _256: &std::collections::VecDeque<S<'_>>;
    let _257: ();
    let mut _258: &std::cell::Cell<std::option::Option<&S<'_>>>;
    let _259: &S<'_>;
    let mut _260: &std::collections::VecDeque<S<'_>>;
    let mut _261: std::option::Option<&S<'_>>;
    let _262: &S<'_>;
    let _263: &S<'_>;
    let mut _264: &std::collections::VecDeque<S<'_>>;
    let mut _266: &ContextData;
    let mut _267: bool;
    let mut _268: bool;
    let mut _269: bool;
    let mut _270: !;
    let _271: ();
    let mut _272: &S<'_>;
    let _273: &S<'_>;
    let mut _274: &std::collections::VecDeque<S<'_>>;
    let mut _275: &mut ContextData;
    let mut _276: bool;
    let mut _277: bool;
    let mut _278: !;
    let mut _279: bool;
    let _280: ();
    let mut _281: std::fmt::Arguments<'_>;
    let mut _282: &[&str];
    let _283: &[&str; 1];
    let _284: [&str; 1];
    let _286: ();
    let mut _287: &mut std::collections::VecDeque<VD<'_>>;
    let mut _288: VD<'_>;
    let _289: ();
    let mut _290: &mut std::collections::VecDeque<VD<'_>>;
    let mut _291: VD<'_>;
    let _292: ();
    let mut _293: &std::cell::Cell<std::option::Option<&std::collections::VecDeque<VD<'_>>>>;
    let _294: &VD<'_>;
    let mut _295: &std::collections::VecDeque<VD<'_>>;
    let mut _296: std::option::Option<&std::collections::VecDeque<VD<'_>>>;
    let _297: &std::collections::VecDeque<VD<'_>>;
    let _298: ();
    let mut _299: &std::cell::Cell<std::option::Option<&std::collections::VecDeque<VD<'_>>>>;
    let _300: &VD<'_>;
    let mut _301: &std::collections::VecDeque<VD<'_>>;
    let mut _302: std::option::Option<&std::collections::VecDeque<VD<'_>>>;
    let _303: &std::collections::VecDeque<VD<'_>>;
    let mut _305: &ContextData;
    let mut _306: bool;
    let mut _307: bool;
    let mut _308: bool;
    let mut _309: !;
    let _310: ();
    let mut _311: &VD<'_>;
    let _312: &VD<'_>;
    let mut _313: &std::collections::VecDeque<VD<'_>>;
    let mut _314: &mut ContextData;
    let mut _315: bool;
    let mut _316: bool;
    let mut _317: !;
    let mut _318: bool;
    let _319: ();
    let mut _320: std::fmt::Arguments<'_>;
    let mut _321: &[&str];
    let _322: &[&str; 1];
    let _323: [&str; 1];
    let _325: std::option::Option<VM<'_>>;
    let mut _326: &mut std::collections::HashMap<usize, VM<'_>>;
    let mut _327: VM<'_>;
    let _328: std::option::Option<VM<'_>>;
    let mut _329: &mut std::collections::HashMap<usize, VM<'_>>;
    let mut _330: VM<'_>;
    let _331: ();
    let mut _332: &std::cell::Cell<std::option::Option<&std::collections::HashMap<usize, VM<'_>>>>;
    let _333: &VM<'_>;
    let mut _334: &std::collections::HashMap<usize, VM<'_>>;
    let _335: &usize;
    let _336: usize;
    let mut _337: std::option::Option<&std::collections::HashMap<usize, VM<'_>>>;
    let _338: &std::collections::HashMap<usize, VM<'_>>;
    let _339: ();
    let mut _340: &std::cell::Cell<std::option::Option<&std::collections::HashMap<usize, VM<'_>>>>;
    let _341: &VM<'_>;
    let mut _342: &std::collections::HashMap<usize, VM<'_>>;
    let _343: &usize;
    let _344: usize;
    let mut _345: std::option::Option<&std::collections::HashMap<usize, VM<'_>>>;
    let _346: &std::collections::HashMap<usize, VM<'_>>;
    let mut _348: &ContextData;
    let mut _349: bool;
    let mut _350: bool;
    let mut _351: bool;
    let mut _352: !;
    let _353: ();
    let mut _354: &VM<'_>;
    let _355: &VM<'_>;
    let mut _356: &std::collections::HashMap<usize, VM<'_>>;
    let _357: &usize;
    let _358: usize;
    let mut _359: &mut ContextData;
    let mut _360: bool;
    let mut _361: bool;
    let mut _362: !;
    let mut _363: bool;
    let _364: ();
    let mut _365: std::fmt::Arguments<'_>;
    let mut _366: &[&str];
    let _367: &[&str; 1];
    let _368: [&str; 1];
    let _370: ();
    let mut _371: &mut std::collections::LinkedList<LL<'_>>;
    let mut _372: LL<'_>;
    let _373: ();
    let mut _374: &mut std::collections::LinkedList<LL<'_>>;
    let mut _375: LL<'_>;
    let mut _376: std::collections::linked_list::Iter<'_, LL<'_>>;
    let mut _377: &std::collections::LinkedList<LL<'_>>;
    let mut _379: std::option::Option<&LL<'_>>;
    let mut _380: &mut std::collections::linked_list::Iter<'_, LL<'_>>;
    let mut _381: isize;
    let _383: ();
    let mut _384: &std::cell::Cell<std::option::Option<&std::collections::LinkedList<LL<'_>>>>;
    let mut _385: std::option::Option<&std::collections::LinkedList<LL<'_>>>;
    let _386: &std::collections::LinkedList<LL<'_>>;
    let mut _388: &ContextData;
    let mut _389: std::collections::linked_list::Iter<'_, LL<'_>>;
    let mut _390: &std::collections::LinkedList<LL<'_>>;
    let mut _392: std::option::Option<&LL<'_>>;
    let mut _393: &mut std::collections::linked_list::Iter<'_, LL<'_>>;
    let mut _394: isize;
    let _396: ();
    let mut _397: &mut ContextData;
    let mut _398: bool;
    let mut _399: bool;
    let mut _400: !;
    let mut _401: bool;
    let _402: ();
    let mut _403: std::fmt::Arguments<'_>;
    let mut _404: &[&str];
    let _405: &[&str; 1];
    let _406: [&str; 1];
    let _408: ();
    let mut _409: &mut std::collections::BinaryHeap<BH<'_>>;
    let mut _410: BH<'_>;
    let _411: ();
    let mut _412: &mut std::collections::BinaryHeap<BH<'_>>;
    let mut _413: BH<'_>;
    let mut _414: std::collections::binary_heap::Iter<'_, BH<'_>>;
    let mut _415: std::collections::binary_heap::Iter<'_, BH<'_>>;
    let mut _416: &std::collections::BinaryHeap<BH<'_>>;
    let mut _418: std::option::Option<&BH<'_>>;
    let mut _419: &mut std::collections::binary_heap::Iter<'_, BH<'_>>;
    let mut _420: isize;
    let _422: ();
    let mut _423: &std::cell::Cell<std::option::Option<&std::collections::BinaryHeap<BH<'_>>>>;
    let mut _424: std::option::Option<&std::collections::BinaryHeap<BH<'_>>>;
    let _425: &std::collections::BinaryHeap<BH<'_>>;
    let mut _427: &ContextData;
    let mut _428: std::collections::binary_heap::Iter<'_, BH<'_>>;
    let mut _429: &std::collections::BinaryHeap<BH<'_>>;
    let mut _431: std::option::Option<&BH<'_>>;
    let mut _432: &mut std::collections::binary_heap::Iter<'_, BH<'_>>;
    let mut _433: isize;
    let _435: ();
    let mut _436: &mut ContextData;
    let mut _437: bool;
    let mut _438: bool;
    let mut _439: !;
    let mut _440: bool;
    let _441: ();
    let mut _442: std::fmt::Arguments<'_>;
    let mut _443: &[&str];
    let _444: &[&str; 1];
    let _445: [&str; 1];
    let _447: std::option::Option<BTM<'_>>;
    let mut _448: &mut std::collections::BTreeMap<BTM<'_>, BTM<'_>>;
    let mut _449: BTM<'_>;
    let mut _450: BTM<'_>;
    let _451: std::option::Option<BTM<'_>>;
    let mut _452: &mut std::collections::BTreeMap<BTM<'_>, BTM<'_>>;
    let mut _453: BTM<'_>;
    let mut _454: BTM<'_>;
    let mut _455: std::collections::btree_map::Iter<'_, BTM<'_>, BTM<'_>>;
    let mut _456: std::collections::btree_map::Iter<'_, BTM<'_>, BTM<'_>>;
    let mut _457: &std::collections::BTreeMap<BTM<'_>, BTM<'_>>;
    let mut _459: std::option::Option<(&BTM<'_>, &BTM<'_>)>;
    let mut _460: &mut std::collections::btree_map::Iter<'_, BTM<'_>, BTM<'_>>;
    let mut _461: isize;
    let _464: ();
    let mut _465: &std::cell::Cell<std::option::Option<&std::collections::BTreeMap<BTM<'_>, BTM<'_>>>>;
    let mut _466: std::option::Option<&std::collections::BTreeMap<BTM<'_>, BTM<'_>>>;
    let _467: &std::collections::BTreeMap<BTM<'_>, BTM<'_>>;
    let _468: ();
    let mut _469: &std::cell::Cell<std::option::Option<&std::collections::BTreeMap<BTM<'_>, BTM<'_>>>>;
    let mut _470: std::option::Option<&std::collections::BTreeMap<BTM<'_>, BTM<'_>>>;
    let _471: &std::collections::BTreeMap<BTM<'_>, BTM<'_>>;
    let mut _473: &ContextData;
    let mut _474: std::collections::btree_map::Iter<'_, BTM<'_>, BTM<'_>>;
    let mut _475: &std::collections::BTreeMap<BTM<'_>, BTM<'_>>;
    let mut _477: std::option::Option<(&BTM<'_>, &BTM<'_>)>;
    let mut _478: &mut std::collections::btree_map::Iter<'_, BTM<'_>, BTM<'_>>;
    let mut _479: isize;
    let _481: ();
    let mut _482: &mut ContextData;
    let mut _483: bool;
    let mut _484: bool;
    let mut _485: !;
    let mut _486: bool;
    let _487: ();
    let mut _488: std::fmt::Arguments<'_>;
    let mut _489: &[&str];
    let _490: &[&str; 1];
    let _491: [&str; 1];
    let _493: bool;
    let mut _494: &mut std::collections::BTreeSet<BTS<'_>>;
    let mut _495: BTS<'_>;
    let _496: bool;
    let mut _497: &mut std::collections::BTreeSet<BTS<'_>>;
    let mut _498: BTS<'_>;
    let mut _499: std::collections::btree_set::Iter<'_, BTS<'_>>;
    let mut _500: std::collections::btree_set::Iter<'_, BTS<'_>>;
    let mut _501: &std::collections::BTreeSet<BTS<'_>>;
    let mut _503: std::option::Option<&BTS<'_>>;
    let mut _504: &mut std::collections::btree_set::Iter<'_, BTS<'_>>;
    let mut _505: isize;
    let _507: ();
    let mut _508: &std::cell::Cell<std::option::Option<&std::collections::BTreeSet<BTS<'_>>>>;
    let mut _509: std::option::Option<&std::collections::BTreeSet<BTS<'_>>>;
    let _510: &std::collections::BTreeSet<BTS<'_>>;
    let mut _512: &ContextData;
    let mut _513: std::collections::btree_set::Iter<'_, BTS<'_>>;
    let mut _514: &std::collections::BTreeSet<BTS<'_>>;
    let mut _516: std::option::Option<&BTS<'_>>;
    let mut _517: &mut std::collections::btree_set::Iter<'_, BTS<'_>>;
    let mut _518: isize;
    let _520: ();
    let mut _521: &mut ContextData;
    let mut _522: bool;
    let mut _523: bool;
    let mut _524: !;
    let mut _525: bool;
    let _526: ();
    let mut _527: std::fmt::Arguments<'_>;
    let mut _528: &[&str];
    let _529: &[&str; 1];
    let _530: [&str; 1];
    let mut _534: RCRC<'_>;
    let mut _535: RCRC<'_>;
    let mut _536: RCRC<'_>;
    let mut _537: std::option::Option<&RCRC<'_>>;
    let _538: &RCRC<'_>;
    let mut _539: &mut RCRCData<'_>;
    let mut _540: &mut std::cell::RefMut<'_, RCRCData<'_>>;
    let mut _541: std::cell::RefMut<'_, RCRCData<'_>>;
    let mut _542: &std::cell::RefCell<RCRCData<'_>>;
    let _543: &std::cell::RefCell<RCRCData<'_>>;
    let mut _544: &std::rc::Rc<std::cell::RefCell<RCRCData<'_>>>;
    let mut _545: std::option::Option<&RCRC<'_>>;
    let _546: &RCRC<'_>;
    let mut _547: &mut RCRCData<'_>;
    let mut _548: &mut std::cell::RefMut<'_, RCRCData<'_>>;
    let mut _549: std::cell::RefMut<'_, RCRCData<'_>>;
    let mut _550: &std::cell::RefCell<RCRCData<'_>>;
    let _551: &std::cell::RefCell<RCRCData<'_>>;
    let mut _552: &std::rc::Rc<std::cell::RefCell<RCRCData<'_>>>;
    let mut _553: std::option::Option<&RCRC<'_>>;
    let _554: &RCRC<'_>;
    let mut _555: &mut RCRCData<'_>;
    let mut _556: &mut std::cell::RefMut<'_, RCRCData<'_>>;
    let mut _557: std::cell::RefMut<'_, RCRCData<'_>>;
    let mut _558: &std::cell::RefCell<RCRCData<'_>>;
    let _559: &std::cell::RefCell<RCRCData<'_>>;
    let mut _560: &std::rc::Rc<std::cell::RefCell<RCRCData<'_>>>;
    let mut _562: &ContextData;
    let mut _563: bool;
    let mut _564: bool;
    let mut _565: bool;
    let mut _566: !;
    let _567: ();
    let mut _568: &RCRC<'_>;
    let mut _569: &mut ContextData;
    let mut _570: bool;
    let mut _571: bool;
    let mut _572: !;
    let mut _573: bool;
    let _574: ();
    let mut _575: std::fmt::Arguments<'_>;
    let mut _576: &[&str];
    let _577: &[&str; 1];
    let _578: [&str; 1];
    let mut _582: ARCRC<'_>;
    let mut _583: ARCRC<'_>;
    let mut _584: ARCRC<'_>;
    let mut _585: std::option::Option<&ARCRC<'_>>;
    let _586: &ARCRC<'_>;
    let mut _587: &mut ARCRCData<'_>;
    let mut _588: &mut std::cell::RefMut<'_, ARCRCData<'_>>;
    let mut _589: std::cell::RefMut<'_, ARCRCData<'_>>;
    let mut _590: &std::cell::RefCell<ARCRCData<'_>>;
    let _591: &std::cell::RefCell<ARCRCData<'_>>;
    let mut _592: &std::sync::Arc<std::cell::RefCell<ARCRCData<'_>>>;
    let mut _593: std::option::Option<&ARCRC<'_>>;
    let _594: &ARCRC<'_>;
    let mut _595: &mut ARCRCData<'_>;
    let mut _596: &mut std::cell::RefMut<'_, ARCRCData<'_>>;
    let mut _597: std::cell::RefMut<'_, ARCRCData<'_>>;
    let mut _598: &std::cell::RefCell<ARCRCData<'_>>;
    let _599: &std::cell::RefCell<ARCRCData<'_>>;
    let mut _600: &std::sync::Arc<std::cell::RefCell<ARCRCData<'_>>>;
    let mut _601: std::option::Option<&ARCRC<'_>>;
    let _602: &ARCRC<'_>;
    let mut _603: &mut ARCRCData<'_>;
    let mut _604: &mut std::cell::RefMut<'_, ARCRCData<'_>>;
    let mut _605: std::cell::RefMut<'_, ARCRCData<'_>>;
    let mut _606: &std::cell::RefCell<ARCRCData<'_>>;
    let _607: &std::cell::RefCell<ARCRCData<'_>>;
    let mut _608: &std::sync::Arc<std::cell::RefCell<ARCRCData<'_>>>;
    let mut _610: &ContextData;
    let mut _611: bool;
    let mut _612: bool;
    let mut _613: bool;
    let mut _614: !;
    let _615: ();
    let mut _616: &ARCRC<'_>;
    let mut _617: &mut ContextData;
    let mut _618: bool;
    let mut _619: bool;
    let mut _620: !;
    let mut _621: bool;
    let _622: ();
    let mut _623: std::fmt::Arguments<'_>;
    let mut _624: &[&str];
    let _625: &[&str; 1];
    let _626: [&str; 1];
    let mut _630: ARCRW<'_>;
    let mut _631: ARCRW<'_>;
    let mut _632: ARCRW<'_>;
    let mut _633: std::option::Option<&ARCRW<'_>>;
    let _634: &ARCRW<'_>;
    let mut _635: &mut ARCRWData<'_>;
    let mut _636: &mut std::sync::RwLockWriteGuard<'_, ARCRWData<'_>>;
    let mut _637: std::sync::RwLockWriteGuard<'_, ARCRWData<'_>>;
    let mut _638: std::result::Result<std::sync::RwLockWriteGuard<'_, ARCRWData<'_>>, std::sync::PoisonError<std::sync::RwLockWriteGuard<'_, ARCRWData<'_>>>>;
    let mut _639: &std::sync::RwLock<ARCRWData<'_>>;
    let _640: &std::sync::RwLock<ARCRWData<'_>>;
    let mut _641: &std::sync::Arc<std::sync::RwLock<ARCRWData<'_>>>;
    let mut _642: std::option::Option<&ARCRW<'_>>;
    let _643: &ARCRW<'_>;
    let mut _644: &mut ARCRWData<'_>;
    let mut _645: &mut std::sync::RwLockWriteGuard<'_, ARCRWData<'_>>;
    let mut _646: std::sync::RwLockWriteGuard<'_, ARCRWData<'_>>;
    let mut _647: std::result::Result<std::sync::RwLockWriteGuard<'_, ARCRWData<'_>>, std::sync::PoisonError<std::sync::RwLockWriteGuard<'_, ARCRWData<'_>>>>;
    let mut _648: &std::sync::RwLock<ARCRWData<'_>>;
    let _649: &std::sync::RwLock<ARCRWData<'_>>;
    let mut _650: &std::sync::Arc<std::sync::RwLock<ARCRWData<'_>>>;
    let mut _651: std::option::Option<&ARCRW<'_>>;
    let _652: &ARCRW<'_>;
    let mut _653: &mut ARCRWData<'_>;
    let mut _654: &mut std::sync::RwLockWriteGuard<'_, ARCRWData<'_>>;
    let mut _655: std::sync::RwLockWriteGuard<'_, ARCRWData<'_>>;
    let mut _656: std::result::Result<std::sync::RwLockWriteGuard<'_, ARCRWData<'_>>, std::sync::PoisonError<std::sync::RwLockWriteGuard<'_, ARCRWData<'_>>>>;
    let mut _657: &std::sync::RwLock<ARCRWData<'_>>;
    let _658: &std::sync::RwLock<ARCRWData<'_>>;
    let mut _659: &std::sync::Arc<std::sync::RwLock<ARCRWData<'_>>>;
    let mut _661: &ContextData;
    let mut _662: bool;
    let mut _663: bool;
    let mut _664: bool;
    let mut _665: !;
    let _666: ();
    let mut _667: &ARCRW<'_>;
    let mut _668: &mut ContextData;
    let mut _669: bool;
    let mut _670: bool;
    let mut _671: !;
    let mut _672: bool;
    let _673: ();
    let mut _674: std::fmt::Arguments<'_>;
    let mut _675: &[&str];
    let _676: &[&str; 1];
    let _677: [&str; 1];
    let mut _681: ARCM<'_>;
    let mut _682: ARCM<'_>;
    let mut _683: ARCM<'_>;
    let mut _684: std::option::Option<&ARCM<'_>>;
    let _685: &ARCM<'_>;
    let mut _686: &mut ARCMData<'_>;
    let mut _687: &mut std::sync::MutexGuard<'_, ARCMData<'_>>;
    let mut _688: std::sync::MutexGuard<'_, ARCMData<'_>>;
    let mut _689: std::result::Result<std::sync::MutexGuard<'_, ARCMData<'_>>, std::sync::PoisonError<std::sync::MutexGuard<'_, ARCMData<'_>>>>;
    let mut _690: &std::sync::Mutex<ARCMData<'_>>;
    let _691: &std::sync::Mutex<ARCMData<'_>>;
    let mut _692: &std::sync::Arc<std::sync::Mutex<ARCMData<'_>>>;
    let mut _693: std::option::Option<&ARCM<'_>>;
    let _694: &ARCM<'_>;
    let mut _695: &mut ARCMData<'_>;
    let mut _696: &mut std::sync::MutexGuard<'_, ARCMData<'_>>;
    let mut _697: std::sync::MutexGuard<'_, ARCMData<'_>>;
    let mut _698: std::result::Result<std::sync::MutexGuard<'_, ARCMData<'_>>, std::sync::PoisonError<std::sync::MutexGuard<'_, ARCMData<'_>>>>;
    let mut _699: &std::sync::Mutex<ARCMData<'_>>;
    let _700: &std::sync::Mutex<ARCMData<'_>>;
    let mut _701: &std::sync::Arc<std::sync::Mutex<ARCMData<'_>>>;
    let mut _702: std::option::Option<&ARCM<'_>>;
    let _703: &ARCM<'_>;
    let mut _704: &mut ARCMData<'_>;
    let mut _705: &mut std::sync::MutexGuard<'_, ARCMData<'_>>;
    let mut _706: std::sync::MutexGuard<'_, ARCMData<'_>>;
    let mut _707: std::result::Result<std::sync::MutexGuard<'_, ARCMData<'_>>, std::sync::PoisonError<std::sync::MutexGuard<'_, ARCMData<'_>>>>;
    let mut _708: &std::sync::Mutex<ARCMData<'_>>;
    let _709: &std::sync::Mutex<ARCMData<'_>>;
    let mut _710: &std::sync::Arc<std::sync::Mutex<ARCMData<'_>>>;
    let mut _712: &ContextData;
    let mut _713: bool;
    let mut _714: bool;
    let mut _715: bool;
    let mut _716: !;
    let _717: ();
    let mut _718: &ARCM<'_>;
    let mut _719: &mut ContextData;
    let mut _720: bool;
    let mut _721: bool;
    let mut _722: !;
    let mut _723: bool;
    let mut _724: bool;
    let mut _725: bool;
    let mut _726: bool;
    let mut _727: bool;
    let mut _728: bool;
    let mut _729: bool;
    let mut _730: bool;
    let mut _731: bool;
    let mut _732: bool;
    let mut _733: bool;
    let mut _734: bool;
    let mut _735: &mut std::boxed::Box<[S<'_>; 2]>;
    let mut _736: ();
    let mut _737: &mut std::boxed::Box<[S2<'_>; 4]>;
    let mut _738: ();
    let mut _739: *const [S2<'_>; 4];
    let mut _740: *const [S<'_>; 2];
    scope 1 {
        debug c_orig => _1;
        let _2: std::vec::Vec<S2<'_>>;
        let mut _747: *const ();
        let mut _748: usize;
        let mut _749: usize;
        let mut _750: usize;
        let mut _751: usize;
        let mut _752: bool;
        scope 2 {
            debug v => _2;
            let mut _53: ContextData;
            scope 4 {
                debug c => _53;
                let _74: std::vec::Vec<S<'_>>;
                let mut _741: *const ();
                let mut _742: usize;
                let mut _743: usize;
                let mut _744: usize;
                let mut _745: usize;
                let mut _746: bool;
                scope 5 {
                    debug v => _74;
                    let mut _99: ContextData;
                    scope 7 {
                        debug c => _99;
                        let _119: V<'_>;
                        scope 8 {
                            debug v => _119;
                            let mut _132: ContextData;
                            scope 9 {
                                debug c => _132;
                                let mut _150: std::collections::HashMap<H<'_>, H<'_>>;
                                scope 10 {
                                    debug h => _150;
                                    let mut _162: std::collections::hash_map::Iter<'_, H<'_>, H<'_>>;
                                    let mut _174: ContextData;
                                    scope 11 {
                                        debug iter => _162;
                                        let _166: &H<'_>;
                                        let _167: &H<'_>;
                                        scope 12 {
                                            debug key => _166;
                                            debug val => _167;
                                        }
                                    }
                                    scope 13 {
                                        debug c => _174;
                                        let mut _179: std::collections::hash_map::Iter<'_, H<'_>, H<'_>>;
                                        let mut _195: std::collections::HashMap<HM<'_>, HM<'_>>;
                                        scope 14 {
                                            debug iter => _179;
                                            let _183: &H<'_>;
                                            scope 15 {
                                                debug key => _183;
                                            }
                                        }
                                        scope 16 {
                                            debug h => _195;
                                            let mut _207: std::collections::hash_map::Iter<'_, HM<'_>, HM<'_>>;
                                            let mut _221: ContextData;
                                            scope 17 {
                                                debug iter => _207;
                                                let _211: &HM<'_>;
                                                let _212: &HM<'_>;
                                                scope 18 {
                                                    debug key => _211;
                                                    debug val => _212;
                                                }
                                            }
                                            scope 19 {
                                                debug c => _221;
                                                let mut _226: std::collections::hash_map::Iter<'_, HM<'_>, HM<'_>>;
                                                let mut _242: std::collections::VecDeque<S<'_>>;
                                                scope 20 {
                                                    debug iter => _226;
                                                    let _230: &HM<'_>;
                                                    scope 21 {
                                                        debug key => _230;
                                                    }
                                                }
                                                scope 22 {
                                                    debug vd => _242;
                                                    let mut _265: ContextData;
                                                    scope 23 {
                                                        debug c => _265;
                                                        let mut _285: std::collections::VecDeque<VD<'_>>;
                                                        scope 24 {
                                                            debug vd => _285;
                                                            let mut _304: ContextData;
                                                            scope 25 {
                                                                debug c => _304;
                                                                let mut _324: std::collections::HashMap<usize, VM<'_>>;
                                                                scope 26 {
                                                                    debug vm => _324;
                                                                    let mut _347: ContextData;
                                                                    scope 27 {
                                                                        debug c => _347;
                                                                        let mut _369: std::collections::LinkedList<LL<'_>>;
                                                                        scope 28 {
                                                                            debug ll => _369;
                                                                            let mut _378: std::collections::linked_list::Iter<'_, LL<'_>>;
                                                                            let mut _387: ContextData;
                                                                            scope 29 {
                                                                                debug iter => _378;
                                                                                let _382: &LL<'_>;
                                                                                scope 30 {
                                                                                    debug e => _382;
                                                                                }
                                                                            }
                                                                            scope 31 {
                                                                                debug c => _387;
                                                                                let mut _391: std::collections::linked_list::Iter<'_, LL<'_>>;
                                                                                let mut _407: std::collections::BinaryHeap<BH<'_>>;
                                                                                scope 32 {
                                                                                    debug iter => _391;
                                                                                    let _395: &LL<'_>;
                                                                                    scope 33 {
                                                                                        debug e => _395;
                                                                                    }
                                                                                }
                                                                                scope 34 {
                                                                                    debug bh => _407;
                                                                                    let mut _417: std::collections::binary_heap::Iter<'_, BH<'_>>;
                                                                                    let mut _426: ContextData;
                                                                                    scope 35 {
                                                                                        debug iter => _417;
                                                                                        let _421: &BH<'_>;
                                                                                        scope 36 {
                                                                                            debug b => _421;
                                                                                        }
                                                                                    }
                                                                                    scope 37 {
                                                                                        debug c => _426;
                                                                                        let mut _430: std::collections::binary_heap::Iter<'_, BH<'_>>;
                                                                                        let mut _446: std::collections::BTreeMap<BTM<'_>, BTM<'_>>;
                                                                                        scope 38 {
                                                                                            debug iter => _430;
                                                                                            let _434: &BH<'_>;
                                                                                            scope 39 {
                                                                                                debug b => _434;
                                                                                            }
                                                                                        }
                                                                                        scope 40 {
                                                                                            debug btm => _446;
                                                                                            let mut _458: std::collections::btree_map::Iter<'_, BTM<'_>, BTM<'_>>;
                                                                                            let mut _472: ContextData;
                                                                                            scope 41 {
                                                                                                debug iter => _458;
                                                                                                let _462: &BTM<'_>;
                                                                                                let _463: &BTM<'_>;
                                                                                                scope 42 {
                                                                                                    debug k => _462;
                                                                                                    debug v => _463;
                                                                                                }
                                                                                            }
                                                                                            scope 43 {
                                                                                                debug c => _472;
                                                                                                let mut _476: std::collections::btree_map::Iter<'_, BTM<'_>, BTM<'_>>;
                                                                                                let mut _492: std::collections::BTreeSet<BTS<'_>>;
                                                                                                scope 44 {
                                                                                                    debug iter => _476;
                                                                                                    let _480: &BTM<'_>;
                                                                                                    scope 45 {
                                                                                                        debug k => _480;
                                                                                                    }
                                                                                                }
                                                                                                scope 46 {
                                                                                                    debug bts => _492;
                                                                                                    let mut _502: std::collections::btree_set::Iter<'_, BTS<'_>>;
                                                                                                    let mut _511: ContextData;
                                                                                                    scope 47 {
                                                                                                        debug iter => _502;
                                                                                                        let _506: &BTS<'_>;
                                                                                                        scope 48 {
                                                                                                            debug v => _506;
                                                                                                        }
                                                                                                    }
                                                                                                    scope 49 {
                                                                                                        debug c => _511;
                                                                                                        let mut _515: std::collections::btree_set::Iter<'_, BTS<'_>>;
                                                                                                        let _531: RCRC<'_>;
                                                                                                        let _532: RCRC<'_>;
                                                                                                        let _533: RCRC<'_>;
                                                                                                        scope 50 {
                                                                                                            debug iter => _515;
                                                                                                            let _519: &BTS<'_>;
                                                                                                            scope 51 {
                                                                                                                debug b => _519;
                                                                                                            }
                                                                                                        }
                                                                                                        scope 52 {
                                                                                                            debug rc0 => _531;
                                                                                                            debug rc1 => _532;
                                                                                                            debug rc2 => _533;
                                                                                                            let mut _561: ContextData;
                                                                                                            scope 53 {
                                                                                                                debug c => _561;
                                                                                                                let _579: ARCRC<'_>;
                                                                                                                let _580: ARCRC<'_>;
                                                                                                                let _581: ARCRC<'_>;
                                                                                                                scope 54 {
                                                                                                                    debug arc0 => _579;
                                                                                                                    debug arc1 => _580;
                                                                                                                    debug arc2 => _581;
                                                                                                                    let mut _609: ContextData;
                                                                                                                    scope 55 {
                                                                                                                        debug c => _609;
                                                                                                                        let _627: ARCRW<'_>;
                                                                                                                        let _628: ARCRW<'_>;
                                                                                                                        let _629: ARCRW<'_>;
                                                                                                                        scope 56 {
                                                                                                                            debug arc0 => _627;
                                                                                                                            debug arc1 => _628;
                                                                                                                            debug arc2 => _629;
                                                                                                                            let mut _660: ContextData;
                                                                                                                            scope 57 {
                                                                                                                                debug c => _660;
                                                                                                                                let _678: ARCM<'_>;
                                                                                                                                let _679: ARCM<'_>;
                                                                                                                                let _680: ARCM<'_>;
                                                                                                                                scope 58 {
                                                                                                                                    debug arc0 => _678;
                                                                                                                                    debug arc1 => _679;
                                                                                                                                    debug arc2 => _680;
                                                                                                                                    let mut _711: ContextData;
                                                                                                                                    scope 59 {
                                                                                                                                        debug c => _711;
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                scope 6 {
                }
            }
        }
        scope 3 {
        }
    }

    bb0: {
        _734 = const false;
        _733 = const false;
        _732 = const false;
        _731 = const false;
        _730 = const false;
        _729 = const false;
        _728 = const false;
        _727 = const false;
        _726 = const false;
        _725 = const false;
        _724 = const false;
        _723 = const false;
        _1 = ContextData { curr_depth: const 0_usize, max_depth: const 3_usize, visited: const 0_usize, max_visits: const 1000_usize, skipped: const 0_usize, curr_mark: const 0_u32, saw_prev_marked: const false, control_bits: const 0_u64 };
        _5 = SizeOf([S2<'_>; 4]);
        _6 = AlignOf([S2<'_>; 4]);
        _7 = alloc::alloc::exchange_malloc(move _5, move _6) -> bb1;
    }

    bb1: {
        _8 = ShallowInitBox(move _7, [S2<'_>; 4]);
        _9 = <S2<'_> as Named>::new(const "s0") -> [return: bb2, unwind: bb438];
    }

    bb2: {
        _10 = <S2<'_> as Named>::new(const "s1") -> [return: bb3, unwind: bb438];
    }

    bb3: {
        _11 = <S2<'_> as Named>::new(const "s2") -> [return: bb4, unwind: bb438];
    }

    bb4: {
        _12 = <S2<'_> as Named>::new(const "s3") -> [return: bb5, unwind: bb438];
    }

    bb5: {
        _739 = (((_8.0: std::ptr::Unique<[S2<'_>; 4]>).0: std::ptr::NonNull<[S2<'_>; 4]>).0: *const [S2<'_>; 4]);
        _747 = _739 as *const () (PtrToPtr);
        _748 = _747 as usize (Transmute);
        _749 = AlignOf(S2<'_>);
        _750 = Sub(_749, const 1_usize);
        _751 = BitAnd(_748, _750);
        _752 = Eq(_751, const 0_usize);
        assert(_752, "misaligned pointer dereference: address must be a multiple of {} but is {}", _749, _748) -> [success: bb440, unwind unreachable];
    }

    bb6: {
        _16 = &_2;
        _15 = <Vec<S2<'_>> as Index<usize>>::index(move _16, const 0_usize) -> [return: bb7, unwind: bb411];
    }

    bb7: {
        _14 = &((*_15).2: std::cell::Cell<(std::option::Option<&S2<'_>>, std::option::Option<&S2<'_>>)>);
        _21 = &_2;
        _20 = <Vec<S2<'_>> as Index<usize>>::index(move _21, const 1_usize) -> [return: bb8, unwind: bb411];
    }

    bb8: {
        _19 = _20;
        _18 = Option::<&S2<'_>>::Some(_19);
        _25 = &_2;
        _24 = <Vec<S2<'_>> as Index<usize>>::index(move _25, const 2_usize) -> [return: bb9, unwind: bb411];
    }

    bb9: {
        _23 = _24;
        _22 = Option::<&S2<'_>>::Some(_23);
        _17 = (move _18, move _22);
        _13 = Cell::<(Option<&S2<'_>>, Option<&S2<'_>>)>::set(move _14, move _17) -> [return: bb10, unwind: bb411];
    }

    bb10: {
        _29 = &_2;
        _28 = <Vec<S2<'_>> as Index<usize>>::index(move _29, const 1_usize) -> [return: bb11, unwind: bb411];
    }

    bb11: {
        _27 = &((*_28).2: std::cell::Cell<(std::option::Option<&S2<'_>>, std::option::Option<&S2<'_>>)>);
        _34 = &_2;
        _33 = <Vec<S2<'_>> as Index<usize>>::index(move _34, const 3_usize) -> [return: bb12, unwind: bb411];
    }

    bb12: {
        _32 = _33;
        _31 = Option::<&S2<'_>>::Some(_32);
        _35 = Option::<&S2<'_>>::None;
        _30 = (move _31, move _35);
        _26 = Cell::<(Option<&S2<'_>>, Option<&S2<'_>>)>::set(move _27, move _30) -> [return: bb13, unwind: bb411];
    }

    bb13: {
        _39 = &_2;
        _38 = <Vec<S2<'_>> as Index<usize>>::index(move _39, const 2_usize) -> [return: bb14, unwind: bb411];
    }

    bb14: {
        _37 = &((*_38).2: std::cell::Cell<(std::option::Option<&S2<'_>>, std::option::Option<&S2<'_>>)>);
        _44 = &_2;
        _43 = <Vec<S2<'_>> as Index<usize>>::index(move _44, const 3_usize) -> [return: bb15, unwind: bb411];
    }

    bb15: {
        _42 = _43;
        _41 = Option::<&S2<'_>>::Some(_42);
        _45 = Option::<&S2<'_>>::None;
        _40 = (move _41, move _45);
        _36 = Cell::<(Option<&S2<'_>>, Option<&S2<'_>>)>::set(move _37, move _40) -> [return: bb16, unwind: bb411];
    }

    bb16: {
        _49 = &_2;
        _48 = <Vec<S2<'_>> as Index<usize>>::index(move _49, const 3_usize) -> [return: bb17, unwind: bb411];
    }

    bb17: {
        _47 = &((*_48).2: std::cell::Cell<(std::option::Option<&S2<'_>>, std::option::Option<&S2<'_>>)>);
        _51 = Option::<&S2<'_>>::None;
        _52 = Option::<&S2<'_>>::None;
        _50 = (move _51, move _52);
        _46 = Cell::<(Option<&S2<'_>>, Option<&S2<'_>>)>::set(move _47, move _50) -> [return: bb18, unwind: bb411];
    }

    bb18: {
        _54 = &_1;
        _53 = <ContextData as Clone>::clone(move _54) -> [return: bb19, unwind: bb411];
    }

    bb19: {
        (_53.5: u32) = const 10_u32;
        _57 = (_53.6: bool);
        _56 = Not(move _57);
        _55 = Not(move _56);
        switchInt(move _55) -> [0: bb21, otherwise: bb20];
    }

    bb20: {
        _58 = core::panicking::panic(const "assertion failed: !c.saw_prev_marked") -> bb411;
    }

    bb21: {
        _62 = &_2;
        _61 = <Vec<S2<'_>> as Index<usize>>::index(move _62, const 0_usize) -> [return: bb22, unwind: bb411];
    }

    bb22: {
        _60 = _61;
        _63 = &mut _53;
        _59 = <S2<'_> as Children<'_>>::descend_into_self::<ContextData>(move _60, _63) -> [return: bb23, unwind: bb411];
    }

    bb23: {
        _66 = (_53.6: bool);
        _65 = Not(move _66);
        _64 = Not(move _65);
        switchInt(move _64) -> [0: bb25, otherwise: bb24];
    }

    bb24: {
        _67 = core::panicking::panic(const "assertion failed: !c.saw_prev_marked") -> bb411;
    }

    bb25: {
        _68 = const _;
        switchInt(move _68) -> [0: bb28, otherwise: bb26];
    }

    bb26: {
        _73 = [const "\n"];
        _72 = &_73;
        _71 = _72 as &[&str] (Pointer(Unsize));
        _70 = Arguments::<'_>::new_const(move _71) -> [return: bb27, unwind: bb411];
    }

    bb27: {
        _69 = _print(move _70) -> [return: bb441, unwind: bb411];
    }

    bb28: {
        _77 = SizeOf([S<'_>; 2]);
        _78 = AlignOf([S<'_>; 2]);
        _79 = alloc::alloc::exchange_malloc(move _77, move _78) -> [return: bb29, unwind: bb411];
    }

    bb29: {
        _80 = ShallowInitBox(move _79, [S<'_>; 2]);
        _81 = <S<'_> as Named>::new(const "s0") -> [return: bb30, unwind: bb437];
    }

    bb30: {
        _82 = <S<'_> as Named>::new(const "s1") -> [return: bb31, unwind: bb437];
    }

    bb31: {
        _740 = (((_80.0: std::ptr::Unique<[S<'_>; 2]>).0: std::ptr::NonNull<[S<'_>; 2]>).0: *const [S<'_>; 2]);
        _741 = _740 as *const () (PtrToPtr);
        _742 = _741 as usize (Transmute);
        _743 = AlignOf(S<'_>);
        _744 = Sub(_743, const 1_usize);
        _745 = BitAnd(_742, _744);
        _746 = Eq(_745, const 0_usize);
        assert(_746, "misaligned pointer dereference: address must be a multiple of {} but is {}", _743, _742) -> [success: bb439, unwind unreachable];
    }

    bb32: {
        _86 = &_74;
        _85 = <Vec<S<'_>> as Index<usize>>::index(move _86, const 0_usize) -> [return: bb33, unwind: bb410];
    }

    bb33: {
        _84 = &((*_85).2: std::cell::Cell<std::option::Option<&S<'_>>>);
        _90 = &_74;
        _89 = <Vec<S<'_>> as Index<usize>>::index(move _90, const 1_usize) -> [return: bb34, unwind: bb410];
    }

    bb34: {
        _88 = _89;
        _87 = Option::<&S<'_>>::Some(_88);
        _83 = Cell::<Option<&S<'_>>>::set(move _84, move _87) -> [return: bb35, unwind: bb410];
    }

    bb35: {
        _94 = &_74;
        _93 = <Vec<S<'_>> as Index<usize>>::index(move _94, const 1_usize) -> [return: bb36, unwind: bb410];
    }

    bb36: {
        _92 = &((*_93).2: std::cell::Cell<std::option::Option<&S<'_>>>);
        _98 = &_74;
        _97 = <Vec<S<'_>> as Index<usize>>::index(move _98, const 0_usize) -> [return: bb37, unwind: bb410];
    }

    bb37: {
        _96 = _97;
        _95 = Option::<&S<'_>>::Some(_96);
        _91 = Cell::<Option<&S<'_>>>::set(move _92, move _95) -> [return: bb38, unwind: bb410];
    }

    bb38: {
        _100 = &_1;
        _99 = <ContextData as Clone>::clone(move _100) -> [return: bb39, unwind: bb410];
    }

    bb39: {
        (_99.5: u32) = const 10_u32;
        _103 = (_99.6: bool);
        _102 = Not(move _103);
        _101 = Not(move _102);
        switchInt(move _101) -> [0: bb41, otherwise: bb40];
    }

    bb40: {
        _104 = core::panicking::panic(const "assertion failed: !c.saw_prev_marked") -> bb410;
    }

    bb41: {
        _108 = &_74;
        _107 = <Vec<S<'_>> as Index<usize>>::index(move _108, const 0_usize) -> [return: bb42, unwind: bb410];
    }

    bb42: {
        _106 = _107;
        _109 = &mut _99;
        _105 = <S<'_> as Children<'_>>::descend_into_self::<ContextData>(move _106, _109) -> [return: bb43, unwind: bb410];
    }

    bb43: {
        _111 = (_99.6: bool);
        _110 = Not(move _111);
        switchInt(move _110) -> [0: bb45, otherwise: bb44];
    }

    bb44: {
        _112 = core::panicking::panic(const "assertion failed: c.saw_prev_marked") -> bb410;
    }

    bb45: {
        _113 = const _;
        switchInt(move _113) -> [0: bb48, otherwise: bb46];
    }

    bb46: {
        _118 = [const "\n"];
        _117 = &_118;
        _116 = _117 as &[&str] (Pointer(Unsize));
        _115 = Arguments::<'_>::new_const(move _116) -> [return: bb47, unwind: bb410];
    }

    bb47: {
        _114 = _print(move _115) -> [return: bb442, unwind: bb410];
    }

    bb48: {
        _119 = <V<'_> as Named>::new(const "v") -> [return: bb49, unwind: bb410];
    }

    bb49: {
        _123 = &(_119.2: std::vec::Vec<std::cell::Cell<std::option::Option<&V<'_>>>>);
        _122 = <Vec<Cell<Option<&V<'_>>>> as Index<usize>>::index(move _123, const 0_usize) -> [return: bb50, unwind: bb409];
    }

    bb50: {
        _121 = _122;
        _125 = &_119;
        _124 = Option::<&V<'_>>::Some(_125);
        _120 = Cell::<Option<&V<'_>>>::set(move _121, move _124) -> [return: bb51, unwind: bb409];
    }

    bb51: {
        _129 = &(_119.2: std::vec::Vec<std::cell::Cell<std::option::Option<&V<'_>>>>);
        _128 = <Vec<Cell<Option<&V<'_>>>> as Index<usize>>::index(move _129, const 1_usize) -> [return: bb52, unwind: bb409];
    }

    bb52: {
        _127 = _128;
        _131 = &_119;
        _130 = Option::<&V<'_>>::Some(_131);
        _126 = Cell::<Option<&V<'_>>>::set(move _127, move _130) -> [return: bb53, unwind: bb409];
    }

    bb53: {
        _133 = &_1;
        _132 = <ContextData as Clone>::clone(move _133) -> [return: bb54, unwind: bb409];
    }

    bb54: {
        (_132.5: u32) = const 20_u32;
        _136 = (_132.6: bool);
        _135 = Not(move _136);
        _134 = Not(move _135);
        switchInt(move _134) -> [0: bb56, otherwise: bb55];
    }

    bb55: {
        _137 = core::panicking::panic(const "assertion failed: !c.saw_prev_marked") -> bb409;
    }

    bb56: {
        _139 = &_119;
        _140 = &mut _132;
        _138 = <V<'_> as Children<'_>>::descend_into_self::<ContextData>(move _139, _140) -> [return: bb57, unwind: bb409];
    }

    bb57: {
        _142 = (_132.6: bool);
        _141 = Not(move _142);
        switchInt(move _141) -> [0: bb59, otherwise: bb58];
    }

    bb58: {
        _143 = core::panicking::panic(const "assertion failed: c.saw_prev_marked") -> bb409;
    }

    bb59: {
        _144 = const _;
        switchInt(move _144) -> [0: bb62, otherwise: bb60];
    }

    bb60: {
        _149 = [const "\n"];
        _148 = &_149;
        _147 = _148 as &[&str] (Pointer(Unsize));
        _146 = Arguments::<'_>::new_const(move _147) -> [return: bb61, unwind: bb409];
    }

    bb61: {
        _145 = _print(move _146) -> [return: bb443, unwind: bb409];
    }

    bb62: {
        _150 = HashMap::<H<'_>, H<'_>>::new() -> [return: bb63, unwind: bb409];
    }

    bb63: {
        _152 = &mut _150;
        _153 = <H<'_> as Named>::new(const "hk0") -> [return: bb64, unwind: bb408];
    }

    bb64: {
        _154 = <H<'_> as Named>::new(const "hv0") -> [return: bb65, unwind: bb408];
    }

    bb65: {
        _151 = HashMap::<H<'_>, H<'_>>::insert(move _152, move _153, move _154) -> [return: bb66, unwind: bb408];
    }

    bb66: {
        _156 = &mut _150;
        _157 = <H<'_> as Named>::new(const "hk1") -> [return: bb67, unwind: bb408];
    }

    bb67: {
        _158 = <H<'_> as Named>::new(const "hv1") -> [return: bb68, unwind: bb408];
    }

    bb68: {
        _155 = HashMap::<H<'_>, H<'_>>::insert(move _156, move _157, move _158) -> [return: bb69, unwind: bb408];
    }

    bb69: {
        _161 = &_150;
        _160 = HashMap::<H<'_>, H<'_>>::iter(move _161) -> [return: bb70, unwind: bb408];
    }

    bb70: {
        _159 = <std::collections::hash_map::Iter<'_, H<'_>, H<'_>> as IntoIterator>::into_iter(move _160) -> [return: bb71, unwind: bb408];
    }

    bb71: {
        _162 = move _159;
        goto -> bb72;
    }

    bb72: {
        _164 = &mut _162;
        _163 = <std::collections::hash_map::Iter<'_, H<'_>, H<'_>> as Iterator>::next(_164) -> [return: bb73, unwind: bb408];
    }

    bb73: {
        _165 = discriminant(_163);
        switchInt(move _165) -> [0: bb76, 1: bb74, otherwise: bb75];
    }

    bb74: {
        _166 = (((_163 as Some).0: (&H<'_>, &H<'_>)).0: &H<'_>);
        _167 = (((_163 as Some).0: (&H<'_>, &H<'_>)).1: &H<'_>);
        _169 = &((*_167).2: std::cell::Cell<std::option::Option<&H<'_>>>);
        _170 = Option::<&H<'_>>::Some(_166);
        _168 = Cell::<Option<&H<'_>>>::set(move _169, move _170) -> [return: bb77, unwind: bb408];
    }

    bb75: {
        unreachable;
    }

    bb76: {
        _175 = &_1;
        _174 = <ContextData as Clone>::clone(move _175) -> [return: bb78, unwind: bb408];
    }

    bb77: {
        _172 = &((*_166).2: std::cell::Cell<std::option::Option<&H<'_>>>);
        _173 = Option::<&H<'_>>::Some(_167);
        _171 = Cell::<Option<&H<'_>>>::set(move _172, move _173) -> [return: bb444, unwind: bb408];
    }

    bb78: {
        (_174.5: u32) = const 30_u32;
        _178 = &_150;
        _177 = HashMap::<H<'_>, H<'_>>::iter(move _178) -> [return: bb79, unwind: bb408];
    }

    bb79: {
        _176 = <std::collections::hash_map::Iter<'_, H<'_>, H<'_>> as IntoIterator>::into_iter(move _177) -> [return: bb80, unwind: bb408];
    }

    bb80: {
        _179 = move _176;
        goto -> bb81;
    }

    bb81: {
        _181 = &mut _179;
        _180 = <std::collections::hash_map::Iter<'_, H<'_>, H<'_>> as Iterator>::next(_181) -> [return: bb82, unwind: bb408];
    }

    bb82: {
        _182 = discriminant(_180);
        switchInt(move _182) -> [0: bb84, 1: bb83, otherwise: bb75];
    }

    bb83: {
        _183 = (((_180 as Some).0: (&H<'_>, &H<'_>)).0: &H<'_>);
        (_174.5: u32) = Add((_174.5: u32), const 1_u32);
        (_174.6: bool) = const false;
        _185 = &mut _174;
        _184 = <H<'_> as Children<'_>>::descend_into_self::<ContextData>(_183, _185) -> [return: bb85, unwind: bb408];
    }

    bb84: {
        _189 = const _;
        switchInt(move _189) -> [0: bb89, otherwise: bb87];
    }

    bb85: {
        _187 = (_174.6: bool);
        _186 = Not(move _187);
        switchInt(move _186) -> [0: bb81, otherwise: bb86];
    }

    bb86: {
        _188 = core::panicking::panic(const "assertion failed: c.saw_prev_marked") -> bb408;
    }

    bb87: {
        _194 = [const "\n"];
        _193 = &_194;
        _192 = _193 as &[&str] (Pointer(Unsize));
        _191 = Arguments::<'_>::new_const(move _192) -> [return: bb88, unwind: bb408];
    }

    bb88: {
        _190 = _print(move _191) -> [return: bb445, unwind: bb408];
    }

    bb89: {
        _195 = HashMap::<HM<'_>, HM<'_>>::new() -> [return: bb90, unwind: bb408];
    }

    bb90: {
        _197 = &mut _195;
        _198 = <HM<'_> as Named>::new(const "hmk0") -> [return: bb91, unwind: bb407];
    }

    bb91: {
        _199 = <HM<'_> as Named>::new(const "hmv0") -> [return: bb92, unwind: bb407];
    }

    bb92: {
        _196 = HashMap::<HM<'_>, HM<'_>>::insert(move _197, move _198, move _199) -> [return: bb93, unwind: bb407];
    }

    bb93: {
        _201 = &mut _195;
        _202 = <HM<'_> as Named>::new(const "hmk0") -> [return: bb94, unwind: bb407];
    }

    bb94: {
        _203 = <HM<'_> as Named>::new(const "hmv0") -> [return: bb95, unwind: bb407];
    }

    bb95: {
        _200 = HashMap::<HM<'_>, HM<'_>>::insert(move _201, move _202, move _203) -> [return: bb96, unwind: bb407];
    }

    bb96: {
        _206 = &_195;
        _205 = HashMap::<HM<'_>, HM<'_>>::iter(move _206) -> [return: bb97, unwind: bb407];
    }

    bb97: {
        _204 = <std::collections::hash_map::Iter<'_, HM<'_>, HM<'_>> as IntoIterator>::into_iter(move _205) -> [return: bb98, unwind: bb407];
    }

    bb98: {
        _207 = move _204;
        goto -> bb99;
    }

    bb99: {
        _209 = &mut _207;
        _208 = <std::collections::hash_map::Iter<'_, HM<'_>, HM<'_>> as Iterator>::next(_209) -> [return: bb100, unwind: bb407];
    }

    bb100: {
        _210 = discriminant(_208);
        switchInt(move _210) -> [0: bb102, 1: bb101, otherwise: bb75];
    }

    bb101: {
        _211 = (((_208 as Some).0: (&HM<'_>, &HM<'_>)).0: &HM<'_>);
        _212 = (((_208 as Some).0: (&HM<'_>, &HM<'_>)).1: &HM<'_>);
        _214 = &((*_212).2: std::cell::Cell<std::option::Option<&std::collections::HashMap<HM<'_>, HM<'_>>>>);
        _216 = &_195;
        _215 = Option::<&HashMap<HM<'_>, HM<'_>>>::Some(_216);
        _213 = Cell::<Option<&HashMap<HM<'_>, HM<'_>>>>::set(move _214, move _215) -> [return: bb103, unwind: bb407];
    }

    bb102: {
        _222 = &_1;
        _221 = <ContextData as Clone>::clone(move _222) -> [return: bb104, unwind: bb407];
    }

    bb103: {
        _218 = &((*_211).2: std::cell::Cell<std::option::Option<&std::collections::HashMap<HM<'_>, HM<'_>>>>);
        _220 = &_195;
        _219 = Option::<&HashMap<HM<'_>, HM<'_>>>::Some(_220);
        _217 = Cell::<Option<&HashMap<HM<'_>, HM<'_>>>>::set(move _218, move _219) -> [return: bb446, unwind: bb407];
    }

    bb104: {
        (_221.1: usize) = const 2_usize;
        (_221.5: u32) = const 40_u32;
        _225 = &_195;
        _224 = HashMap::<HM<'_>, HM<'_>>::iter(move _225) -> [return: bb105, unwind: bb407];
    }

    bb105: {
        _223 = <std::collections::hash_map::Iter<'_, HM<'_>, HM<'_>> as IntoIterator>::into_iter(move _224) -> [return: bb106, unwind: bb407];
    }

    bb106: {
        _226 = move _223;
        goto -> bb107;
    }

    bb107: {
        _228 = &mut _226;
        _227 = <std::collections::hash_map::Iter<'_, HM<'_>, HM<'_>> as Iterator>::next(_228) -> [return: bb108, unwind: bb407];
    }

    bb108: {
        _229 = discriminant(_227);
        switchInt(move _229) -> [0: bb110, 1: bb109, otherwise: bb75];
    }

    bb109: {
        _230 = (((_227 as Some).0: (&HM<'_>, &HM<'_>)).0: &HM<'_>);
        (_221.5: u32) = Add((_221.5: u32), const 1_u32);
        (_221.6: bool) = const false;
        _232 = &mut _221;
        _231 = <HM<'_> as Children<'_>>::descend_into_self::<ContextData>(_230, _232) -> [return: bb111, unwind: bb407];
    }

    bb110: {
        _236 = const _;
        switchInt(move _236) -> [0: bb115, otherwise: bb113];
    }

    bb111: {
        _234 = (_221.6: bool);
        _233 = Not(move _234);
        switchInt(move _233) -> [0: bb107, otherwise: bb112];
    }

    bb112: {
        _235 = core::panicking::panic(const "assertion failed: c.saw_prev_marked") -> bb407;
    }

    bb113: {
        _241 = [const "\n"];
        _240 = &_241;
        _239 = _240 as &[&str] (Pointer(Unsize));
        _238 = Arguments::<'_>::new_const(move _239) -> [return: bb114, unwind: bb407];
    }

    bb114: {
        _237 = _print(move _238) -> [return: bb447, unwind: bb407];
    }

    bb115: {
        _242 = VecDeque::<S<'_>>::new() -> [return: bb116, unwind: bb407];
    }

    bb116: {
        _244 = &mut _242;
        _245 = <S<'_> as Named>::new(const "d0") -> [return: bb117, unwind: bb406];
    }

    bb117: {
        _243 = VecDeque::<S<'_>>::push_back(move _244, move _245) -> [return: bb118, unwind: bb406];
    }

    bb118: {
        _247 = &mut _242;
        _248 = <S<'_> as Named>::new(const "d1") -> [return: bb119, unwind: bb406];
    }

    bb119: {
        _246 = VecDeque::<S<'_>>::push_back(move _247, move _248) -> [return: bb120, unwind: bb406];
    }

    bb120: {
        _252 = &_242;
        _251 = <VecDeque<S<'_>> as Index<usize>>::index(move _252, const 0_usize) -> [return: bb121, unwind: bb406];
    }

    bb121: {
        _250 = &((*_251).2: std::cell::Cell<std::option::Option<&S<'_>>>);
        _256 = &_242;
        _255 = <VecDeque<S<'_>> as Index<usize>>::index(move _256, const 1_usize) -> [return: bb122, unwind: bb406];
    }

    bb122: {
        _254 = _255;
        _253 = Option::<&S<'_>>::Some(_254);
        _249 = Cell::<Option<&S<'_>>>::set(move _250, move _253) -> [return: bb123, unwind: bb406];
    }

    bb123: {
        _260 = &_242;
        _259 = <VecDeque<S<'_>> as Index<usize>>::index(move _260, const 1_usize) -> [return: bb124, unwind: bb406];
    }

    bb124: {
        _258 = &((*_259).2: std::cell::Cell<std::option::Option<&S<'_>>>);
        _264 = &_242;
        _263 = <VecDeque<S<'_>> as Index<usize>>::index(move _264, const 0_usize) -> [return: bb125, unwind: bb406];
    }

    bb125: {
        _262 = _263;
        _261 = Option::<&S<'_>>::Some(_262);
        _257 = Cell::<Option<&S<'_>>>::set(move _258, move _261) -> [return: bb126, unwind: bb406];
    }

    bb126: {
        _266 = &_1;
        _265 = <ContextData as Clone>::clone(move _266) -> [return: bb127, unwind: bb406];
    }

    bb127: {
        (_265.5: u32) = const 50_u32;
        _269 = (_265.6: bool);
        _268 = Not(move _269);
        _267 = Not(move _268);
        switchInt(move _267) -> [0: bb129, otherwise: bb128];
    }

    bb128: {
        _270 = core::panicking::panic(const "assertion failed: !c.saw_prev_marked") -> bb406;
    }

    bb129: {
        _274 = &_242;
        _273 = <VecDeque<S<'_>> as Index<usize>>::index(move _274, const 0_usize) -> [return: bb130, unwind: bb406];
    }

    bb130: {
        _272 = _273;
        _275 = &mut _265;
        _271 = <S<'_> as Children<'_>>::descend_into_self::<ContextData>(move _272, _275) -> [return: bb131, unwind: bb406];
    }

    bb131: {
        _277 = (_265.6: bool);
        _276 = Not(move _277);
        switchInt(move _276) -> [0: bb133, otherwise: bb132];
    }

    bb132: {
        _278 = core::panicking::panic(const "assertion failed: c.saw_prev_marked") -> bb406;
    }

    bb133: {
        _279 = const _;
        switchInt(move _279) -> [0: bb136, otherwise: bb134];
    }

    bb134: {
        _284 = [const "\n"];
        _283 = &_284;
        _282 = _283 as &[&str] (Pointer(Unsize));
        _281 = Arguments::<'_>::new_const(move _282) -> [return: bb135, unwind: bb406];
    }

    bb135: {
        _280 = _print(move _281) -> [return: bb448, unwind: bb406];
    }

    bb136: {
        _285 = VecDeque::<VD<'_>>::new() -> [return: bb137, unwind: bb406];
    }

    bb137: {
        _287 = &mut _285;
        _288 = <VD<'_> as Named>::new(const "vd0") -> [return: bb138, unwind: bb405];
    }

    bb138: {
        _286 = VecDeque::<VD<'_>>::push_back(move _287, move _288) -> [return: bb139, unwind: bb405];
    }

    bb139: {
        _290 = &mut _285;
        _291 = <VD<'_> as Named>::new(const "vd1") -> [return: bb140, unwind: bb405];
    }

    bb140: {
        _289 = VecDeque::<VD<'_>>::push_back(move _290, move _291) -> [return: bb141, unwind: bb405];
    }

    bb141: {
        _295 = &_285;
        _294 = <VecDeque<VD<'_>> as Index<usize>>::index(move _295, const 0_usize) -> [return: bb142, unwind: bb405];
    }

    bb142: {
        _293 = &((*_294).2: std::cell::Cell<std::option::Option<&std::collections::VecDeque<VD<'_>>>>);
        _297 = &_285;
        _296 = Option::<&VecDeque<VD<'_>>>::Some(_297);
        _292 = Cell::<Option<&VecDeque<VD<'_>>>>::set(move _293, move _296) -> [return: bb143, unwind: bb405];
    }

    bb143: {
        _301 = &_285;
        _300 = <VecDeque<VD<'_>> as Index<usize>>::index(move _301, const 1_usize) -> [return: bb144, unwind: bb405];
    }

    bb144: {
        _299 = &((*_300).2: std::cell::Cell<std::option::Option<&std::collections::VecDeque<VD<'_>>>>);
        _303 = &_285;
        _302 = Option::<&VecDeque<VD<'_>>>::Some(_303);
        _298 = Cell::<Option<&VecDeque<VD<'_>>>>::set(move _299, move _302) -> [return: bb145, unwind: bb405];
    }

    bb145: {
        _305 = &_1;
        _304 = <ContextData as Clone>::clone(move _305) -> [return: bb146, unwind: bb405];
    }

    bb146: {
        (_304.5: u32) = const 60_u32;
        _308 = (_304.6: bool);
        _307 = Not(move _308);
        _306 = Not(move _307);
        switchInt(move _306) -> [0: bb148, otherwise: bb147];
    }

    bb147: {
        _309 = core::panicking::panic(const "assertion failed: !c.saw_prev_marked") -> bb405;
    }

    bb148: {
        _313 = &_285;
        _312 = <VecDeque<VD<'_>> as Index<usize>>::index(move _313, const 0_usize) -> [return: bb149, unwind: bb405];
    }

    bb149: {
        _311 = _312;
        _314 = &mut _304;
        _310 = <VD<'_> as Children<'_>>::descend_into_self::<ContextData>(move _311, _314) -> [return: bb150, unwind: bb405];
    }

    bb150: {
        _316 = (_304.6: bool);
        _315 = Not(move _316);
        switchInt(move _315) -> [0: bb152, otherwise: bb151];
    }

    bb151: {
        _317 = core::panicking::panic(const "assertion failed: c.saw_prev_marked") -> bb405;
    }

    bb152: {
        _318 = const _;
        switchInt(move _318) -> [0: bb155, otherwise: bb153];
    }

    bb153: {
        _323 = [const "\n"];
        _322 = &_323;
        _321 = _322 as &[&str] (Pointer(Unsize));
        _320 = Arguments::<'_>::new_const(move _321) -> [return: bb154, unwind: bb405];
    }

    bb154: {
        _319 = _print(move _320) -> [return: bb449, unwind: bb405];
    }

    bb155: {
        _324 = HashMap::<usize, VM<'_>>::new() -> [return: bb156, unwind: bb405];
    }

    bb156: {
        _326 = &mut _324;
        _327 = <VM<'_> as Named>::new(const "vm0") -> [return: bb157, unwind: bb404];
    }

    bb157: {
        _325 = HashMap::<usize, VM<'_>>::insert(move _326, const 0_usize, move _327) -> [return: bb158, unwind: bb404];
    }

    bb158: {
        _329 = &mut _324;
        _330 = <VM<'_> as Named>::new(const "vm1") -> [return: bb159, unwind: bb404];
    }

    bb159: {
        _328 = HashMap::<usize, VM<'_>>::insert(move _329, const 1_usize, move _330) -> [return: bb160, unwind: bb404];
    }

    bb160: {
        _334 = &_324;
        _336 = const 0_usize;
        _335 = &_336;
        _333 = <HashMap<usize, VM<'_>> as Index<&usize>>::index(move _334, _335) -> [return: bb161, unwind: bb404];
    }

    bb161: {
        _332 = &((*_333).2: std::cell::Cell<std::option::Option<&std::collections::HashMap<usize, VM<'_>>>>);
        _338 = &_324;
        _337 = Option::<&HashMap<usize, VM<'_>>>::Some(_338);
        _331 = Cell::<Option<&HashMap<usize, VM<'_>>>>::set(move _332, move _337) -> [return: bb162, unwind: bb404];
    }

    bb162: {
        _342 = &_324;
        _344 = const 1_usize;
        _343 = &_344;
        _341 = <HashMap<usize, VM<'_>> as Index<&usize>>::index(move _342, _343) -> [return: bb163, unwind: bb404];
    }

    bb163: {
        _340 = &((*_341).2: std::cell::Cell<std::option::Option<&std::collections::HashMap<usize, VM<'_>>>>);
        _346 = &_324;
        _345 = Option::<&HashMap<usize, VM<'_>>>::Some(_346);
        _339 = Cell::<Option<&HashMap<usize, VM<'_>>>>::set(move _340, move _345) -> [return: bb164, unwind: bb404];
    }

    bb164: {
        _348 = &_1;
        _347 = <ContextData as Clone>::clone(move _348) -> [return: bb165, unwind: bb404];
    }

    bb165: {
        (_347.5: u32) = const 70_u32;
        _351 = (_347.6: bool);
        _350 = Not(move _351);
        _349 = Not(move _350);
        switchInt(move _349) -> [0: bb167, otherwise: bb166];
    }

    bb166: {
        _352 = core::panicking::panic(const "assertion failed: !c.saw_prev_marked") -> bb404;
    }

    bb167: {
        _356 = &_324;
        _358 = const 0_usize;
        _357 = &_358;
        _355 = <HashMap<usize, VM<'_>> as Index<&usize>>::index(move _356, _357) -> [return: bb168, unwind: bb404];
    }

    bb168: {
        _354 = _355;
        _359 = &mut _347;
        _353 = <VM<'_> as Children<'_>>::descend_into_self::<ContextData>(move _354, _359) -> [return: bb169, unwind: bb404];
    }

    bb169: {
        _361 = (_347.6: bool);
        _360 = Not(move _361);
        switchInt(move _360) -> [0: bb171, otherwise: bb170];
    }

    bb170: {
        _362 = core::panicking::panic(const "assertion failed: c.saw_prev_marked") -> bb404;
    }

    bb171: {
        _363 = const _;
        switchInt(move _363) -> [0: bb174, otherwise: bb172];
    }

    bb172: {
        _368 = [const "\n"];
        _367 = &_368;
        _366 = _367 as &[&str] (Pointer(Unsize));
        _365 = Arguments::<'_>::new_const(move _366) -> [return: bb173, unwind: bb404];
    }

    bb173: {
        _364 = _print(move _365) -> [return: bb450, unwind: bb404];
    }

    bb174: {
        _369 = LinkedList::<LL<'_>>::new() -> [return: bb175, unwind: bb404];
    }

    bb175: {
        _371 = &mut _369;
        _372 = <LL<'_> as Named>::new(const "ll0") -> [return: bb176, unwind: bb403];
    }

    bb176: {
        _370 = LinkedList::<LL<'_>>::push_back(move _371, move _372) -> [return: bb177, unwind: bb403];
    }

    bb177: {
        _374 = &mut _369;
        _375 = <LL<'_> as Named>::new(const "ll1") -> [return: bb178, unwind: bb403];
    }

    bb178: {
        _373 = LinkedList::<LL<'_>>::push_back(move _374, move _375) -> [return: bb179, unwind: bb403];
    }

    bb179: {
        _377 = &_369;
        _376 = <&LinkedList<LL<'_>> as IntoIterator>::into_iter(move _377) -> [return: bb180, unwind: bb403];
    }

    bb180: {
        _378 = move _376;
        goto -> bb181;
    }

    bb181: {
        _380 = &mut _378;
        _379 = <std::collections::linked_list::Iter<'_, LL<'_>> as Iterator>::next(_380) -> [return: bb182, unwind: bb403];
    }

    bb182: {
        _381 = discriminant(_379);
        switchInt(move _381) -> [0: bb184, 1: bb183, otherwise: bb75];
    }

    bb183: {
        _382 = ((_379 as Some).0: &LL<'_>);
        _384 = &((*_382).2: std::cell::Cell<std::option::Option<&std::collections::LinkedList<LL<'_>>>>);
        _386 = &_369;
        _385 = Option::<&LinkedList<LL<'_>>>::Some(_386);
        _383 = Cell::<Option<&LinkedList<LL<'_>>>>::set(move _384, move _385) -> [return: bb451, unwind: bb403];
    }

    bb184: {
        _388 = &_1;
        _387 = <ContextData as Clone>::clone(move _388) -> [return: bb185, unwind: bb403];
    }

    bb185: {
        (_387.5: u32) = const 80_u32;
        _390 = &_369;
        _389 = <&LinkedList<LL<'_>> as IntoIterator>::into_iter(move _390) -> [return: bb186, unwind: bb403];
    }

    bb186: {
        _391 = move _389;
        goto -> bb187;
    }

    bb187: {
        _393 = &mut _391;
        _392 = <std::collections::linked_list::Iter<'_, LL<'_>> as Iterator>::next(_393) -> [return: bb188, unwind: bb403];
    }

    bb188: {
        _394 = discriminant(_392);
        switchInt(move _394) -> [0: bb190, 1: bb189, otherwise: bb75];
    }

    bb189: {
        _395 = ((_392 as Some).0: &LL<'_>);
        (_387.5: u32) = Add((_387.5: u32), const 1_u32);
        (_387.6: bool) = const false;
        _397 = &mut _387;
        _396 = <LL<'_> as Children<'_>>::descend_into_self::<ContextData>(_395, _397) -> [return: bb191, unwind: bb403];
    }

    bb190: {
        _401 = const _;
        switchInt(move _401) -> [0: bb195, otherwise: bb193];
    }

    bb191: {
        _399 = (_387.6: bool);
        _398 = Not(move _399);
        switchInt(move _398) -> [0: bb187, otherwise: bb192];
    }

    bb192: {
        _400 = core::panicking::panic(const "assertion failed: c.saw_prev_marked") -> bb403;
    }

    bb193: {
        _406 = [const "\n"];
        _405 = &_406;
        _404 = _405 as &[&str] (Pointer(Unsize));
        _403 = Arguments::<'_>::new_const(move _404) -> [return: bb194, unwind: bb403];
    }

    bb194: {
        _402 = _print(move _403) -> [return: bb452, unwind: bb403];
    }

    bb195: {
        _407 = BinaryHeap::<BH<'_>>::new() -> [return: bb196, unwind: bb403];
    }

    bb196: {
        _409 = &mut _407;
        _410 = <BH<'_> as Named>::new(const "bh0") -> [return: bb197, unwind: bb402];
    }

    bb197: {
        _408 = BinaryHeap::<BH<'_>>::push(move _409, move _410) -> [return: bb198, unwind: bb402];
    }

    bb198: {
        _412 = &mut _407;
        _413 = <BH<'_> as Named>::new(const "bh1") -> [return: bb199, unwind: bb402];
    }

    bb199: {
        _411 = BinaryHeap::<BH<'_>>::push(move _412, move _413) -> [return: bb200, unwind: bb402];
    }

    bb200: {
        _416 = &_407;
        _415 = BinaryHeap::<BH<'_>>::iter(move _416) -> [return: bb201, unwind: bb402];
    }

    bb201: {
        _414 = <std::collections::binary_heap::Iter<'_, BH<'_>> as IntoIterator>::into_iter(move _415) -> [return: bb202, unwind: bb402];
    }

    bb202: {
        _417 = move _414;
        goto -> bb203;
    }

    bb203: {
        _419 = &mut _417;
        _418 = <std::collections::binary_heap::Iter<'_, BH<'_>> as Iterator>::next(_419) -> [return: bb204, unwind: bb402];
    }

    bb204: {
        _420 = discriminant(_418);
        switchInt(move _420) -> [0: bb206, 1: bb205, otherwise: bb75];
    }

    bb205: {
        _421 = ((_418 as Some).0: &BH<'_>);
        _423 = &((*_421).2: std::cell::Cell<std::option::Option<&std::collections::BinaryHeap<BH<'_>>>>);
        _425 = &_407;
        _424 = Option::<&BinaryHeap<BH<'_>>>::Some(_425);
        _422 = Cell::<Option<&BinaryHeap<BH<'_>>>>::set(move _423, move _424) -> [return: bb453, unwind: bb402];
    }

    bb206: {
        _427 = &_1;
        _426 = <ContextData as Clone>::clone(move _427) -> [return: bb207, unwind: bb402];
    }

    bb207: {
        (_426.5: u32) = const 90_u32;
        _429 = &_407;
        _428 = <&BinaryHeap<BH<'_>> as IntoIterator>::into_iter(move _429) -> [return: bb208, unwind: bb402];
    }

    bb208: {
        _430 = move _428;
        goto -> bb209;
    }

    bb209: {
        _432 = &mut _430;
        _431 = <std::collections::binary_heap::Iter<'_, BH<'_>> as Iterator>::next(_432) -> [return: bb210, unwind: bb402];
    }

    bb210: {
        _433 = discriminant(_431);
        switchInt(move _433) -> [0: bb212, 1: bb211, otherwise: bb75];
    }

    bb211: {
        _434 = ((_431 as Some).0: &BH<'_>);
        (_426.5: u32) = Add((_426.5: u32), const 1_u32);
        (_426.6: bool) = const false;
        _436 = &mut _426;
        _435 = <BH<'_> as Children<'_>>::descend_into_self::<ContextData>(_434, _436) -> [return: bb213, unwind: bb402];
    }

    bb212: {
        _440 = const _;
        switchInt(move _440) -> [0: bb217, otherwise: bb215];
    }

    bb213: {
        _438 = (_426.6: bool);
        _437 = Not(move _438);
        switchInt(move _437) -> [0: bb209, otherwise: bb214];
    }

    bb214: {
        _439 = core::panicking::panic(const "assertion failed: c.saw_prev_marked") -> bb402;
    }

    bb215: {
        _445 = [const "\n"];
        _444 = &_445;
        _443 = _444 as &[&str] (Pointer(Unsize));
        _442 = Arguments::<'_>::new_const(move _443) -> [return: bb216, unwind: bb402];
    }

    bb216: {
        _441 = _print(move _442) -> [return: bb454, unwind: bb402];
    }

    bb217: {
        _446 = BTreeMap::<BTM<'_>, BTM<'_>>::new() -> [return: bb218, unwind: bb402];
    }

    bb218: {
        _448 = &mut _446;
        _449 = <BTM<'_> as Named>::new(const "btk0") -> [return: bb219, unwind: bb401];
    }

    bb219: {
        _450 = <BTM<'_> as Named>::new(const "btv0") -> [return: bb220, unwind: bb401];
    }

    bb220: {
        _447 = BTreeMap::<BTM<'_>, BTM<'_>>::insert(move _448, move _449, move _450) -> [return: bb221, unwind: bb401];
    }

    bb221: {
        _452 = &mut _446;
        _453 = <BTM<'_> as Named>::new(const "btk1") -> [return: bb222, unwind: bb401];
    }

    bb222: {
        _454 = <BTM<'_> as Named>::new(const "btv1") -> [return: bb223, unwind: bb401];
    }

    bb223: {
        _451 = BTreeMap::<BTM<'_>, BTM<'_>>::insert(move _452, move _453, move _454) -> [return: bb224, unwind: bb401];
    }

    bb224: {
        _457 = &_446;
        _456 = BTreeMap::<BTM<'_>, BTM<'_>>::iter(move _457) -> [return: bb225, unwind: bb401];
    }

    bb225: {
        _455 = <std::collections::btree_map::Iter<'_, BTM<'_>, BTM<'_>> as IntoIterator>::into_iter(move _456) -> [return: bb226, unwind: bb401];
    }

    bb226: {
        _458 = move _455;
        goto -> bb227;
    }

    bb227: {
        _460 = &mut _458;
        _459 = <std::collections::btree_map::Iter<'_, BTM<'_>, BTM<'_>> as Iterator>::next(_460) -> [return: bb228, unwind: bb401];
    }

    bb228: {
        _461 = discriminant(_459);
        switchInt(move _461) -> [0: bb230, 1: bb229, otherwise: bb75];
    }

    bb229: {
        _462 = (((_459 as Some).0: (&BTM<'_>, &BTM<'_>)).0: &BTM<'_>);
        _463 = (((_459 as Some).0: (&BTM<'_>, &BTM<'_>)).1: &BTM<'_>);
        _465 = &((*_462).2: std::cell::Cell<std::option::Option<&std::collections::BTreeMap<BTM<'_>, BTM<'_>>>>);
        _467 = &_446;
        _466 = Option::<&BTreeMap<BTM<'_>, BTM<'_>>>::Some(_467);
        _464 = Cell::<Option<&BTreeMap<BTM<'_>, BTM<'_>>>>::set(move _465, move _466) -> [return: bb231, unwind: bb401];
    }

    bb230: {
        _473 = &_1;
        _472 = <ContextData as Clone>::clone(move _473) -> [return: bb232, unwind: bb401];
    }

    bb231: {
        _469 = &((*_463).2: std::cell::Cell<std::option::Option<&std::collections::BTreeMap<BTM<'_>, BTM<'_>>>>);
        _471 = &_446;
        _470 = Option::<&BTreeMap<BTM<'_>, BTM<'_>>>::Some(_471);
        _468 = Cell::<Option<&BTreeMap<BTM<'_>, BTM<'_>>>>::set(move _469, move _470) -> [return: bb455, unwind: bb401];
    }

    bb232: {
        (_472.5: u32) = const 100_u32;
        _475 = &_446;
        _474 = <&BTreeMap<BTM<'_>, BTM<'_>> as IntoIterator>::into_iter(move _475) -> [return: bb233, unwind: bb401];
    }

    bb233: {
        _476 = move _474;
        goto -> bb234;
    }

    bb234: {
        _478 = &mut _476;
        _477 = <std::collections::btree_map::Iter<'_, BTM<'_>, BTM<'_>> as Iterator>::next(_478) -> [return: bb235, unwind: bb401];
    }

    bb235: {
        _479 = discriminant(_477);
        switchInt(move _479) -> [0: bb237, 1: bb236, otherwise: bb75];
    }

    bb236: {
        _480 = (((_477 as Some).0: (&BTM<'_>, &BTM<'_>)).0: &BTM<'_>);
        (_472.5: u32) = Add((_472.5: u32), const 1_u32);
        (_472.6: bool) = const false;
        _482 = &mut _472;
        _481 = <BTM<'_> as Children<'_>>::descend_into_self::<ContextData>(_480, _482) -> [return: bb238, unwind: bb401];
    }

    bb237: {
        _486 = const _;
        switchInt(move _486) -> [0: bb242, otherwise: bb240];
    }

    bb238: {
        _484 = (_472.6: bool);
        _483 = Not(move _484);
        switchInt(move _483) -> [0: bb234, otherwise: bb239];
    }

    bb239: {
        _485 = core::panicking::panic(const "assertion failed: c.saw_prev_marked") -> bb401;
    }

    bb240: {
        _491 = [const "\n"];
        _490 = &_491;
        _489 = _490 as &[&str] (Pointer(Unsize));
        _488 = Arguments::<'_>::new_const(move _489) -> [return: bb241, unwind: bb401];
    }

    bb241: {
        _487 = _print(move _488) -> [return: bb456, unwind: bb401];
    }

    bb242: {
        _492 = BTreeSet::<BTS<'_>>::new() -> [return: bb243, unwind: bb401];
    }

    bb243: {
        _494 = &mut _492;
        _495 = <BTS<'_> as Named>::new(const "bts0") -> [return: bb244, unwind: bb400];
    }

    bb244: {
        _493 = BTreeSet::<BTS<'_>>::insert(move _494, move _495) -> [return: bb245, unwind: bb400];
    }

    bb245: {
        _497 = &mut _492;
        _498 = <BTS<'_> as Named>::new(const "bts1") -> [return: bb246, unwind: bb400];
    }

    bb246: {
        _496 = BTreeSet::<BTS<'_>>::insert(move _497, move _498) -> [return: bb247, unwind: bb400];
    }

    bb247: {
        _501 = &_492;
        _500 = BTreeSet::<BTS<'_>>::iter(move _501) -> [return: bb248, unwind: bb400];
    }

    bb248: {
        _499 = <std::collections::btree_set::Iter<'_, BTS<'_>> as IntoIterator>::into_iter(move _500) -> [return: bb249, unwind: bb400];
    }

    bb249: {
        _502 = move _499;
        goto -> bb250;
    }

    bb250: {
        _504 = &mut _502;
        _503 = <std::collections::btree_set::Iter<'_, BTS<'_>> as Iterator>::next(_504) -> [return: bb251, unwind: bb400];
    }

    bb251: {
        _505 = discriminant(_503);
        switchInt(move _505) -> [0: bb253, 1: bb252, otherwise: bb75];
    }

    bb252: {
        _506 = ((_503 as Some).0: &BTS<'_>);
        _508 = &((*_506).2: std::cell::Cell<std::option::Option<&std::collections::BTreeSet<BTS<'_>>>>);
        _510 = &_492;
        _509 = Option::<&BTreeSet<BTS<'_>>>::Some(_510);
        _507 = Cell::<Option<&BTreeSet<BTS<'_>>>>::set(move _508, move _509) -> [return: bb457, unwind: bb400];
    }

    bb253: {
        _512 = &_1;
        _511 = <ContextData as Clone>::clone(move _512) -> [return: bb254, unwind: bb400];
    }

    bb254: {
        (_511.5: u32) = const 100_u32;
        _514 = &_492;
        _513 = <&BTreeSet<BTS<'_>> as IntoIterator>::into_iter(move _514) -> [return: bb255, unwind: bb400];
    }

    bb255: {
        _515 = move _513;
        goto -> bb256;
    }

    bb256: {
        _517 = &mut _515;
        _516 = <std::collections::btree_set::Iter<'_, BTS<'_>> as Iterator>::next(_517) -> [return: bb257, unwind: bb400];
    }

    bb257: {
        _518 = discriminant(_516);
        switchInt(move _518) -> [0: bb259, 1: bb258, otherwise: bb75];
    }

    bb258: {
        _519 = ((_516 as Some).0: &BTS<'_>);
        (_511.5: u32) = Add((_511.5: u32), const 1_u32);
        (_511.6: bool) = const false;
        _521 = &mut _511;
        _520 = <BTS<'_> as Children<'_>>::descend_into_self::<ContextData>(_519, _521) -> [return: bb260, unwind: bb400];
    }

    bb259: {
        _525 = const _;
        switchInt(move _525) -> [0: bb264, otherwise: bb262];
    }

    bb260: {
        _523 = (_511.6: bool);
        _522 = Not(move _523);
        switchInt(move _522) -> [0: bb256, otherwise: bb261];
    }

    bb261: {
        _524 = core::panicking::panic(const "assertion failed: c.saw_prev_marked") -> bb400;
    }

    bb262: {
        _530 = [const "\n"];
        _529 = &_530;
        _528 = _529 as &[&str] (Pointer(Unsize));
        _527 = Arguments::<'_>::new_const(move _528) -> [return: bb263, unwind: bb400];
    }

    bb263: {
        _526 = _print(move _527) -> [return: bb458, unwind: bb400];
    }

    bb264: {
        _534 = <RCRC<'_> as Named>::new(const "rcrc0") -> [return: bb265, unwind: bb432];
    }

    bb265: {
        _734 = const true;
        _531 = move _534;
        _535 = <RCRC<'_> as Named>::new(const "rcrc1") -> [return: bb266, unwind: bb432];
    }

    bb266: {
        _733 = const true;
        _532 = move _535;
        _536 = <RCRC<'_> as Named>::new(const "rcrc2") -> [return: bb267, unwind: bb432];
    }

    bb267: {
        _732 = const true;
        _533 = move _536;
        _538 = &_532;
        _537 = Option::<&RCRC<'_>>::Some(_538);
        _544 = &(_531.0: std::rc::Rc<std::cell::RefCell<RCRCData<'_>>>);
        _543 = <Rc<RefCell<RCRCData<'_>>> as Deref>::deref(move _544) -> [return: bb268, unwind: bb432];
    }

    bb268: {
        _542 = _543;
        _541 = RefCell::<RCRCData<'_>>::borrow_mut(move _542) -> [return: bb269, unwind: bb432];
    }

    bb269: {
        _540 = &mut _541;
        _539 = <RefMut<'_, RCRCData<'_>> as DerefMut>::deref_mut(move _540) -> [return: bb270, unwind: bb399];
    }

    bb270: {
        (((*_539).2: (std::option::Option<&RCRC<'_>>, std::option::Option<&RCRC<'_>>)).0: std::option::Option<&RCRC<'_>>) = move _537;
        drop(_541) -> [return: bb271, unwind: bb432];
    }

    bb271: {
        _546 = &_533;
        _545 = Option::<&RCRC<'_>>::Some(_546);
        _552 = &(_531.0: std::rc::Rc<std::cell::RefCell<RCRCData<'_>>>);
        _551 = <Rc<RefCell<RCRCData<'_>>> as Deref>::deref(move _552) -> [return: bb272, unwind: bb432];
    }

    bb272: {
        _550 = _551;
        _549 = RefCell::<RCRCData<'_>>::borrow_mut(move _550) -> [return: bb273, unwind: bb432];
    }

    bb273: {
        _548 = &mut _549;
        _547 = <RefMut<'_, RCRCData<'_>> as DerefMut>::deref_mut(move _548) -> [return: bb274, unwind: bb398];
    }

    bb274: {
        (((*_547).2: (std::option::Option<&RCRC<'_>>, std::option::Option<&RCRC<'_>>)).1: std::option::Option<&RCRC<'_>>) = move _545;
        drop(_549) -> [return: bb275, unwind: bb432];
    }

    bb275: {
        _554 = &_531;
        _553 = Option::<&RCRC<'_>>::Some(_554);
        _560 = &(_533.0: std::rc::Rc<std::cell::RefCell<RCRCData<'_>>>);
        _559 = <Rc<RefCell<RCRCData<'_>>> as Deref>::deref(move _560) -> [return: bb276, unwind: bb432];
    }

    bb276: {
        _558 = _559;
        _557 = RefCell::<RCRCData<'_>>::borrow_mut(move _558) -> [return: bb277, unwind: bb432];
    }

    bb277: {
        _556 = &mut _557;
        _555 = <RefMut<'_, RCRCData<'_>> as DerefMut>::deref_mut(move _556) -> [return: bb278, unwind: bb397];
    }

    bb278: {
        (((*_555).2: (std::option::Option<&RCRC<'_>>, std::option::Option<&RCRC<'_>>)).0: std::option::Option<&RCRC<'_>>) = move _553;
        drop(_557) -> [return: bb279, unwind: bb432];
    }

    bb279: {
        _562 = &_1;
        _561 = <ContextData as Clone>::clone(move _562) -> [return: bb280, unwind: bb432];
    }

    bb280: {
        (_561.7: u64) = const 1_u64;
        (_561.5: u32) = const 110_u32;
        _565 = (_561.6: bool);
        _564 = Not(move _565);
        _563 = Not(move _564);
        switchInt(move _563) -> [0: bb282, otherwise: bb281];
    }

    bb281: {
        _566 = core::panicking::panic(const "assertion failed: !c.saw_prev_marked") -> bb432;
    }

    bb282: {
        _568 = &_531;
        _569 = &mut _561;
        _567 = <RCRC<'_> as Children<'_>>::descend_into_self::<ContextData>(move _568, _569) -> [return: bb283, unwind: bb432];
    }

    bb283: {
        _571 = (_561.6: bool);
        _570 = Not(move _571);
        switchInt(move _570) -> [0: bb285, otherwise: bb284];
    }

    bb284: {
        _572 = core::panicking::panic(const "assertion failed: c.saw_prev_marked") -> bb432;
    }

    bb285: {
        _573 = const _;
        switchInt(move _573) -> [0: bb288, otherwise: bb286];
    }

    bb286: {
        _578 = [const "\n"];
        _577 = &_578;
        _576 = _577 as &[&str] (Pointer(Unsize));
        _575 = Arguments::<'_>::new_const(move _576) -> [return: bb287, unwind: bb432];
    }

    bb287: {
        _574 = _print(move _575) -> [return: bb459, unwind: bb432];
    }

    bb288: {
        _582 = <ARCRC<'_> as Named>::new(const "arcrc0") -> [return: bb289, unwind: bb426];
    }

    bb289: {
        _731 = const true;
        _579 = move _582;
        _583 = <ARCRC<'_> as Named>::new(const "arcrc1") -> [return: bb290, unwind: bb426];
    }

    bb290: {
        _730 = const true;
        _580 = move _583;
        _584 = <ARCRC<'_> as Named>::new(const "arcrc2") -> [return: bb291, unwind: bb426];
    }

    bb291: {
        _729 = const true;
        _581 = move _584;
        _586 = &_580;
        _585 = Option::<&ARCRC<'_>>::Some(_586);
        _592 = &(_579.0: std::sync::Arc<std::cell::RefCell<ARCRCData<'_>>>);
        _591 = <Arc<RefCell<ARCRCData<'_>>> as Deref>::deref(move _592) -> [return: bb292, unwind: bb426];
    }

    bb292: {
        _590 = _591;
        _589 = RefCell::<ARCRCData<'_>>::borrow_mut(move _590) -> [return: bb293, unwind: bb426];
    }

    bb293: {
        _588 = &mut _589;
        _587 = <RefMut<'_, ARCRCData<'_>> as DerefMut>::deref_mut(move _588) -> [return: bb294, unwind: bb396];
    }

    bb294: {
        (((*_587).2: (std::option::Option<&ARCRC<'_>>, std::option::Option<&ARCRC<'_>>)).0: std::option::Option<&ARCRC<'_>>) = move _585;
        drop(_589) -> [return: bb295, unwind: bb426];
    }

    bb295: {
        _594 = &_581;
        _593 = Option::<&ARCRC<'_>>::Some(_594);
        _600 = &(_579.0: std::sync::Arc<std::cell::RefCell<ARCRCData<'_>>>);
        _599 = <Arc<RefCell<ARCRCData<'_>>> as Deref>::deref(move _600) -> [return: bb296, unwind: bb426];
    }

    bb296: {
        _598 = _599;
        _597 = RefCell::<ARCRCData<'_>>::borrow_mut(move _598) -> [return: bb297, unwind: bb426];
    }

    bb297: {
        _596 = &mut _597;
        _595 = <RefMut<'_, ARCRCData<'_>> as DerefMut>::deref_mut(move _596) -> [return: bb298, unwind: bb395];
    }

    bb298: {
        (((*_595).2: (std::option::Option<&ARCRC<'_>>, std::option::Option<&ARCRC<'_>>)).1: std::option::Option<&ARCRC<'_>>) = move _593;
        drop(_597) -> [return: bb299, unwind: bb426];
    }

    bb299: {
        _602 = &_579;
        _601 = Option::<&ARCRC<'_>>::Some(_602);
        _608 = &(_581.0: std::sync::Arc<std::cell::RefCell<ARCRCData<'_>>>);
        _607 = <Arc<RefCell<ARCRCData<'_>>> as Deref>::deref(move _608) -> [return: bb300, unwind: bb426];
    }

    bb300: {
        _606 = _607;
        _605 = RefCell::<ARCRCData<'_>>::borrow_mut(move _606) -> [return: bb301, unwind: bb426];
    }

    bb301: {
        _604 = &mut _605;
        _603 = <RefMut<'_, ARCRCData<'_>> as DerefMut>::deref_mut(move _604) -> [return: bb302, unwind: bb394];
    }

    bb302: {
        (((*_603).2: (std::option::Option<&ARCRC<'_>>, std::option::Option<&ARCRC<'_>>)).0: std::option::Option<&ARCRC<'_>>) = move _601;
        drop(_605) -> [return: bb303, unwind: bb426];
    }

    bb303: {
        _610 = &_1;
        _609 = <ContextData as Clone>::clone(move _610) -> [return: bb304, unwind: bb426];
    }

    bb304: {
        (_609.7: u64) = const 1_u64;
        (_609.5: u32) = const 110_u32;
        _613 = (_609.6: bool);
        _612 = Not(move _613);
        _611 = Not(move _612);
        switchInt(move _611) -> [0: bb306, otherwise: bb305];
    }

    bb305: {
        _614 = core::panicking::panic(const "assertion failed: !c.saw_prev_marked") -> bb426;
    }

    bb306: {
        _616 = &_579;
        _617 = &mut _609;
        _615 = <ARCRC<'_> as Children<'_>>::descend_into_self::<ContextData>(move _616, _617) -> [return: bb307, unwind: bb426];
    }

    bb307: {
        _619 = (_609.6: bool);
        _618 = Not(move _619);
        switchInt(move _618) -> [0: bb309, otherwise: bb308];
    }

    bb308: {
        _620 = core::panicking::panic(const "assertion failed: c.saw_prev_marked") -> bb426;
    }

    bb309: {
        _621 = const _;
        switchInt(move _621) -> [0: bb312, otherwise: bb310];
    }

    bb310: {
        _626 = [const "\n"];
        _625 = &_626;
        _624 = _625 as &[&str] (Pointer(Unsize));
        _623 = Arguments::<'_>::new_const(move _624) -> [return: bb311, unwind: bb426];
    }

    bb311: {
        _622 = _print(move _623) -> [return: bb460, unwind: bb426];
    }

    bb312: {
        _630 = <ARCRW<'_> as Named>::new(const "arcrw0") -> [return: bb313, unwind: bb420];
    }

    bb313: {
        _728 = const true;
        _627 = move _630;
        _631 = <ARCRW<'_> as Named>::new(const "arcrw1") -> [return: bb314, unwind: bb420];
    }

    bb314: {
        _727 = const true;
        _628 = move _631;
        _632 = <ARCRW<'_> as Named>::new(const "arcrw2") -> [return: bb315, unwind: bb420];
    }

    bb315: {
        _726 = const true;
        _629 = move _632;
        _634 = &_628;
        _633 = Option::<&ARCRW<'_>>::Some(_634);
        _641 = &(_627.0: std::sync::Arc<std::sync::RwLock<ARCRWData<'_>>>);
        _640 = <Arc<RwLock<ARCRWData<'_>>> as Deref>::deref(move _641) -> [return: bb316, unwind: bb420];
    }

    bb316: {
        _639 = _640;
        _638 = RwLock::<ARCRWData<'_>>::write(move _639) -> [return: bb317, unwind: bb420];
    }

    bb317: {
        _637 = Result::<RwLockWriteGuard<'_, ARCRWData<'_>>, PoisonError<RwLockWriteGuard<'_, ARCRWData<'_>>>>::unwrap(move _638) -> [return: bb318, unwind: bb420];
    }

    bb318: {
        _636 = &mut _637;
        _635 = <RwLockWriteGuard<'_, ARCRWData<'_>> as DerefMut>::deref_mut(move _636) -> [return: bb319, unwind: bb393];
    }

    bb319: {
        (((*_635).2: (std::option::Option<&ARCRW<'_>>, std::option::Option<&ARCRW<'_>>)).0: std::option::Option<&ARCRW<'_>>) = move _633;
        drop(_637) -> [return: bb320, unwind: bb420];
    }

    bb320: {
        _643 = &_629;
        _642 = Option::<&ARCRW<'_>>::Some(_643);
        _650 = &(_627.0: std::sync::Arc<std::sync::RwLock<ARCRWData<'_>>>);
        _649 = <Arc<RwLock<ARCRWData<'_>>> as Deref>::deref(move _650) -> [return: bb321, unwind: bb420];
    }

    bb321: {
        _648 = _649;
        _647 = RwLock::<ARCRWData<'_>>::write(move _648) -> [return: bb322, unwind: bb420];
    }

    bb322: {
        _646 = Result::<RwLockWriteGuard<'_, ARCRWData<'_>>, PoisonError<RwLockWriteGuard<'_, ARCRWData<'_>>>>::unwrap(move _647) -> [return: bb323, unwind: bb420];
    }

    bb323: {
        _645 = &mut _646;
        _644 = <RwLockWriteGuard<'_, ARCRWData<'_>> as DerefMut>::deref_mut(move _645) -> [return: bb324, unwind: bb392];
    }

    bb324: {
        (((*_644).2: (std::option::Option<&ARCRW<'_>>, std::option::Option<&ARCRW<'_>>)).1: std::option::Option<&ARCRW<'_>>) = move _642;
        drop(_646) -> [return: bb325, unwind: bb420];
    }

    bb325: {
        _652 = &_627;
        _651 = Option::<&ARCRW<'_>>::Some(_652);
        _659 = &(_629.0: std::sync::Arc<std::sync::RwLock<ARCRWData<'_>>>);
        _658 = <Arc<RwLock<ARCRWData<'_>>> as Deref>::deref(move _659) -> [return: bb326, unwind: bb420];
    }

    bb326: {
        _657 = _658;
        _656 = RwLock::<ARCRWData<'_>>::write(move _657) -> [return: bb327, unwind: bb420];
    }

    bb327: {
        _655 = Result::<RwLockWriteGuard<'_, ARCRWData<'_>>, PoisonError<RwLockWriteGuard<'_, ARCRWData<'_>>>>::unwrap(move _656) -> [return: bb328, unwind: bb420];
    }

    bb328: {
        _654 = &mut _655;
        _653 = <RwLockWriteGuard<'_, ARCRWData<'_>> as DerefMut>::deref_mut(move _654) -> [return: bb329, unwind: bb391];
    }

    bb329: {
        (((*_653).2: (std::option::Option<&ARCRW<'_>>, std::option::Option<&ARCRW<'_>>)).0: std::option::Option<&ARCRW<'_>>) = move _651;
        drop(_655) -> [return: bb330, unwind: bb420];
    }

    bb330: {
        _661 = &_1;
        _660 = <ContextData as Clone>::clone(move _661) -> [return: bb331, unwind: bb420];
    }

    bb331: {
        (_660.7: u64) = const 1_u64;
        (_660.5: u32) = const 110_u32;
        _664 = (_660.6: bool);
        _663 = Not(move _664);
        _662 = Not(move _663);
        switchInt(move _662) -> [0: bb333, otherwise: bb332];
    }

    bb332: {
        _665 = core::panicking::panic(const "assertion failed: !c.saw_prev_marked") -> bb420;
    }

    bb333: {
        _667 = &_627;
        _668 = &mut _660;
        _666 = <ARCRW<'_> as Children<'_>>::descend_into_self::<ContextData>(move _667, _668) -> [return: bb334, unwind: bb420];
    }

    bb334: {
        _670 = (_660.6: bool);
        _669 = Not(move _670);
        switchInt(move _669) -> [0: bb336, otherwise: bb335];
    }

    bb335: {
        _671 = core::panicking::panic(const "assertion failed: c.saw_prev_marked") -> bb420;
    }

    bb336: {
        _672 = const _;
        switchInt(move _672) -> [0: bb339, otherwise: bb337];
    }

    bb337: {
        _677 = [const "\n"];
        _676 = &_677;
        _675 = _676 as &[&str] (Pointer(Unsize));
        _674 = Arguments::<'_>::new_const(move _675) -> [return: bb338, unwind: bb420];
    }

    bb338: {
        _673 = _print(move _674) -> [return: bb461, unwind: bb420];
    }

    bb339: {
        _681 = <ARCM<'_> as Named>::new(const "arcm0") -> [return: bb340, unwind: bb414];
    }

    bb340: {
        _725 = const true;
        _678 = move _681;
        _682 = <ARCM<'_> as Named>::new(const "arcm1") -> [return: bb341, unwind: bb414];
    }

    bb341: {
        _724 = const true;
        _679 = move _682;
        _683 = <ARCM<'_> as Named>::new(const "arcm2") -> [return: bb342, unwind: bb414];
    }

    bb342: {
        _723 = const true;
        _680 = move _683;
        _685 = &_679;
        _684 = Option::<&ARCM<'_>>::Some(_685);
        _692 = &(_678.1: std::sync::Arc<std::sync::Mutex<ARCMData<'_>>>);
        _691 = <Arc<Mutex<ARCMData<'_>>> as Deref>::deref(move _692) -> [return: bb343, unwind: bb414];
    }

    bb343: {
        _690 = _691;
        _689 = Mutex::<ARCMData<'_>>::lock(move _690) -> [return: bb344, unwind: bb414];
    }

    bb344: {
        _688 = Result::<MutexGuard<'_, ARCMData<'_>>, PoisonError<MutexGuard<'_, ARCMData<'_>>>>::unwrap(move _689) -> [return: bb345, unwind: bb414];
    }

    bb345: {
        _687 = &mut _688;
        _686 = <MutexGuard<'_, ARCMData<'_>> as DerefMut>::deref_mut(move _687) -> [return: bb346, unwind: bb390];
    }

    bb346: {
        (((*_686).1: (std::option::Option<&ARCM<'_>>, std::option::Option<&ARCM<'_>>)).0: std::option::Option<&ARCM<'_>>) = move _684;
        drop(_688) -> [return: bb347, unwind: bb414];
    }

    bb347: {
        _694 = &_680;
        _693 = Option::<&ARCM<'_>>::Some(_694);
        _701 = &(_678.1: std::sync::Arc<std::sync::Mutex<ARCMData<'_>>>);
        _700 = <Arc<Mutex<ARCMData<'_>>> as Deref>::deref(move _701) -> [return: bb348, unwind: bb414];
    }

    bb348: {
        _699 = _700;
        _698 = Mutex::<ARCMData<'_>>::lock(move _699) -> [return: bb349, unwind: bb414];
    }

    bb349: {
        _697 = Result::<MutexGuard<'_, ARCMData<'_>>, PoisonError<MutexGuard<'_, ARCMData<'_>>>>::unwrap(move _698) -> [return: bb350, unwind: bb414];
    }

    bb350: {
        _696 = &mut _697;
        _695 = <MutexGuard<'_, ARCMData<'_>> as DerefMut>::deref_mut(move _696) -> [return: bb351, unwind: bb389];
    }

    bb351: {
        (((*_695).1: (std::option::Option<&ARCM<'_>>, std::option::Option<&ARCM<'_>>)).1: std::option::Option<&ARCM<'_>>) = move _693;
        drop(_697) -> [return: bb352, unwind: bb414];
    }

    bb352: {
        _703 = &_678;
        _702 = Option::<&ARCM<'_>>::Some(_703);
        _710 = &(_680.1: std::sync::Arc<std::sync::Mutex<ARCMData<'_>>>);
        _709 = <Arc<Mutex<ARCMData<'_>>> as Deref>::deref(move _710) -> [return: bb353, unwind: bb414];
    }

    bb353: {
        _708 = _709;
        _707 = Mutex::<ARCMData<'_>>::lock(move _708) -> [return: bb354, unwind: bb414];
    }

    bb354: {
        _706 = Result::<MutexGuard<'_, ARCMData<'_>>, PoisonError<MutexGuard<'_, ARCMData<'_>>>>::unwrap(move _707) -> [return: bb355, unwind: bb414];
    }

    bb355: {
        _705 = &mut _706;
        _704 = <MutexGuard<'_, ARCMData<'_>> as DerefMut>::deref_mut(move _705) -> [return: bb356, unwind: bb388];
    }

    bb356: {
        (((*_704).1: (std::option::Option<&ARCM<'_>>, std::option::Option<&ARCM<'_>>)).0: std::option::Option<&ARCM<'_>>) = move _702;
        drop(_706) -> [return: bb357, unwind: bb414];
    }

    bb357: {
        _712 = &_1;
        _711 = <ContextData as Clone>::clone(move _712) -> [return: bb358, unwind: bb414];
    }

    bb358: {
        (_711.7: u64) = const 1_u64;
        (_711.5: u32) = const 110_u32;
        _715 = (_711.6: bool);
        _714 = Not(move _715);
        _713 = Not(move _714);
        switchInt(move _713) -> [0: bb360, otherwise: bb359];
    }

    bb359: {
        _716 = core::panicking::panic(const "assertion failed: !c.saw_prev_marked") -> bb414;
    }

    bb360: {
        _718 = &_678;
        _719 = &mut _711;
        _717 = <ARCM<'_> as Children<'_>>::descend_into_self::<ContextData>(move _718, _719) -> [return: bb361, unwind: bb414];
    }

    bb361: {
        _721 = (_711.6: bool);
        _720 = Not(move _721);
        switchInt(move _720) -> [0: bb363, otherwise: bb362];
    }

    bb362: {
        _722 = core::panicking::panic(const "assertion failed: c.saw_prev_marked") -> bb414;
    }

    bb363: {
        drop(_680) -> [return: bb364, unwind: bb416];
    }

    bb364: {
        _723 = const false;
        drop(_679) -> [return: bb365, unwind: bb418];
    }

    bb365: {
        _724 = const false;
        drop(_678) -> [return: bb366, unwind: bb420];
    }

    bb366: {
        _725 = const false;
        drop(_629) -> [return: bb367, unwind: bb422];
    }

    bb367: {
        _726 = const false;
        drop(_628) -> [return: bb368, unwind: bb424];
    }

    bb368: {
        _727 = const false;
        drop(_627) -> [return: bb369, unwind: bb426];
    }

    bb369: {
        _728 = const false;
        drop(_581) -> [return: bb370, unwind: bb428];
    }

    bb370: {
        _729 = const false;
        drop(_580) -> [return: bb371, unwind: bb430];
    }

    bb371: {
        _730 = const false;
        drop(_579) -> [return: bb372, unwind: bb432];
    }

    bb372: {
        _731 = const false;
        drop(_533) -> [return: bb373, unwind: bb434];
    }

    bb373: {
        _732 = const false;
        drop(_532) -> [return: bb374, unwind: bb436];
    }

    bb374: {
        _733 = const false;
        drop(_531) -> [return: bb375, unwind: bb400];
    }

    bb375: {
        _734 = const false;
        drop(_492) -> [return: bb376, unwind: bb401];
    }

    bb376: {
        drop(_446) -> [return: bb377, unwind: bb402];
    }

    bb377: {
        drop(_407) -> [return: bb378, unwind: bb403];
    }

    bb378: {
        drop(_369) -> [return: bb379, unwind: bb404];
    }

    bb379: {
        drop(_324) -> [return: bb380, unwind: bb405];
    }

    bb380: {
        drop(_285) -> [return: bb381, unwind: bb406];
    }

    bb381: {
        drop(_242) -> [return: bb382, unwind: bb407];
    }

    bb382: {
        drop(_195) -> [return: bb383, unwind: bb408];
    }

    bb383: {
        drop(_150) -> [return: bb384, unwind: bb409];
    }

    bb384: {
        drop(_119) -> [return: bb385, unwind: bb410];
    }

    bb385: {
        drop(_74) -> [return: bb386, unwind: bb411];
    }

    bb386: {
        drop(_2) -> bb387;
    }

    bb387: {
        return;
    }

    bb388 (cleanup): {
        drop(_706) -> [return: bb414, unwind terminate];
    }

    bb389 (cleanup): {
        drop(_697) -> [return: bb414, unwind terminate];
    }

    bb390 (cleanup): {
        drop(_688) -> [return: bb414, unwind terminate];
    }

    bb391 (cleanup): {
        drop(_655) -> [return: bb420, unwind terminate];
    }

    bb392 (cleanup): {
        drop(_646) -> [return: bb420, unwind terminate];
    }

    bb393 (cleanup): {
        drop(_637) -> [return: bb420, unwind terminate];
    }

    bb394 (cleanup): {
        drop(_605) -> [return: bb426, unwind terminate];
    }

    bb395 (cleanup): {
        drop(_597) -> [return: bb426, unwind terminate];
    }

    bb396 (cleanup): {
        drop(_589) -> [return: bb426, unwind terminate];
    }

    bb397 (cleanup): {
        drop(_557) -> [return: bb432, unwind terminate];
    }

    bb398 (cleanup): {
        drop(_549) -> [return: bb432, unwind terminate];
    }

    bb399 (cleanup): {
        drop(_541) -> [return: bb432, unwind terminate];
    }

    bb400 (cleanup): {
        drop(_492) -> [return: bb401, unwind terminate];
    }

    bb401 (cleanup): {
        drop(_446) -> [return: bb402, unwind terminate];
    }

    bb402 (cleanup): {
        drop(_407) -> [return: bb403, unwind terminate];
    }

    bb403 (cleanup): {
        drop(_369) -> [return: bb404, unwind terminate];
    }

    bb404 (cleanup): {
        drop(_324) -> [return: bb405, unwind terminate];
    }

    bb405 (cleanup): {
        drop(_285) -> [return: bb406, unwind terminate];
    }

    bb406 (cleanup): {
        drop(_242) -> [return: bb407, unwind terminate];
    }

    bb407 (cleanup): {
        drop(_195) -> [return: bb408, unwind terminate];
    }

    bb408 (cleanup): {
        drop(_150) -> [return: bb409, unwind terminate];
    }

    bb409 (cleanup): {
        drop(_119) -> [return: bb410, unwind terminate];
    }

    bb410 (cleanup): {
        drop(_74) -> [return: bb411, unwind terminate];
    }

    bb411 (cleanup): {
        drop(_2) -> [return: bb412, unwind terminate];
    }

    bb412 (cleanup): {
        resume;
    }

    bb413 (cleanup): {
        drop(_680) -> [return: bb416, unwind terminate];
    }

    bb414 (cleanup): {
        switchInt(_723) -> [0: bb416, otherwise: bb413];
    }

    bb415 (cleanup): {
        drop(_679) -> [return: bb418, unwind terminate];
    }

    bb416 (cleanup): {
        switchInt(_724) -> [0: bb418, otherwise: bb415];
    }

    bb417 (cleanup): {
        drop(_678) -> [return: bb420, unwind terminate];
    }

    bb418 (cleanup): {
        switchInt(_725) -> [0: bb420, otherwise: bb417];
    }

    bb419 (cleanup): {
        drop(_629) -> [return: bb422, unwind terminate];
    }

    bb420 (cleanup): {
        switchInt(_726) -> [0: bb422, otherwise: bb419];
    }

    bb421 (cleanup): {
        drop(_628) -> [return: bb424, unwind terminate];
    }

    bb422 (cleanup): {
        switchInt(_727) -> [0: bb424, otherwise: bb421];
    }

    bb423 (cleanup): {
        drop(_627) -> [return: bb426, unwind terminate];
    }

    bb424 (cleanup): {
        switchInt(_728) -> [0: bb426, otherwise: bb423];
    }

    bb425 (cleanup): {
        drop(_581) -> [return: bb428, unwind terminate];
    }

    bb426 (cleanup): {
        switchInt(_729) -> [0: bb428, otherwise: bb425];
    }

    bb427 (cleanup): {
        drop(_580) -> [return: bb430, unwind terminate];
    }

    bb428 (cleanup): {
        switchInt(_730) -> [0: bb430, otherwise: bb427];
    }

    bb429 (cleanup): {
        drop(_579) -> [return: bb432, unwind terminate];
    }

    bb430 (cleanup): {
        switchInt(_731) -> [0: bb432, otherwise: bb429];
    }

    bb431 (cleanup): {
        drop(_533) -> [return: bb434, unwind terminate];
    }

    bb432 (cleanup): {
        switchInt(_732) -> [0: bb434, otherwise: bb431];
    }

    bb433 (cleanup): {
        drop(_532) -> [return: bb436, unwind terminate];
    }

    bb434 (cleanup): {
        switchInt(_733) -> [0: bb436, otherwise: bb433];
    }

    bb435 (cleanup): {
        drop(_531) -> [return: bb400, unwind terminate];
    }

    bb436 (cleanup): {
        switchInt(_734) -> [0: bb400, otherwise: bb435];
    }

    bb437 (cleanup): {
        _735 = &mut _80;
        _736 = <Box<[S<'_>; 2]> as Drop>::drop(move _735) -> [return: bb462, unwind terminate];
    }

    bb438 (cleanup): {
        _737 = &mut _8;
        _738 = <Box<[S2<'_>; 4]> as Drop>::drop(move _737) -> [return: bb463, unwind terminate];
    }

    bb439: {
        (*_740) = [move _81, move _82];
        _76 = move _80;
        _75 = move _76 as std::boxed::Box<[S<'_>]> (Pointer(Unsize));
        _74 = slice::<impl [S<'_>]>::into_vec::<std::alloc::Global>(move _75) -> [return: bb32, unwind: bb411];
    }

    bb440: {
        (*_739) = [move _9, move _10, move _11, move _12];
        _4 = move _8;
        _3 = move _4 as std::boxed::Box<[S2<'_>]> (Pointer(Unsize));
        _2 = slice::<impl [S2<'_>]>::into_vec::<std::alloc::Global>(move _3) -> bb6;
    }

    bb441: {
        goto -> bb28;
    }

    bb442: {
        goto -> bb48;
    }

    bb443: {
        goto -> bb62;
    }

    bb444: {
        goto -> bb72;
    }

    bb445: {
        goto -> bb89;
    }

    bb446: {
        goto -> bb99;
    }

    bb447: {
        goto -> bb115;
    }

    bb448: {
        goto -> bb136;
    }

    bb449: {
        goto -> bb155;
    }

    bb450: {
        goto -> bb174;
    }

    bb451: {
        goto -> bb181;
    }

    bb452: {
        goto -> bb195;
    }

    bb453: {
        goto -> bb203;
    }

    bb454: {
        goto -> bb217;
    }

    bb455: {
        goto -> bb227;
    }

    bb456: {
        goto -> bb242;
    }

    bb457: {
        goto -> bb250;
    }

    bb458: {
        goto -> bb264;
    }

    bb459: {
        goto -> bb288;
    }

    bb460: {
        goto -> bb312;
    }

    bb461: {
        goto -> bb339;
    }

    bb462 (cleanup): {
        goto -> bb411;
    }

    bb463 (cleanup): {
        goto -> bb412;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:451:1: 451:25>::new(_1: &str) -> S<'_> {
    debug name => _1;
    let mut _0: S<'_>;
    let mut _2: std::cell::Cell<u32>;
    let mut _3: std::cell::Cell<std::option::Option<&S<'_>>>;
    let mut _4: std::option::Option<&S<'_>>;

    bb0: {
        _2 = Cell::<u32>::new(const 0_u32) -> bb1;
    }

    bb1: {
        _4 = Option::<&S<'_>>::None;
        _3 = Cell::<Option<&S<'_>>>::new(move _4) -> bb2;
    }

    bb2: {
        _0 = S::<'_> { name: _1, mark: move _2, next: move _3 };
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:451:1: 451:25>::name(_1: &S<'_>) -> &str {
    debug self => _1;
    let mut _0: &str;

    bb0: {
        _0 = deref_copy ((*_1).0: &str);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:458:1: 458:31>::mark(_1: &S<'_>) -> u32 {
    debug self => _1;
    let mut _0: u32;
    let mut _2: &std::cell::Cell<u32>;

    bb0: {
        _2 = &((*_1).1: std::cell::Cell<u32>);
        _0 = Cell::<u32>::get(move _2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:458:1: 458:31>::set_mark(_1: &S<'_>, _2: u32) -> () {
    debug self => _1;
    debug mark => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: &std::cell::Cell<u32>;

    bb0: {
        _4 = &((*_1).1: std::cell::Cell<u32>);
        _3 = Cell::<u32>::set(move _4, _2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:469:1: 469:26>::new(_1: &str) -> S2<'_> {
    debug name => _1;
    let mut _0: S2<'_>;
    let mut _2: std::cell::Cell<u32>;
    let mut _3: std::cell::Cell<(std::option::Option<&S2<'_>>, std::option::Option<&S2<'_>>)>;
    let mut _4: (std::option::Option<&S2<'_>>, std::option::Option<&S2<'_>>);
    let mut _5: std::option::Option<&S2<'_>>;
    let mut _6: std::option::Option<&S2<'_>>;

    bb0: {
        _2 = Cell::<u32>::new(const 0_u32) -> bb1;
    }

    bb1: {
        _5 = Option::<&S2<'_>>::None;
        _6 = Option::<&S2<'_>>::None;
        _4 = (move _5, move _6);
        _3 = Cell::<(Option<&S2<'_>>, Option<&S2<'_>>)>::new(move _4) -> bb2;
    }

    bb2: {
        _0 = S2::<'_> { name: _1, mark: move _2, next: move _3 };
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:469:1: 469:26>::name(_1: &S2<'_>) -> &str {
    debug self => _1;
    let mut _0: &str;

    bb0: {
        _0 = deref_copy ((*_1).0: &str);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:476:1: 476:32>::mark(_1: &S2<'_>) -> u32 {
    debug self => _1;
    let mut _0: u32;
    let mut _2: &std::cell::Cell<u32>;

    bb0: {
        _2 = &((*_1).1: std::cell::Cell<u32>);
        _0 = Cell::<u32>::get(move _2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:476:1: 476:32>::set_mark(_1: &S2<'_>, _2: u32) -> () {
    debug self => _1;
    debug mark => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: &std::cell::Cell<u32>;

    bb0: {
        _4 = &((*_1).1: std::cell::Cell<u32>);
        _3 = Cell::<u32>::set(move _4, _2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:489:1: 489:25>::new(_1: &str) -> V<'_> {
    debug name => _1;
    let mut _0: V<'_>;
    let mut _2: std::cell::Cell<u32>;
    let mut _3: std::vec::Vec<std::cell::Cell<std::option::Option<&V<'_>>>>;
    let mut _4: std::boxed::Box<[std::cell::Cell<std::option::Option<&V<'_>>>]>;
    let mut _5: std::boxed::Box<[std::cell::Cell<std::option::Option<&V<'_>>>; 2]>;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: *mut u8;
    let mut _9: std::boxed::Box<[std::cell::Cell<std::option::Option<&V<'_>>>; 2]>;
    let mut _10: std::cell::Cell<std::option::Option<&V<'_>>>;
    let mut _11: std::option::Option<&V<'_>>;
    let mut _12: std::cell::Cell<std::option::Option<&V<'_>>>;
    let mut _13: std::option::Option<&V<'_>>;
    let mut _14: &mut std::boxed::Box<[std::cell::Cell<std::option::Option<&V<'_>>>; 2]>;
    let mut _15: ();
    let mut _16: *const [std::cell::Cell<std::option::Option<&V<'_>>>; 2];
    let mut _17: *const ();
    let mut _18: usize;
    let mut _19: usize;
    let mut _20: usize;
    let mut _21: usize;
    let mut _22: bool;
    scope 1 {
    }

    bb0: {
        _2 = Cell::<u32>::new(const 0_u32) -> bb1;
    }

    bb1: {
        _6 = SizeOf([std::cell::Cell<std::option::Option<&V<'_>>>; 2]);
        _7 = AlignOf([std::cell::Cell<std::option::Option<&V<'_>>>; 2]);
        _8 = alloc::alloc::exchange_malloc(move _6, move _7) -> bb2;
    }

    bb2: {
        _9 = ShallowInitBox(move _8, [std::cell::Cell<std::option::Option<&V<'_>>>; 2]);
        _11 = Option::<&V<'_>>::None;
        _10 = Cell::<Option<&V<'_>>>::new(move _11) -> [return: bb3, unwind: bb7];
    }

    bb3: {
        _13 = Option::<&V<'_>>::None;
        _12 = Cell::<Option<&V<'_>>>::new(move _13) -> [return: bb4, unwind: bb7];
    }

    bb4: {
        _16 = (((_9.0: std::ptr::Unique<[std::cell::Cell<std::option::Option<&V<'_>>>; 2]>).0: std::ptr::NonNull<[std::cell::Cell<std::option::Option<&V<'_>>>; 2]>).0: *const [std::cell::Cell<std::option::Option<&V<'_>>>; 2]);
        _17 = _16 as *const () (PtrToPtr);
        _18 = _17 as usize (Transmute);
        _19 = AlignOf(std::cell::Cell<std::option::Option<&V<'_>>>);
        _20 = Sub(_19, const 1_usize);
        _21 = BitAnd(_18, _20);
        _22 = Eq(_21, const 0_usize);
        assert(_22, "misaligned pointer dereference: address must be a multiple of {} but is {}", _19, _18) -> [success: bb8, unwind unreachable];
    }

    bb5: {
        _0 = V::<'_> { name: _1, mark: move _2, contents: move _3 };
        return;
    }

    bb6 (cleanup): {
        resume;
    }

    bb7 (cleanup): {
        _14 = &mut _9;
        _15 = <Box<[Cell<Option<&V<'_>>>; 2]> as Drop>::drop(move _14) -> [return: bb6, unwind terminate];
    }

    bb8: {
        (*_16) = [move _10, move _12];
        _5 = move _9;
        _4 = move _5 as std::boxed::Box<[std::cell::Cell<std::option::Option<&V<'_>>>]> (Pointer(Unsize));
        _3 = slice::<impl [Cell<Option<&V<'_>>>]>::into_vec::<std::alloc::Global>(move _4) -> bb5;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:489:1: 489:25>::name(_1: &V<'_>) -> &str {
    debug self => _1;
    let mut _0: &str;

    bb0: {
        _0 = deref_copy ((*_1).0: &str);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:499:1: 499:31>::mark(_1: &V<'_>) -> u32 {
    debug self => _1;
    let mut _0: u32;
    let mut _2: &std::cell::Cell<u32>;

    bb0: {
        _2 = &((*_1).1: std::cell::Cell<u32>);
        _0 = Cell::<u32>::get(move _2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:499:1: 499:31>::set_mark(_1: &V<'_>, _2: u32) -> () {
    debug self => _1;
    debug mark => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: &std::cell::Cell<u32>;

    bb0: {
        _4 = &((*_1).1: std::cell::Cell<u32>);
        _3 = Cell::<u32>::set(move _4, _2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:504:10: 504:12>::assert_receiver_is_total_eq(_1: &H<'_>) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
        scope 2 {
            scope 3 {
            }
        }
    }

    bb0: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:511:1: 511:25>::new(_1: &str) -> H<'_> {
    debug name => _1;
    let mut _0: H<'_>;
    let mut _2: std::cell::Cell<u32>;
    let mut _3: std::cell::Cell<std::option::Option<&H<'_>>>;
    let mut _4: std::option::Option<&H<'_>>;

    bb0: {
        _2 = Cell::<u32>::new(const 0_u32) -> bb1;
    }

    bb1: {
        _4 = Option::<&H<'_>>::None;
        _3 = Cell::<Option<&H<'_>>>::new(move _4) -> bb2;
    }

    bb2: {
        _0 = H::<'_> { name: _1, mark: move _2, next: move _3 };
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:511:1: 511:25>::name(_1: &H<'_>) -> &str {
    debug self => _1;
    let mut _0: &str;

    bb0: {
        _0 = deref_copy ((*_1).0: &str);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:518:1: 518:31>::mark(_1: &H<'_>) -> u32 {
    debug self => _1;
    let mut _0: u32;
    let mut _2: &std::cell::Cell<u32>;

    bb0: {
        _2 = &((*_1).1: std::cell::Cell<u32>);
        _0 = Cell::<u32>::get(move _2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:518:1: 518:31>::set_mark(_1: &H<'_>, _2: u32) -> () {
    debug self => _1;
    debug mark => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: &std::cell::Cell<u32>;

    bb0: {
        _4 = &((*_1).1: std::cell::Cell<u32>);
        _3 = Cell::<u32>::set(move _4, _2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:523:1: 523:29>::eq(_1: &H<'_>, _2: &H<'_>) -> bool {
    debug self => _1;
    debug rhs => _2;
    let mut _0: bool;
    let mut _3: &&str;
    let mut _4: &&str;

    bb0: {
        _3 = &((*_1).0: &str);
        _4 = &((*_2).0: &str);
        _0 = <&str as PartialEq>::eq(move _3, move _4) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:529:1: 529:24>::hash(_1: &H<'_>, _2: &mut H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let mut _3: &str;

    bb0: {
        _3 = deref_copy ((*_1).0: &str);
        _0 = <str as Hash>::hash::<H>(_3, _2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:535:10: 535:12>::assert_receiver_is_total_eq(_1: &HM<'_>) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
        scope 2 {
            scope 3 {
            }
        }
    }

    bb0: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:542:1: 542:26>::new(_1: &str) -> HM<'_> {
    debug name => _1;
    let mut _0: HM<'_>;
    let mut _2: std::cell::Cell<u32>;
    let mut _3: std::cell::Cell<std::option::Option<&std::collections::HashMap<HM<'_>, HM<'_>>>>;
    let mut _4: std::option::Option<&std::collections::HashMap<HM<'_>, HM<'_>>>;

    bb0: {
        _2 = Cell::<u32>::new(const 0_u32) -> bb1;
    }

    bb1: {
        _4 = Option::<&HashMap<HM<'_>, HM<'_>>>::None;
        _3 = Cell::<Option<&HashMap<HM<'_>, HM<'_>>>>::new(move _4) -> bb2;
    }

    bb2: {
        _0 = HM::<'_> { name: _1, mark: move _2, contents: move _3 };
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:542:1: 542:26>::name(_1: &HM<'_>) -> &str {
    debug self => _1;
    let mut _0: &str;

    bb0: {
        _0 = deref_copy ((*_1).0: &str);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:552:1: 552:32>::mark(_1: &HM<'_>) -> u32 {
    debug self => _1;
    let mut _0: u32;
    let mut _2: &std::cell::Cell<u32>;

    bb0: {
        _2 = &((*_1).1: std::cell::Cell<u32>);
        _0 = Cell::<u32>::get(move _2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:552:1: 552:32>::set_mark(_1: &HM<'_>, _2: u32) -> () {
    debug self => _1;
    debug mark => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: &std::cell::Cell<u32>;

    bb0: {
        _4 = &((*_1).1: std::cell::Cell<u32>);
        _3 = Cell::<u32>::set(move _4, _2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:557:1: 557:30>::eq(_1: &HM<'_>, _2: &HM<'_>) -> bool {
    debug self => _1;
    debug rhs => _2;
    let mut _0: bool;
    let mut _3: &&str;
    let mut _4: &&str;

    bb0: {
        _3 = &((*_1).0: &str);
        _4 = &((*_2).0: &str);
        _0 = <&str as PartialEq>::eq(move _3, move _4) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:563:1: 563:25>::hash(_1: &HM<'_>, _2: &mut H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let mut _3: &str;

    bb0: {
        _3 = deref_copy ((*_1).0: &str);
        _0 = <str as Hash>::hash::<H>(_3, _2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:576:1: 576:26>::new(_1: &str) -> VD<'_> {
    debug name => _1;
    let mut _0: VD<'_>;
    let mut _2: std::cell::Cell<u32>;
    let mut _3: std::cell::Cell<std::option::Option<&std::collections::VecDeque<VD<'_>>>>;
    let mut _4: std::option::Option<&std::collections::VecDeque<VD<'_>>>;

    bb0: {
        _2 = Cell::<u32>::new(const 0_u32) -> bb1;
    }

    bb1: {
        _4 = Option::<&VecDeque<VD<'_>>>::None;
        _3 = Cell::<Option<&VecDeque<VD<'_>>>>::new(move _4) -> bb2;
    }

    bb2: {
        _0 = VD::<'_> { name: _1, mark: move _2, contents: move _3 };
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:576:1: 576:26>::name(_1: &VD<'_>) -> &str {
    debug self => _1;
    let mut _0: &str;

    bb0: {
        _0 = deref_copy ((*_1).0: &str);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:586:1: 586:32>::mark(_1: &VD<'_>) -> u32 {
    debug self => _1;
    let mut _0: u32;
    let mut _2: &std::cell::Cell<u32>;

    bb0: {
        _2 = &((*_1).1: std::cell::Cell<u32>);
        _0 = Cell::<u32>::get(move _2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:586:1: 586:32>::set_mark(_1: &VD<'_>, _2: u32) -> () {
    debug self => _1;
    debug mark => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: &std::cell::Cell<u32>;

    bb0: {
        _4 = &((*_1).1: std::cell::Cell<u32>);
        _3 = Cell::<u32>::set(move _4, _2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:597:1: 597:26>::new(_1: &str) -> VM<'_> {
    debug name => _1;
    let mut _0: VM<'_>;
    let mut _2: std::cell::Cell<u32>;
    let mut _3: std::cell::Cell<std::option::Option<&std::collections::HashMap<usize, VM<'_>>>>;
    let mut _4: std::option::Option<&std::collections::HashMap<usize, VM<'_>>>;

    bb0: {
        _2 = Cell::<u32>::new(const 0_u32) -> bb1;
    }

    bb1: {
        _4 = Option::<&HashMap<usize, VM<'_>>>::None;
        _3 = Cell::<Option<&HashMap<usize, VM<'_>>>>::new(move _4) -> bb2;
    }

    bb2: {
        _0 = VM::<'_> { name: _1, mark: move _2, contents: move _3 };
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:597:1: 597:26>::name(_1: &VM<'_>) -> &str {
    debug self => _1;
    let mut _0: &str;

    bb0: {
        _0 = deref_copy ((*_1).0: &str);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:607:1: 607:32>::mark(_1: &VM<'_>) -> u32 {
    debug self => _1;
    let mut _0: u32;
    let mut _2: &std::cell::Cell<u32>;

    bb0: {
        _2 = &((*_1).1: std::cell::Cell<u32>);
        _0 = Cell::<u32>::get(move _2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:607:1: 607:32>::set_mark(_1: &VM<'_>, _2: u32) -> () {
    debug self => _1;
    debug mark => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: &std::cell::Cell<u32>;

    bb0: {
        _4 = &((*_1).1: std::cell::Cell<u32>);
        _3 = Cell::<u32>::set(move _4, _2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:618:1: 618:26>::new(_1: &str) -> LL<'_> {
    debug name => _1;
    let mut _0: LL<'_>;
    let mut _2: std::cell::Cell<u32>;
    let mut _3: std::cell::Cell<std::option::Option<&std::collections::LinkedList<LL<'_>>>>;
    let mut _4: std::option::Option<&std::collections::LinkedList<LL<'_>>>;

    bb0: {
        _2 = Cell::<u32>::new(const 0_u32) -> bb1;
    }

    bb1: {
        _4 = Option::<&LinkedList<LL<'_>>>::None;
        _3 = Cell::<Option<&LinkedList<LL<'_>>>>::new(move _4) -> bb2;
    }

    bb2: {
        _0 = LL::<'_> { name: _1, mark: move _2, contents: move _3 };
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:618:1: 618:26>::name(_1: &LL<'_>) -> &str {
    debug self => _1;
    let mut _0: &str;

    bb0: {
        _0 = deref_copy ((*_1).0: &str);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:628:1: 628:32>::mark(_1: &LL<'_>) -> u32 {
    debug self => _1;
    let mut _0: u32;
    let mut _2: &std::cell::Cell<u32>;

    bb0: {
        _2 = &((*_1).1: std::cell::Cell<u32>);
        _0 = Cell::<u32>::get(move _2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:628:1: 628:32>::set_mark(_1: &LL<'_>, _2: u32) -> () {
    debug self => _1;
    debug mark => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: &std::cell::Cell<u32>;

    bb0: {
        _4 = &((*_1).1: std::cell::Cell<u32>);
        _3 = Cell::<u32>::set(move _4, _2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:639:1: 639:26>::new(_1: &str) -> BH<'_> {
    debug name => _1;
    let mut _0: BH<'_>;
    let mut _2: std::cell::Cell<u32>;
    let mut _3: std::cell::Cell<std::option::Option<&std::collections::BinaryHeap<BH<'_>>>>;
    let mut _4: std::option::Option<&std::collections::BinaryHeap<BH<'_>>>;

    bb0: {
        _2 = Cell::<u32>::new(const 0_u32) -> bb1;
    }

    bb1: {
        _4 = Option::<&BinaryHeap<BH<'_>>>::None;
        _3 = Cell::<Option<&BinaryHeap<BH<'_>>>>::new(move _4) -> bb2;
    }

    bb2: {
        _0 = BH::<'_> { name: _1, mark: move _2, contents: move _3 };
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:639:1: 639:26>::name(_1: &BH<'_>) -> &str {
    debug self => _1;
    let mut _0: &str;

    bb0: {
        _0 = deref_copy ((*_1).0: &str);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:649:1: 649:32>::mark(_1: &BH<'_>) -> u32 {
    debug self => _1;
    let mut _0: u32;
    let mut _2: &std::cell::Cell<u32>;

    bb0: {
        _2 = &((*_1).1: std::cell::Cell<u32>);
        _0 = Cell::<u32>::get(move _2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:649:1: 649:32>::set_mark(_1: &BH<'_>, _2: u32) -> () {
    debug self => _1;
    debug mark => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: &std::cell::Cell<u32>;

    bb0: {
        _4 = &((*_1).1: std::cell::Cell<u32>);
        _3 = Cell::<u32>::set(move _4, _2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:656:1: 656:30>::eq(_1: &BH<'_>, _2: &BH<'_>) -> bool {
    debug self => _1;
    debug rhs => _2;
    let mut _0: bool;
    let mut _3: &&str;
    let mut _4: &&str;

    bb0: {
        _3 = &((*_1).0: &str);
        _4 = &((*_2).0: &str);
        _0 = <&str as PartialEq>::eq(move _3, move _4) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:662:1: 662:31>::partial_cmp(_1: &BH<'_>, _2: &BH<'_>) -> Option<std::cmp::Ordering> {
    debug self => _1;
    debug rhs => _2;
    let mut _0: std::option::Option<std::cmp::Ordering>;
    let mut _3: std::cmp::Ordering;

    bb0: {
        _3 = <BH<'_> as Ord>::cmp(_1, _2) -> bb1;
    }

    bb1: {
        _0 = Option::<std::cmp::Ordering>::Some(move _3);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:668:1: 668:24>::cmp(_1: &BH<'_>, _2: &BH<'_>) -> std::cmp::Ordering {
    debug self => _1;
    debug rhs => _2;
    let mut _0: std::cmp::Ordering;
    let mut _3: &str;
    let mut _4: &str;

    bb0: {
        _3 = deref_copy ((*_1).0: &str);
        _4 = deref_copy ((*_2).0: &str);
        _0 = <str as Ord>::cmp(_3, _4) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:680:1: 680:27>::new(_1: &str) -> BTM<'_> {
    debug name => _1;
    let mut _0: BTM<'_>;
    let mut _2: std::cell::Cell<u32>;
    let mut _3: std::cell::Cell<std::option::Option<&std::collections::BTreeMap<BTM<'_>, BTM<'_>>>>;
    let mut _4: std::option::Option<&std::collections::BTreeMap<BTM<'_>, BTM<'_>>>;

    bb0: {
        _2 = Cell::<u32>::new(const 0_u32) -> bb1;
    }

    bb1: {
        _4 = Option::<&BTreeMap<BTM<'_>, BTM<'_>>>::None;
        _3 = Cell::<Option<&BTreeMap<BTM<'_>, BTM<'_>>>>::new(move _4) -> bb2;
    }

    bb2: {
        _0 = BTM::<'_> { name: _1, mark: move _2, contents: move _3 };
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:680:1: 680:27>::name(_1: &BTM<'_>) -> &str {
    debug self => _1;
    let mut _0: &str;

    bb0: {
        _0 = deref_copy ((*_1).0: &str);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:690:1: 690:33>::mark(_1: &BTM<'_>) -> u32 {
    debug self => _1;
    let mut _0: u32;
    let mut _2: &std::cell::Cell<u32>;

    bb0: {
        _2 = &((*_1).1: std::cell::Cell<u32>);
        _0 = Cell::<u32>::get(move _2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:690:1: 690:33>::set_mark(_1: &BTM<'_>, _2: u32) -> () {
    debug self => _1;
    debug mark => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: &std::cell::Cell<u32>;

    bb0: {
        _4 = &((*_1).1: std::cell::Cell<u32>);
        _3 = Cell::<u32>::set(move _4, _2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:697:1: 697:31>::eq(_1: &BTM<'_>, _2: &BTM<'_>) -> bool {
    debug self => _1;
    debug rhs => _2;
    let mut _0: bool;
    let mut _3: &&str;
    let mut _4: &&str;

    bb0: {
        _3 = &((*_1).0: &str);
        _4 = &((*_2).0: &str);
        _0 = <&str as PartialEq>::eq(move _3, move _4) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:703:1: 703:32>::partial_cmp(_1: &BTM<'_>, _2: &BTM<'_>) -> Option<std::cmp::Ordering> {
    debug self => _1;
    debug rhs => _2;
    let mut _0: std::option::Option<std::cmp::Ordering>;
    let mut _3: std::cmp::Ordering;

    bb0: {
        _3 = <BTM<'_> as Ord>::cmp(_1, _2) -> bb1;
    }

    bb1: {
        _0 = Option::<std::cmp::Ordering>::Some(move _3);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:709:1: 709:25>::cmp(_1: &BTM<'_>, _2: &BTM<'_>) -> std::cmp::Ordering {
    debug self => _1;
    debug rhs => _2;
    let mut _0: std::cmp::Ordering;
    let mut _3: &str;
    let mut _4: &str;

    bb0: {
        _3 = deref_copy ((*_1).0: &str);
        _4 = deref_copy ((*_2).0: &str);
        _0 = <str as Ord>::cmp(_3, _4) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:721:1: 721:27>::new(_1: &str) -> BTS<'_> {
    debug name => _1;
    let mut _0: BTS<'_>;
    let mut _2: std::cell::Cell<u32>;
    let mut _3: std::cell::Cell<std::option::Option<&std::collections::BTreeSet<BTS<'_>>>>;
    let mut _4: std::option::Option<&std::collections::BTreeSet<BTS<'_>>>;

    bb0: {
        _2 = Cell::<u32>::new(const 0_u32) -> bb1;
    }

    bb1: {
        _4 = Option::<&BTreeSet<BTS<'_>>>::None;
        _3 = Cell::<Option<&BTreeSet<BTS<'_>>>>::new(move _4) -> bb2;
    }

    bb2: {
        _0 = BTS::<'_> { name: _1, mark: move _2, contents: move _3 };
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:721:1: 721:27>::name(_1: &BTS<'_>) -> &str {
    debug self => _1;
    let mut _0: &str;

    bb0: {
        _0 = deref_copy ((*_1).0: &str);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:731:1: 731:33>::mark(_1: &BTS<'_>) -> u32 {
    debug self => _1;
    let mut _0: u32;
    let mut _2: &std::cell::Cell<u32>;

    bb0: {
        _2 = &((*_1).1: std::cell::Cell<u32>);
        _0 = Cell::<u32>::get(move _2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:731:1: 731:33>::set_mark(_1: &BTS<'_>, _2: u32) -> () {
    debug self => _1;
    debug mark => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: &std::cell::Cell<u32>;

    bb0: {
        _4 = &((*_1).1: std::cell::Cell<u32>);
        _3 = Cell::<u32>::set(move _4, _2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:738:1: 738:31>::eq(_1: &BTS<'_>, _2: &BTS<'_>) -> bool {
    debug self => _1;
    debug rhs => _2;
    let mut _0: bool;
    let mut _3: &&str;
    let mut _4: &&str;

    bb0: {
        _3 = &((*_1).0: &str);
        _4 = &((*_2).0: &str);
        _0 = <&str as PartialEq>::eq(move _3, move _4) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:744:1: 744:32>::partial_cmp(_1: &BTS<'_>, _2: &BTS<'_>) -> Option<std::cmp::Ordering> {
    debug self => _1;
    debug rhs => _2;
    let mut _0: std::option::Option<std::cmp::Ordering>;
    let mut _3: std::cmp::Ordering;

    bb0: {
        _3 = <BTS<'_> as Ord>::cmp(_1, _2) -> bb1;
    }

    bb1: {
        _0 = Option::<std::cmp::Ordering>::Some(move _3);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:750:1: 750:25>::cmp(_1: &BTS<'_>, _2: &BTS<'_>) -> std::cmp::Ordering {
    debug self => _1;
    debug rhs => _2;
    let mut _0: std::cmp::Ordering;
    let mut _3: &str;
    let mut _4: &str;

    bb0: {
        _3 = deref_copy ((*_1).0: &str);
        _4 = deref_copy ((*_2).0: &str);
        _0 = <str as Ord>::cmp(_3, _4) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:756:10: 756:15>::clone(_1: &RCRCData<'_>) -> RCRCData<'_> {
    debug self => _1;
    let mut _0: RCRCData<'_>;
    let mut _2: &str;
    let _3: &str;
    let _4: &&str;
    let mut _5: std::cell::Cell<u32>;
    let _6: &std::cell::Cell<u32>;
    let mut _7: (std::option::Option<&RCRC<'_>>, std::option::Option<&RCRC<'_>>);
    let _8: &(std::option::Option<&RCRC<'_>>, std::option::Option<&RCRC<'_>>);

    bb0: {
        _4 = &((*_1).0: &str);
        _3 = <&str as Clone>::clone(_4) -> bb1;
    }

    bb1: {
        _2 = _3;
        _6 = &((*_1).1: std::cell::Cell<u32>);
        _5 = <Cell<u32> as Clone>::clone(_6) -> bb2;
    }

    bb2: {
        _8 = &((*_1).2: (std::option::Option<&RCRC<'_>>, std::option::Option<&RCRC<'_>>));
        _7 = <(Option<&RCRC<'_>>, Option<&RCRC<'_>>) as Clone>::clone(_8) -> bb3;
    }

    bb3: {
        _0 = RCRCData::<'_> { name: move _2, mark: move _5, children: move _7 };
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:762:10: 762:15>::clone(_1: &RCRC<'_>) -> RCRC<'_> {
    debug self => _1;
    let mut _0: RCRC<'_>;
    let mut _2: std::rc::Rc<std::cell::RefCell<RCRCData<'_>>>;
    let _3: &std::rc::Rc<std::cell::RefCell<RCRCData<'_>>>;

    bb0: {
        _3 = &((*_1).0: std::rc::Rc<std::cell::RefCell<RCRCData<'_>>>);
        _2 = <Rc<RefCell<RCRCData<'_>>> as Clone>::clone(_3) -> bb1;
    }

    bb1: {
        _0 = RCRC::<'_>(move _2);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:765:1: 765:28>::new(_1: &str) -> RCRC<'_> {
    debug name => _1;
    let mut _0: RCRC<'_>;
    let mut _2: std::rc::Rc<std::cell::RefCell<RCRCData<'_>>>;
    let mut _3: std::cell::RefCell<RCRCData<'_>>;
    let mut _4: RCRCData<'_>;
    let mut _5: std::cell::Cell<u32>;
    let mut _6: (std::option::Option<&RCRC<'_>>, std::option::Option<&RCRC<'_>>);
    let mut _7: std::option::Option<&RCRC<'_>>;
    let mut _8: std::option::Option<&RCRC<'_>>;

    bb0: {
        _5 = Cell::<u32>::new(const 0_u32) -> bb1;
    }

    bb1: {
        _7 = Option::<&RCRC<'_>>::None;
        _8 = Option::<&RCRC<'_>>::None;
        _6 = (move _7, move _8);
        _4 = RCRCData::<'_> { name: _1, mark: move _5, children: move _6 };
        _3 = RefCell::<RCRCData<'_>>::new(move _4) -> bb2;
    }

    bb2: {
        _2 = Rc::<RefCell<RCRCData<'_>>>::new(move _3) -> bb3;
    }

    bb3: {
        _0 = RCRC::<'_>(move _2);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:765:1: 765:28>::name(_1: &RCRC<'_>) -> &str {
    debug self => _1;
    let mut _0: &str;
    let _2: &RCRCData<'_>;
    let mut _3: &std::cell::Ref<'_, RCRCData<'_>>;
    let _4: std::cell::Ref<'_, RCRCData<'_>>;
    let mut _5: &std::cell::RefCell<RCRCData<'_>>;
    let _6: &std::cell::RefCell<RCRCData<'_>>;
    let mut _7: &std::rc::Rc<std::cell::RefCell<RCRCData<'_>>>;

    bb0: {
        _7 = &((*_1).0: std::rc::Rc<std::cell::RefCell<RCRCData<'_>>>);
        _6 = <Rc<RefCell<RCRCData<'_>>> as Deref>::deref(move _7) -> bb1;
    }

    bb1: {
        _5 = _6;
        _4 = RefCell::<RCRCData<'_>>::borrow(move _5) -> bb2;
    }

    bb2: {
        _3 = &_4;
        _2 = <Ref<'_, RCRCData<'_>> as Deref>::deref(move _3) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        _0 = deref_copy ((*_2).0: &str);
        drop(_4) -> bb4;
    }

    bb4: {
        return;
    }

    bb5 (cleanup): {
        drop(_4) -> [return: bb6, unwind terminate];
    }

    bb6 (cleanup): {
        resume;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:773:1: 773:34>::mark(_1: &RCRC<'_>) -> u32 {
    debug self => _1;
    let mut _0: u32;
    let mut _2: &std::cell::Cell<u32>;
    let _3: &RCRCData<'_>;
    let mut _4: &std::cell::Ref<'_, RCRCData<'_>>;
    let _5: std::cell::Ref<'_, RCRCData<'_>>;
    let mut _6: &std::cell::RefCell<RCRCData<'_>>;
    let _7: &std::cell::RefCell<RCRCData<'_>>;
    let mut _8: &std::rc::Rc<std::cell::RefCell<RCRCData<'_>>>;

    bb0: {
        _8 = &((*_1).0: std::rc::Rc<std::cell::RefCell<RCRCData<'_>>>);
        _7 = <Rc<RefCell<RCRCData<'_>>> as Deref>::deref(move _8) -> bb1;
    }

    bb1: {
        _6 = _7;
        _5 = RefCell::<RCRCData<'_>>::borrow(move _6) -> bb2;
    }

    bb2: {
        _4 = &_5;
        _3 = <Ref<'_, RCRCData<'_>> as Deref>::deref(move _4) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        _2 = &((*_3).1: std::cell::Cell<u32>);
        _0 = Cell::<u32>::get(move _2) -> [return: bb4, unwind: bb6];
    }

    bb4: {
        drop(_5) -> bb5;
    }

    bb5: {
        return;
    }

    bb6 (cleanup): {
        drop(_5) -> [return: bb7, unwind terminate];
    }

    bb7 (cleanup): {
        resume;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:773:1: 773:34>::set_mark(_1: &RCRC<'_>, _2: u32) -> () {
    debug self => _1;
    debug mark => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: &std::cell::Cell<u32>;
    let _5: &RCRCData<'_>;
    let mut _6: &std::cell::Ref<'_, RCRCData<'_>>;
    let _7: std::cell::Ref<'_, RCRCData<'_>>;
    let mut _8: &std::cell::RefCell<RCRCData<'_>>;
    let _9: &std::cell::RefCell<RCRCData<'_>>;
    let mut _10: &std::rc::Rc<std::cell::RefCell<RCRCData<'_>>>;

    bb0: {
        _10 = &((*_1).0: std::rc::Rc<std::cell::RefCell<RCRCData<'_>>>);
        _9 = <Rc<RefCell<RCRCData<'_>>> as Deref>::deref(move _10) -> bb1;
    }

    bb1: {
        _8 = _9;
        _7 = RefCell::<RCRCData<'_>>::borrow(move _8) -> bb2;
    }

    bb2: {
        _6 = &_7;
        _5 = <Ref<'_, RCRCData<'_>> as Deref>::deref(move _6) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        _4 = &((*_5).1: std::cell::Cell<u32>);
        _3 = Cell::<u32>::set(move _4, _2) -> [return: bb4, unwind: bb6];
    }

    bb4: {
        drop(_7) -> bb5;
    }

    bb5: {
        return;
    }

    bb6 (cleanup): {
        drop(_7) -> [return: bb7, unwind terminate];
    }

    bb7 (cleanup): {
        resume;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:778:1: 778:35>::count_children(_1: &RCRC<'_>) -> usize {
    debug self => _1;
    let mut _0: usize;

    bb0: {
        _0 = const 2_usize;
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:778:1: 778:35>::descend_one_child(_1: &RCRC<'_>, _2: &mut C, _3: usize) -> () {
    debug self => _1;
    debug context => _2;
    debug index => _3;
    let mut _0: ();
    let _4: &(std::option::Option<&RCRC<'_>>, std::option::Option<&RCRC<'_>>);
    let _5: &RCRCData<'_>;
    let mut _6: &std::cell::Ref<'_, RCRCData<'_>>;
    let _7: std::cell::Ref<'_, RCRCData<'_>>;
    let mut _8: &std::cell::RefCell<RCRCData<'_>>;
    let _9: &std::cell::RefCell<RCRCData<'_>>;
    let mut _10: &std::rc::Rc<std::cell::RefCell<RCRCData<'_>>>;
    let mut _12: isize;
    let mut _14: isize;
    let _16: !;
    let _17: ();
    let mut _18: &RCRC<'_>;
    scope 1 {
        debug children => _4;
        let _11: &RCRC<'_>;
        scope 2 {
            debug child => _11;
        }
        scope 3 {
            debug child => _13;
            let _13: &RCRC<'_>;
        }
        scope 4 {
            debug child => _15;
            let _15: &RCRC<'_>;
        }
    }

    bb0: {
        _10 = &((*_1).0: std::rc::Rc<std::cell::RefCell<RCRCData<'_>>>);
        _9 = <Rc<RefCell<RCRCData<'_>>> as Deref>::deref(move _10) -> bb1;
    }

    bb1: {
        _8 = _9;
        _7 = RefCell::<RCRCData<'_>>::borrow(move _8) -> bb2;
    }

    bb2: {
        _6 = &_7;
        _5 = <Ref<'_, RCRCData<'_>> as Deref>::deref(move _6) -> [return: bb3, unwind: bb13];
    }

    bb3: {
        _4 = &((*_5).2: (std::option::Option<&RCRC<'_>>, std::option::Option<&RCRC<'_>>));
        switchInt(_3) -> [0: bb5, 1: bb7, otherwise: bb4];
    }

    bb4: {
        _16 = begin_panic::<&str>(const "bad children") -> bb13;
    }

    bb5: {
        _12 = discriminant(((*_4).0: std::option::Option<&RCRC<'_>>));
        switchInt(move _12) -> [1: bb6, otherwise: bb11];
    }

    bb6: {
        _13 = ((((*_4).0: std::option::Option<&RCRC<'_>>) as Some).0: &RCRC<'_>);
        _11 = _13;
        goto -> bb9;
    }

    bb7: {
        _14 = discriminant(((*_4).1: std::option::Option<&RCRC<'_>>));
        switchInt(move _14) -> [1: bb8, otherwise: bb11];
    }

    bb8: {
        _15 = ((((*_4).1: std::option::Option<&RCRC<'_>>) as Some).0: &RCRC<'_>);
        _11 = _15;
        goto -> bb9;
    }

    bb9: {
        _18 = _11;
        _17 = <RCRC<'_> as Children<'_>>::descend_into_self::<C>(move _18, _2) -> [return: bb10, unwind: bb13];
    }

    bb10: {
        drop(_7) -> bb12;
    }

    bb11: {
        drop(_7) -> bb12;
    }

    bb12: {
        return;
    }

    bb13 (cleanup): {
        drop(_7) -> [return: bb14, unwind terminate];
    }

    bb14 (cleanup): {
        resume;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:793:10: 793:15>::clone(_1: &ARCRCData<'_>) -> ARCRCData<'_> {
    debug self => _1;
    let mut _0: ARCRCData<'_>;
    let mut _2: &str;
    let _3: &str;
    let _4: &&str;
    let mut _5: std::cell::Cell<u32>;
    let _6: &std::cell::Cell<u32>;
    let mut _7: (std::option::Option<&ARCRC<'_>>, std::option::Option<&ARCRC<'_>>);
    let _8: &(std::option::Option<&ARCRC<'_>>, std::option::Option<&ARCRC<'_>>);

    bb0: {
        _4 = &((*_1).0: &str);
        _3 = <&str as Clone>::clone(_4) -> bb1;
    }

    bb1: {
        _2 = _3;
        _6 = &((*_1).1: std::cell::Cell<u32>);
        _5 = <Cell<u32> as Clone>::clone(_6) -> bb2;
    }

    bb2: {
        _8 = &((*_1).2: (std::option::Option<&ARCRC<'_>>, std::option::Option<&ARCRC<'_>>));
        _7 = <(Option<&ARCRC<'_>>, Option<&ARCRC<'_>>) as Clone>::clone(_8) -> bb3;
    }

    bb3: {
        _0 = ARCRCData::<'_> { name: move _2, mark: move _5, children: move _7 };
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:799:10: 799:15>::clone(_1: &ARCRC<'_>) -> ARCRC<'_> {
    debug self => _1;
    let mut _0: ARCRC<'_>;
    let mut _2: std::sync::Arc<std::cell::RefCell<ARCRCData<'_>>>;
    let _3: &std::sync::Arc<std::cell::RefCell<ARCRCData<'_>>>;

    bb0: {
        _3 = &((*_1).0: std::sync::Arc<std::cell::RefCell<ARCRCData<'_>>>);
        _2 = <Arc<RefCell<ARCRCData<'_>>> as Clone>::clone(_3) -> bb1;
    }

    bb1: {
        _0 = ARCRC::<'_>(move _2);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:802:1: 802:29>::new(_1: &str) -> ARCRC<'_> {
    debug name => _1;
    let mut _0: ARCRC<'_>;
    let mut _2: std::sync::Arc<std::cell::RefCell<ARCRCData<'_>>>;
    let mut _3: std::cell::RefCell<ARCRCData<'_>>;
    let mut _4: ARCRCData<'_>;
    let mut _5: std::cell::Cell<u32>;
    let mut _6: (std::option::Option<&ARCRC<'_>>, std::option::Option<&ARCRC<'_>>);
    let mut _7: std::option::Option<&ARCRC<'_>>;
    let mut _8: std::option::Option<&ARCRC<'_>>;

    bb0: {
        _5 = Cell::<u32>::new(const 0_u32) -> bb1;
    }

    bb1: {
        _7 = Option::<&ARCRC<'_>>::None;
        _8 = Option::<&ARCRC<'_>>::None;
        _6 = (move _7, move _8);
        _4 = ARCRCData::<'_> { name: _1, mark: move _5, children: move _6 };
        _3 = RefCell::<ARCRCData<'_>>::new(move _4) -> bb2;
    }

    bb2: {
        _2 = Arc::<RefCell<ARCRCData<'_>>>::new(move _3) -> bb3;
    }

    bb3: {
        _0 = ARCRC::<'_>(move _2);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:802:1: 802:29>::name(_1: &ARCRC<'_>) -> &str {
    debug self => _1;
    let mut _0: &str;
    let _2: &ARCRCData<'_>;
    let mut _3: &std::cell::Ref<'_, ARCRCData<'_>>;
    let _4: std::cell::Ref<'_, ARCRCData<'_>>;
    let mut _5: &std::cell::RefCell<ARCRCData<'_>>;
    let _6: &std::cell::RefCell<ARCRCData<'_>>;
    let mut _7: &std::sync::Arc<std::cell::RefCell<ARCRCData<'_>>>;

    bb0: {
        _7 = &((*_1).0: std::sync::Arc<std::cell::RefCell<ARCRCData<'_>>>);
        _6 = <Arc<RefCell<ARCRCData<'_>>> as Deref>::deref(move _7) -> bb1;
    }

    bb1: {
        _5 = _6;
        _4 = RefCell::<ARCRCData<'_>>::borrow(move _5) -> bb2;
    }

    bb2: {
        _3 = &_4;
        _2 = <Ref<'_, ARCRCData<'_>> as Deref>::deref(move _3) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        _0 = deref_copy ((*_2).0: &str);
        drop(_4) -> bb4;
    }

    bb4: {
        return;
    }

    bb5 (cleanup): {
        drop(_4) -> [return: bb6, unwind terminate];
    }

    bb6 (cleanup): {
        resume;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:810:1: 810:35>::mark(_1: &ARCRC<'_>) -> u32 {
    debug self => _1;
    let mut _0: u32;
    let mut _2: &std::cell::Cell<u32>;
    let _3: &ARCRCData<'_>;
    let mut _4: &std::cell::Ref<'_, ARCRCData<'_>>;
    let _5: std::cell::Ref<'_, ARCRCData<'_>>;
    let mut _6: &std::cell::RefCell<ARCRCData<'_>>;
    let _7: &std::cell::RefCell<ARCRCData<'_>>;
    let mut _8: &std::sync::Arc<std::cell::RefCell<ARCRCData<'_>>>;

    bb0: {
        _8 = &((*_1).0: std::sync::Arc<std::cell::RefCell<ARCRCData<'_>>>);
        _7 = <Arc<RefCell<ARCRCData<'_>>> as Deref>::deref(move _8) -> bb1;
    }

    bb1: {
        _6 = _7;
        _5 = RefCell::<ARCRCData<'_>>::borrow(move _6) -> bb2;
    }

    bb2: {
        _4 = &_5;
        _3 = <Ref<'_, ARCRCData<'_>> as Deref>::deref(move _4) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        _2 = &((*_3).1: std::cell::Cell<u32>);
        _0 = Cell::<u32>::get(move _2) -> [return: bb4, unwind: bb6];
    }

    bb4: {
        drop(_5) -> bb5;
    }

    bb5: {
        return;
    }

    bb6 (cleanup): {
        drop(_5) -> [return: bb7, unwind terminate];
    }

    bb7 (cleanup): {
        resume;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:810:1: 810:35>::set_mark(_1: &ARCRC<'_>, _2: u32) -> () {
    debug self => _1;
    debug mark => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: &std::cell::Cell<u32>;
    let _5: &ARCRCData<'_>;
    let mut _6: &std::cell::Ref<'_, ARCRCData<'_>>;
    let _7: std::cell::Ref<'_, ARCRCData<'_>>;
    let mut _8: &std::cell::RefCell<ARCRCData<'_>>;
    let _9: &std::cell::RefCell<ARCRCData<'_>>;
    let mut _10: &std::sync::Arc<std::cell::RefCell<ARCRCData<'_>>>;

    bb0: {
        _10 = &((*_1).0: std::sync::Arc<std::cell::RefCell<ARCRCData<'_>>>);
        _9 = <Arc<RefCell<ARCRCData<'_>>> as Deref>::deref(move _10) -> bb1;
    }

    bb1: {
        _8 = _9;
        _7 = RefCell::<ARCRCData<'_>>::borrow(move _8) -> bb2;
    }

    bb2: {
        _6 = &_7;
        _5 = <Ref<'_, ARCRCData<'_>> as Deref>::deref(move _6) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        _4 = &((*_5).1: std::cell::Cell<u32>);
        _3 = Cell::<u32>::set(move _4, _2) -> [return: bb4, unwind: bb6];
    }

    bb4: {
        drop(_7) -> bb5;
    }

    bb5: {
        return;
    }

    bb6 (cleanup): {
        drop(_7) -> [return: bb7, unwind terminate];
    }

    bb7 (cleanup): {
        resume;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:815:1: 815:36>::count_children(_1: &ARCRC<'_>) -> usize {
    debug self => _1;
    let mut _0: usize;

    bb0: {
        _0 = const 2_usize;
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:815:1: 815:36>::descend_one_child(_1: &ARCRC<'_>, _2: &mut C, _3: usize) -> () {
    debug self => _1;
    debug context => _2;
    debug index => _3;
    let mut _0: ();
    let _4: &(std::option::Option<&ARCRC<'_>>, std::option::Option<&ARCRC<'_>>);
    let _5: &ARCRCData<'_>;
    let mut _6: &std::cell::Ref<'_, ARCRCData<'_>>;
    let _7: std::cell::Ref<'_, ARCRCData<'_>>;
    let mut _8: &std::cell::RefCell<ARCRCData<'_>>;
    let _9: &std::cell::RefCell<ARCRCData<'_>>;
    let mut _10: &std::sync::Arc<std::cell::RefCell<ARCRCData<'_>>>;
    let mut _11: isize;
    let _13: ();
    let mut _14: isize;
    let _16: ();
    let _17: !;
    let mut _18: &ARCRC<'_>;
    let mut _19: &ARCRC<'_>;
    scope 1 {
        debug children => _4;
        scope 2 {
            debug child => _12;
            let _12: &&ARCRC<'_>;
        }
        scope 3 {
            debug child => _15;
            let _15: &&ARCRC<'_>;
        }
    }

    bb0: {
        _10 = &((*_1).0: std::sync::Arc<std::cell::RefCell<ARCRCData<'_>>>);
        _9 = <Arc<RefCell<ARCRCData<'_>>> as Deref>::deref(move _10) -> bb1;
    }

    bb1: {
        _8 = _9;
        _7 = RefCell::<ARCRCData<'_>>::borrow(move _8) -> bb2;
    }

    bb2: {
        _6 = &_7;
        _5 = <Ref<'_, ARCRCData<'_>> as Deref>::deref(move _6) -> [return: bb3, unwind: bb11];
    }

    bb3: {
        _4 = &((*_5).2: (std::option::Option<&ARCRC<'_>>, std::option::Option<&ARCRC<'_>>));
        switchInt(_3) -> [0: bb5, 1: bb7, otherwise: bb4];
    }

    bb4: {
        _17 = begin_panic::<&str>(const "bad children!") -> bb11;
    }

    bb5: {
        _11 = discriminant(((*_4).0: std::option::Option<&ARCRC<'_>>));
        switchInt(move _11) -> [1: bb6, otherwise: bb9];
    }

    bb6: {
        _12 = &((((*_4).0: std::option::Option<&ARCRC<'_>>) as Some).0: &ARCRC<'_>);
        _18 = deref_copy (*_12);
        _13 = <ARCRC<'_> as Children<'_>>::descend_into_self::<C>(_18, _2) -> [return: bb13, unwind: bb11];
    }

    bb7: {
        _14 = discriminant(((*_4).1: std::option::Option<&ARCRC<'_>>));
        switchInt(move _14) -> [1: bb8, otherwise: bb9];
    }

    bb8: {
        _15 = &((((*_4).1: std::option::Option<&ARCRC<'_>>) as Some).0: &ARCRC<'_>);
        _19 = deref_copy (*_15);
        _16 = <ARCRC<'_> as Children<'_>>::descend_into_self::<C>(_19, _2) -> [return: bb14, unwind: bb11];
    }

    bb9: {
        drop(_7) -> bb10;
    }

    bb10: {
        return;
    }

    bb11 (cleanup): {
        drop(_7) -> [return: bb12, unwind terminate];
    }

    bb12 (cleanup): {
        resume;
    }

    bb13: {
        goto -> bb9;
    }

    bb14: {
        goto -> bb9;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:833:10: 833:15>::clone(_1: &ARCMData<'_>) -> ARCMData<'_> {
    debug self => _1;
    let mut _0: ARCMData<'_>;
    let mut _2: std::cell::Cell<u32>;
    let _3: &std::cell::Cell<u32>;
    let mut _4: (std::option::Option<&ARCM<'_>>, std::option::Option<&ARCM<'_>>);
    let _5: &(std::option::Option<&ARCM<'_>>, std::option::Option<&ARCM<'_>>);

    bb0: {
        _3 = &((*_1).0: std::cell::Cell<u32>);
        _2 = <Cell<u32> as Clone>::clone(_3) -> bb1;
    }

    bb1: {
        _5 = &((*_1).1: (std::option::Option<&ARCM<'_>>, std::option::Option<&ARCM<'_>>));
        _4 = <(Option<&ARCM<'_>>, Option<&ARCM<'_>>) as Clone>::clone(_5) -> bb2;
    }

    bb2: {
        _0 = ARCMData::<'_> { mark: move _2, children: move _4 };
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:839:10: 839:15>::clone(_1: &ARCM<'_>) -> ARCM<'_> {
    debug self => _1;
    let mut _0: ARCM<'_>;
    let mut _2: &str;
    let _3: &str;
    let _4: &&str;
    let mut _5: std::sync::Arc<std::sync::Mutex<ARCMData<'_>>>;
    let _6: &std::sync::Arc<std::sync::Mutex<ARCMData<'_>>>;

    bb0: {
        _4 = &((*_1).0: &str);
        _3 = <&str as Clone>::clone(_4) -> bb1;
    }

    bb1: {
        _2 = _3;
        _6 = &((*_1).1: std::sync::Arc<std::sync::Mutex<ARCMData<'_>>>);
        _5 = <Arc<Mutex<ARCMData<'_>>> as Clone>::clone(_6) -> bb2;
    }

    bb2: {
        _0 = ARCM::<'_>(move _2, move _5);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:842:1: 842:28>::new(_1: &str) -> ARCM<'_> {
    debug name => _1;
    let mut _0: ARCM<'_>;
    let mut _2: std::sync::Arc<std::sync::Mutex<ARCMData<'_>>>;
    let mut _3: std::sync::Mutex<ARCMData<'_>>;
    let mut _4: ARCMData<'_>;
    let mut _5: std::cell::Cell<u32>;
    let mut _6: (std::option::Option<&ARCM<'_>>, std::option::Option<&ARCM<'_>>);
    let mut _7: std::option::Option<&ARCM<'_>>;
    let mut _8: std::option::Option<&ARCM<'_>>;

    bb0: {
        _5 = Cell::<u32>::new(const 0_u32) -> bb1;
    }

    bb1: {
        _7 = Option::<&ARCM<'_>>::None;
        _8 = Option::<&ARCM<'_>>::None;
        _6 = (move _7, move _8);
        _4 = ARCMData::<'_> { mark: move _5, children: move _6 };
        _3 = Mutex::<ARCMData<'_>>::new(move _4) -> bb2;
    }

    bb2: {
        _2 = Arc::<Mutex<ARCMData<'_>>>::new(move _3) -> bb3;
    }

    bb3: {
        _0 = ARCM::<'_>(_1, move _2);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:842:1: 842:28>::name(_1: &ARCM<'_>) -> &str {
    debug self => _1;
    let mut _0: &str;

    bb0: {
        _0 = deref_copy ((*_1).0: &str);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:850:1: 850:34>::mark(_1: &ARCM<'_>) -> u32 {
    debug self => _1;
    let mut _0: u32;
    let mut _2: &std::cell::Cell<u32>;
    let _3: &ARCMData<'_>;
    let mut _4: &std::sync::MutexGuard<'_, ARCMData<'_>>;
    let _5: std::sync::MutexGuard<'_, ARCMData<'_>>;
    let mut _6: std::result::Result<std::sync::MutexGuard<'_, ARCMData<'_>>, std::sync::PoisonError<std::sync::MutexGuard<'_, ARCMData<'_>>>>;
    let mut _7: &std::sync::Mutex<ARCMData<'_>>;
    let _8: &std::sync::Mutex<ARCMData<'_>>;
    let mut _9: &std::sync::Arc<std::sync::Mutex<ARCMData<'_>>>;

    bb0: {
        _9 = &((*_1).1: std::sync::Arc<std::sync::Mutex<ARCMData<'_>>>);
        _8 = <Arc<Mutex<ARCMData<'_>>> as Deref>::deref(move _9) -> bb1;
    }

    bb1: {
        _7 = _8;
        _6 = Mutex::<ARCMData<'_>>::lock(move _7) -> bb2;
    }

    bb2: {
        _5 = Result::<MutexGuard<'_, ARCMData<'_>>, PoisonError<MutexGuard<'_, ARCMData<'_>>>>::unwrap(move _6) -> bb3;
    }

    bb3: {
        _4 = &_5;
        _3 = <MutexGuard<'_, ARCMData<'_>> as Deref>::deref(move _4) -> [return: bb4, unwind: bb7];
    }

    bb4: {
        _2 = &((*_3).0: std::cell::Cell<u32>);
        _0 = Cell::<u32>::get(move _2) -> [return: bb5, unwind: bb7];
    }

    bb5: {
        drop(_5) -> bb6;
    }

    bb6: {
        return;
    }

    bb7 (cleanup): {
        drop(_5) -> [return: bb8, unwind terminate];
    }

    bb8 (cleanup): {
        resume;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:850:1: 850:34>::set_mark(_1: &ARCM<'_>, _2: u32) -> () {
    debug self => _1;
    debug mark => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: &std::cell::Cell<u32>;
    let _5: &ARCMData<'_>;
    let mut _6: &std::sync::MutexGuard<'_, ARCMData<'_>>;
    let _7: std::sync::MutexGuard<'_, ARCMData<'_>>;
    let mut _8: std::result::Result<std::sync::MutexGuard<'_, ARCMData<'_>>, std::sync::PoisonError<std::sync::MutexGuard<'_, ARCMData<'_>>>>;
    let mut _9: &std::sync::Mutex<ARCMData<'_>>;
    let _10: &std::sync::Mutex<ARCMData<'_>>;
    let mut _11: &std::sync::Arc<std::sync::Mutex<ARCMData<'_>>>;

    bb0: {
        _11 = &((*_1).1: std::sync::Arc<std::sync::Mutex<ARCMData<'_>>>);
        _10 = <Arc<Mutex<ARCMData<'_>>> as Deref>::deref(move _11) -> bb1;
    }

    bb1: {
        _9 = _10;
        _8 = Mutex::<ARCMData<'_>>::lock(move _9) -> bb2;
    }

    bb2: {
        _7 = Result::<MutexGuard<'_, ARCMData<'_>>, PoisonError<MutexGuard<'_, ARCMData<'_>>>>::unwrap(move _8) -> bb3;
    }

    bb3: {
        _6 = &_7;
        _5 = <MutexGuard<'_, ARCMData<'_>> as Deref>::deref(move _6) -> [return: bb4, unwind: bb7];
    }

    bb4: {
        _4 = &((*_5).0: std::cell::Cell<u32>);
        _3 = Cell::<u32>::set(move _4, _2) -> [return: bb5, unwind: bb7];
    }

    bb5: {
        drop(_7) -> bb6;
    }

    bb6: {
        return;
    }

    bb7 (cleanup): {
        drop(_7) -> [return: bb8, unwind terminate];
    }

    bb8 (cleanup): {
        resume;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:855:1: 855:35>::count_children(_1: &ARCM<'_>) -> usize {
    debug self => _1;
    let mut _0: usize;

    bb0: {
        _0 = const 2_usize;
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:855:1: 855:35>::descend_one_child(_1: &ARCM<'_>, _2: &mut C, _3: usize) -> () {
    debug self => _1;
    debug context => _2;
    debug index => _3;
    let mut _0: ();
    let _4: &(std::option::Option<&ARCM<'_>>, std::option::Option<&ARCM<'_>>);
    let mut _5: (std::option::Option<&ARCM<'_>>, std::option::Option<&ARCM<'_>>);
    let mut _6: std::result::Result<std::sync::MutexGuard<'_, ARCMData<'_>>, std::sync::TryLockError<std::sync::MutexGuard<'_, ARCMData<'_>>>>;
    let mut _7: &std::sync::Mutex<ARCMData<'_>>;
    let _8: &std::sync::Mutex<ARCMData<'_>>;
    let mut _9: &std::sync::Arc<std::sync::Mutex<ARCMData<'_>>>;
    let mut _10: isize;
    let mut _12: &ARCMData<'_>;
    let mut _13: &std::sync::MutexGuard<'_, ARCMData<'_>>;
    let mut _14: isize;
    let _16: ();
    let mut _17: isize;
    let _19: ();
    let _20: !;
    let mut _21: &ARCM<'_>;
    let mut _22: &ARCM<'_>;
    let mut _23: isize;
    let mut _24: isize;
    scope 1 {
        debug children => _4;
        scope 3 {
            debug child => _15;
            let _15: &&ARCM<'_>;
        }
        scope 4 {
            debug child => _18;
            let _18: &&ARCM<'_>;
        }
    }
    scope 2 {
        debug data => _11;
        let _11: std::sync::MutexGuard<'_, ARCMData<'_>>;
    }

    bb0: {
        _9 = &((*_1).1: std::sync::Arc<std::sync::Mutex<ARCMData<'_>>>);
        _8 = <Arc<Mutex<ARCMData<'_>>> as Deref>::deref(move _9) -> bb1;
    }

    bb1: {
        _7 = _8;
        _6 = Mutex::<ARCMData<'_>>::try_lock(move _7) -> bb2;
    }

    bb2: {
        _10 = discriminant(_6);
        switchInt(move _10) -> [0: bb3, otherwise: bb5];
    }

    bb3: {
        _11 = move ((_6 as Ok).0: std::sync::MutexGuard<'_, ARCMData<'_>>);
        _13 = &_11;
        _12 = <MutexGuard<'_, ARCMData<'_>> as Deref>::deref(move _13) -> [return: bb4, unwind: bb13];
    }

    bb4: {
        _5 = ((*_12).1: (std::option::Option<&ARCM<'_>>, std::option::Option<&ARCM<'_>>));
        drop(_11) -> [return: bb6, unwind: bb18];
    }

    bb5: {
        drop(_6) -> bb12;
    }

    bb6: {
        _4 = &_5;
        _23 = discriminant(_6);
        switchInt(move _23) -> [0: bb15, otherwise: bb16];
    }

    bb7: {
        _20 = begin_panic::<&str>(const "bad children!");
    }

    bb8: {
        _14 = discriminant(((*_4).0: std::option::Option<&ARCM<'_>>));
        switchInt(move _14) -> [1: bb9, otherwise: bb12];
    }

    bb9: {
        _15 = &((((*_4).0: std::option::Option<&ARCM<'_>>) as Some).0: &ARCM<'_>);
        _21 = deref_copy (*_15);
        _16 = <ARCM<'_> as Children<'_>>::descend_into_self::<C>(_21, _2) -> bb12;
    }

    bb10: {
        _17 = discriminant(((*_4).1: std::option::Option<&ARCM<'_>>));
        switchInt(move _17) -> [1: bb11, otherwise: bb12];
    }

    bb11: {
        _18 = &((((*_4).1: std::option::Option<&ARCM<'_>>) as Some).0: &ARCM<'_>);
        _22 = deref_copy (*_18);
        _19 = <ARCM<'_> as Children<'_>>::descend_into_self::<C>(_22, _2) -> bb12;
    }

    bb12: {
        return;
    }

    bb13 (cleanup): {
        drop(_11) -> [return: bb18, unwind terminate];
    }

    bb14 (cleanup): {
        resume;
    }

    bb15: {
        switchInt(_3) -> [0: bb8, 1: bb10, otherwise: bb7];
    }

    bb16: {
        drop(_6) -> bb15;
    }

    bb17 (cleanup): {
        drop(_6) -> [return: bb14, unwind terminate];
    }

    bb18 (cleanup): {
        _24 = discriminant(_6);
        switchInt(move _24) -> [0: bb14, otherwise: bb17];
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:875:10: 875:15>::clone(_1: &ARCRWData<'_>) -> ARCRWData<'_> {
    debug self => _1;
    let mut _0: ARCRWData<'_>;
    let mut _2: &str;
    let _3: &str;
    let _4: &&str;
    let mut _5: std::cell::Cell<u32>;
    let _6: &std::cell::Cell<u32>;
    let mut _7: (std::option::Option<&ARCRW<'_>>, std::option::Option<&ARCRW<'_>>);
    let _8: &(std::option::Option<&ARCRW<'_>>, std::option::Option<&ARCRW<'_>>);

    bb0: {
        _4 = &((*_1).0: &str);
        _3 = <&str as Clone>::clone(_4) -> bb1;
    }

    bb1: {
        _2 = _3;
        _6 = &((*_1).1: std::cell::Cell<u32>);
        _5 = <Cell<u32> as Clone>::clone(_6) -> bb2;
    }

    bb2: {
        _8 = &((*_1).2: (std::option::Option<&ARCRW<'_>>, std::option::Option<&ARCRW<'_>>));
        _7 = <(Option<&ARCRW<'_>>, Option<&ARCRW<'_>>) as Clone>::clone(_8) -> bb3;
    }

    bb3: {
        _0 = ARCRWData::<'_> { name: move _2, mark: move _5, children: move _7 };
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:882:10: 882:15>::clone(_1: &ARCRW<'_>) -> ARCRW<'_> {
    debug self => _1;
    let mut _0: ARCRW<'_>;
    let mut _2: std::sync::Arc<std::sync::RwLock<ARCRWData<'_>>>;
    let _3: &std::sync::Arc<std::sync::RwLock<ARCRWData<'_>>>;

    bb0: {
        _3 = &((*_1).0: std::sync::Arc<std::sync::RwLock<ARCRWData<'_>>>);
        _2 = <Arc<RwLock<ARCRWData<'_>>> as Clone>::clone(_3) -> bb1;
    }

    bb1: {
        _0 = ARCRW::<'_>(move _2);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:885:1: 885:29>::new(_1: &str) -> ARCRW<'_> {
    debug name => _1;
    let mut _0: ARCRW<'_>;
    let mut _2: std::sync::Arc<std::sync::RwLock<ARCRWData<'_>>>;
    let mut _3: std::sync::RwLock<ARCRWData<'_>>;
    let mut _4: ARCRWData<'_>;
    let mut _5: std::cell::Cell<u32>;
    let mut _6: (std::option::Option<&ARCRW<'_>>, std::option::Option<&ARCRW<'_>>);
    let mut _7: std::option::Option<&ARCRW<'_>>;
    let mut _8: std::option::Option<&ARCRW<'_>>;

    bb0: {
        _5 = Cell::<u32>::new(const 0_u32) -> bb1;
    }

    bb1: {
        _7 = Option::<&ARCRW<'_>>::None;
        _8 = Option::<&ARCRW<'_>>::None;
        _6 = (move _7, move _8);
        _4 = ARCRWData::<'_> { name: _1, mark: move _5, children: move _6 };
        _3 = RwLock::<ARCRWData<'_>>::new(move _4) -> bb2;
    }

    bb2: {
        _2 = Arc::<RwLock<ARCRWData<'_>>>::new(move _3) -> bb3;
    }

    bb3: {
        _0 = ARCRW::<'_>(move _2);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:885:1: 885:29>::name(_1: &ARCRW<'_>) -> &str {
    debug self => _1;
    let mut _0: &str;
    let _2: &ARCRWData<'_>;
    let mut _3: &std::sync::RwLockReadGuard<'_, ARCRWData<'_>>;
    let _4: std::sync::RwLockReadGuard<'_, ARCRWData<'_>>;
    let mut _5: std::result::Result<std::sync::RwLockReadGuard<'_, ARCRWData<'_>>, std::sync::PoisonError<std::sync::RwLockReadGuard<'_, ARCRWData<'_>>>>;
    let mut _6: &std::sync::RwLock<ARCRWData<'_>>;
    let _7: &std::sync::RwLock<ARCRWData<'_>>;
    let mut _8: &std::sync::Arc<std::sync::RwLock<ARCRWData<'_>>>;

    bb0: {
        _8 = &((*_1).0: std::sync::Arc<std::sync::RwLock<ARCRWData<'_>>>);
        _7 = <Arc<RwLock<ARCRWData<'_>>> as Deref>::deref(move _8) -> bb1;
    }

    bb1: {
        _6 = _7;
        _5 = RwLock::<ARCRWData<'_>>::read(move _6) -> bb2;
    }

    bb2: {
        _4 = Result::<RwLockReadGuard<'_, ARCRWData<'_>>, PoisonError<RwLockReadGuard<'_, ARCRWData<'_>>>>::unwrap(move _5) -> bb3;
    }

    bb3: {
        _3 = &_4;
        _2 = <RwLockReadGuard<'_, ARCRWData<'_>> as Deref>::deref(move _3) -> [return: bb4, unwind: bb6];
    }

    bb4: {
        _0 = deref_copy ((*_2).0: &str);
        drop(_4) -> bb5;
    }

    bb5: {
        return;
    }

    bb6 (cleanup): {
        drop(_4) -> [return: bb7, unwind terminate];
    }

    bb7 (cleanup): {
        resume;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:893:1: 893:35>::mark(_1: &ARCRW<'_>) -> u32 {
    debug self => _1;
    let mut _0: u32;
    let mut _2: &std::cell::Cell<u32>;
    let _3: &ARCRWData<'_>;
    let mut _4: &std::sync::RwLockReadGuard<'_, ARCRWData<'_>>;
    let _5: std::sync::RwLockReadGuard<'_, ARCRWData<'_>>;
    let mut _6: std::result::Result<std::sync::RwLockReadGuard<'_, ARCRWData<'_>>, std::sync::PoisonError<std::sync::RwLockReadGuard<'_, ARCRWData<'_>>>>;
    let mut _7: &std::sync::RwLock<ARCRWData<'_>>;
    let _8: &std::sync::RwLock<ARCRWData<'_>>;
    let mut _9: &std::sync::Arc<std::sync::RwLock<ARCRWData<'_>>>;

    bb0: {
        _9 = &((*_1).0: std::sync::Arc<std::sync::RwLock<ARCRWData<'_>>>);
        _8 = <Arc<RwLock<ARCRWData<'_>>> as Deref>::deref(move _9) -> bb1;
    }

    bb1: {
        _7 = _8;
        _6 = RwLock::<ARCRWData<'_>>::read(move _7) -> bb2;
    }

    bb2: {
        _5 = Result::<RwLockReadGuard<'_, ARCRWData<'_>>, PoisonError<RwLockReadGuard<'_, ARCRWData<'_>>>>::unwrap(move _6) -> bb3;
    }

    bb3: {
        _4 = &_5;
        _3 = <RwLockReadGuard<'_, ARCRWData<'_>> as Deref>::deref(move _4) -> [return: bb4, unwind: bb7];
    }

    bb4: {
        _2 = &((*_3).1: std::cell::Cell<u32>);
        _0 = Cell::<u32>::get(move _2) -> [return: bb5, unwind: bb7];
    }

    bb5: {
        drop(_5) -> bb6;
    }

    bb6: {
        return;
    }

    bb7 (cleanup): {
        drop(_5) -> [return: bb8, unwind terminate];
    }

    bb8 (cleanup): {
        resume;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:893:1: 893:35>::set_mark(_1: &ARCRW<'_>, _2: u32) -> () {
    debug self => _1;
    debug mark => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: &std::cell::Cell<u32>;
    let _5: &ARCRWData<'_>;
    let mut _6: &std::sync::RwLockReadGuard<'_, ARCRWData<'_>>;
    let _7: std::sync::RwLockReadGuard<'_, ARCRWData<'_>>;
    let mut _8: std::result::Result<std::sync::RwLockReadGuard<'_, ARCRWData<'_>>, std::sync::PoisonError<std::sync::RwLockReadGuard<'_, ARCRWData<'_>>>>;
    let mut _9: &std::sync::RwLock<ARCRWData<'_>>;
    let _10: &std::sync::RwLock<ARCRWData<'_>>;
    let mut _11: &std::sync::Arc<std::sync::RwLock<ARCRWData<'_>>>;

    bb0: {
        _11 = &((*_1).0: std::sync::Arc<std::sync::RwLock<ARCRWData<'_>>>);
        _10 = <Arc<RwLock<ARCRWData<'_>>> as Deref>::deref(move _11) -> bb1;
    }

    bb1: {
        _9 = _10;
        _8 = RwLock::<ARCRWData<'_>>::read(move _9) -> bb2;
    }

    bb2: {
        _7 = Result::<RwLockReadGuard<'_, ARCRWData<'_>>, PoisonError<RwLockReadGuard<'_, ARCRWData<'_>>>>::unwrap(move _8) -> bb3;
    }

    bb3: {
        _6 = &_7;
        _5 = <RwLockReadGuard<'_, ARCRWData<'_>> as Deref>::deref(move _6) -> [return: bb4, unwind: bb7];
    }

    bb4: {
        _4 = &((*_5).1: std::cell::Cell<u32>);
        _3 = Cell::<u32>::set(move _4, _2) -> [return: bb5, unwind: bb7];
    }

    bb5: {
        drop(_7) -> bb6;
    }

    bb6: {
        return;
    }

    bb7 (cleanup): {
        drop(_7) -> [return: bb8, unwind terminate];
    }

    bb8 (cleanup): {
        resume;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:898:1: 898:36>::count_children(_1: &ARCRW<'_>) -> usize {
    debug self => _1;
    let mut _0: usize;

    bb0: {
        _0 = const 2_usize;
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:898:1: 898:36>::descend_one_child(_1: &ARCRW<'_>, _2: &mut C, _3: usize) -> () {
    debug self => _1;
    debug context => _2;
    debug index => _3;
    let mut _0: ();
    let _4: &(std::option::Option<&ARCRW<'_>>, std::option::Option<&ARCRW<'_>>);
    let _5: &ARCRWData<'_>;
    let mut _6: &std::sync::RwLockReadGuard<'_, ARCRWData<'_>>;
    let _7: std::sync::RwLockReadGuard<'_, ARCRWData<'_>>;
    let mut _8: std::result::Result<std::sync::RwLockReadGuard<'_, ARCRWData<'_>>, std::sync::PoisonError<std::sync::RwLockReadGuard<'_, ARCRWData<'_>>>>;
    let mut _9: &std::sync::RwLock<ARCRWData<'_>>;
    let _10: &std::sync::RwLock<ARCRWData<'_>>;
    let mut _11: &std::sync::Arc<std::sync::RwLock<ARCRWData<'_>>>;
    let mut _12: isize;
    let _14: ();
    let mut _15: isize;
    let _17: ();
    let _18: !;
    let mut _19: &ARCRW<'_>;
    let mut _20: &ARCRW<'_>;
    scope 1 {
        debug children => _4;
        scope 2 {
            debug child => _13;
            let _13: &&ARCRW<'_>;
        }
        scope 3 {
            debug child => _16;
            let _16: &&ARCRW<'_>;
        }
    }

    bb0: {
        _11 = &((*_1).0: std::sync::Arc<std::sync::RwLock<ARCRWData<'_>>>);
        _10 = <Arc<RwLock<ARCRWData<'_>>> as Deref>::deref(move _11) -> bb1;
    }

    bb1: {
        _9 = _10;
        _8 = RwLock::<ARCRWData<'_>>::read(move _9) -> bb2;
    }

    bb2: {
        _7 = Result::<RwLockReadGuard<'_, ARCRWData<'_>>, PoisonError<RwLockReadGuard<'_, ARCRWData<'_>>>>::unwrap(move _8) -> bb3;
    }

    bb3: {
        _6 = &_7;
        _5 = <RwLockReadGuard<'_, ARCRWData<'_>> as Deref>::deref(move _6) -> [return: bb4, unwind: bb12];
    }

    bb4: {
        _4 = &((*_5).2: (std::option::Option<&ARCRW<'_>>, std::option::Option<&ARCRW<'_>>));
        switchInt(_3) -> [0: bb6, 1: bb8, otherwise: bb5];
    }

    bb5: {
        _18 = begin_panic::<&str>(const "bad children!") -> bb12;
    }

    bb6: {
        _12 = discriminant(((*_4).0: std::option::Option<&ARCRW<'_>>));
        switchInt(move _12) -> [1: bb7, otherwise: bb10];
    }

    bb7: {
        _13 = &((((*_4).0: std::option::Option<&ARCRW<'_>>) as Some).0: &ARCRW<'_>);
        _19 = deref_copy (*_13);
        _14 = <ARCRW<'_> as Children<'_>>::descend_into_self::<C>(_19, _2) -> [return: bb14, unwind: bb12];
    }

    bb8: {
        _15 = discriminant(((*_4).1: std::option::Option<&ARCRW<'_>>));
        switchInt(move _15) -> [1: bb9, otherwise: bb10];
    }

    bb9: {
        _16 = &((((*_4).1: std::option::Option<&ARCRW<'_>>) as Some).0: &ARCRW<'_>);
        _20 = deref_copy (*_16);
        _17 = <ARCRW<'_> as Children<'_>>::descend_into_self::<C>(_20, _2) -> [return: bb15, unwind: bb12];
    }

    bb10: {
        drop(_7) -> bb11;
    }

    bb11: {
        return;
    }

    bb12 (cleanup): {
        drop(_7) -> [return: bb13, unwind terminate];
    }

    bb13 (cleanup): {
        resume;
    }

    bb14: {
        goto -> bb10;
    }

    bb15: {
        goto -> bb10;
    }
}

fn Children::next_child(_1: &Self, _2: &mut C) -> () {
    debug self => _1;
    debug context => _2;
    let mut _0: ();
    let _3: usize;
    let mut _4: usize;
    let _5: ();
    let mut _6: usize;
    scope 1 {
        debug index => _3;
    }

    bb0: {
        _4 = <Self as Children<'_>>::count_children(_1) -> bb1;
    }

    bb1: {
        _3 = <C as Context>::next_index(_2, move _4) -> bb2;
    }

    bb2: {
        _6 = _3;
        _5 = <Self as Children<'_>>::descend_one_child::<C>(_1, _2, move _6) -> bb3;
    }

    bb3: {
        return;
    }
}

fn Children::descend_into_self(_1: &Self, _2: &mut C) -> () {
    debug self => _1;
    debug context => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: bool;
    let mut _5: &C;
    let _6: ();
    let _7: ();
    let _8: ();
    let _9: ();
    let _10: ();
    let _11: ();
    let _12: ();

    bb0: {
        _3 = <C as PrePost<Self>>::pre(_2, _1) -> bb1;
    }

    bb1: {
        _5 = &(*_2);
        _4 = <C as Context>::should_act(move _5) -> bb2;
    }

    bb2: {
        switchInt(move _4) -> [0: bb7, otherwise: bb3];
    }

    bb3: {
        _6 = <C as Context>::increase_visited(_2) -> bb4;
    }

    bb4: {
        _7 = <C as Context>::increase_depth(_2) -> bb5;
    }

    bb5: {
        _8 = <Self as Children<'_>>::next_child::<C>(_1, _2) -> bb6;
    }

    bb6: {
        _9 = <C as Context>::decrease_depth(_2) -> bb9;
    }

    bb7: {
        _10 = <C as PrePost<Self>>::hit_limit(_2, _1) -> bb8;
    }

    bb8: {
        _11 = <C as Context>::increase_skipped(_2) -> bb9;
    }

    bb9: {
        _12 = <C as PrePost<Self>>::post(_2, _1) -> bb10;
    }

    bb10: {
        return;
    }
}

fn Children::descend(_1: &Self, _2: &Cell<Option<&Self>>, _3: &mut C) -> () {
    debug self => _1;
    debug c => _2;
    debug context => _3;
    let mut _0: ();
    let mut _4: std::option::Option<&Self>;
    let mut _5: isize;
    let _7: ();
    scope 1 {
        debug r => _6;
        let _6: &Self;
    }

    bb0: {
        _4 = Cell::<Option<&Self>>::get(_2) -> bb1;
    }

    bb1: {
        _5 = discriminant(_4);
        switchInt(move _5) -> [1: bb2, otherwise: bb3];
    }

    bb2: {
        _6 = ((_4 as Some).0: &Self);
        _7 = <Self as Children<'_>>::descend_into_self::<C>(_6, _3) -> bb3;
    }

    bb3: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:968:1: 968:32>::count_children(_1: &S<'_>) -> usize {
    debug self => _1;
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:968:1: 968:32>::descend_one_child(_1: &S<'_>, _2: &mut C, _3: usize) -> () {
    debug self => _1;
    debug context => _2;
    let mut _0: ();
    let _4: ();
    let _5: &std::cell::Cell<std::option::Option<&S<'_>>>;

    bb0: {
        _5 = &((*_1).2: std::cell::Cell<std::option::Option<&S<'_>>>);
        _4 = <S<'_> as Children<'_>>::descend::<C>(_1, _5, _2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:976:1: 976:33>::count_children(_1: &S2<'_>) -> usize {
    debug self => _1;
    let mut _0: usize;

    bb0: {
        _0 = const 2_usize;
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:976:1: 976:33>::descend_one_child(_1: &S2<'_>, _2: &mut C, _3: usize) -> () {
    debug self => _1;
    debug context => _2;
    debug index => _3;
    let mut _0: ();
    let _4: (std::option::Option<&S2<'_>>, std::option::Option<&S2<'_>>);
    let mut _5: &std::cell::Cell<(std::option::Option<&S2<'_>>, std::option::Option<&S2<'_>>)>;
    let mut _7: isize;
    let mut _9: isize;
    let _11: !;
    let _12: ();
    let mut _13: &S2<'_>;
    scope 1 {
        debug children => _4;
        let _6: &S2<'_>;
        scope 2 {
            debug child => _6;
        }
        scope 3 {
            debug child => _8;
            let _8: &S2<'_>;
        }
        scope 4 {
            debug child => _10;
            let _10: &S2<'_>;
        }
    }

    bb0: {
        _5 = &((*_1).2: std::cell::Cell<(std::option::Option<&S2<'_>>, std::option::Option<&S2<'_>>)>);
        _4 = Cell::<(Option<&S2<'_>>, Option<&S2<'_>>)>::get(move _5) -> bb1;
    }

    bb1: {
        switchInt(_3) -> [0: bb3, 1: bb5, otherwise: bb2];
    }

    bb2: {
        _11 = begin_panic::<&str>(const "bad children");
    }

    bb3: {
        _7 = discriminant((_4.0: std::option::Option<&S2<'_>>));
        switchInt(move _7) -> [1: bb4, otherwise: bb8];
    }

    bb4: {
        _8 = (((_4.0: std::option::Option<&S2<'_>>) as Some).0: &S2<'_>);
        _6 = _8;
        goto -> bb7;
    }

    bb5: {
        _9 = discriminant((_4.1: std::option::Option<&S2<'_>>));
        switchInt(move _9) -> [1: bb6, otherwise: bb8];
    }

    bb6: {
        _10 = (((_4.1: std::option::Option<&S2<'_>>) as Some).0: &S2<'_>);
        _6 = _10;
        goto -> bb7;
    }

    bb7: {
        _13 = _6;
        _12 = <S2<'_> as Children<'_>>::descend_into_self::<C>(move _13, _2) -> bb8;
    }

    bb8: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:992:1: 992:32>::count_children(_1: &V<'_>) -> usize {
    debug self => _1;
    let mut _0: usize;
    let mut _2: &std::vec::Vec<std::cell::Cell<std::option::Option<&V<'_>>>>;

    bb0: {
        _2 = &((*_1).2: std::vec::Vec<std::cell::Cell<std::option::Option<&V<'_>>>>);
        _0 = Vec::<Cell<Option<&V<'_>>>>::len(move _2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:992:1: 992:32>::descend_one_child(_1: &V<'_>, _2: &mut C, _3: usize) -> () {
    debug self => _1;
    debug context => _2;
    debug index => _3;
    let mut _0: ();
    let mut _4: std::option::Option<&V<'_>>;
    let mut _5: &std::cell::Cell<std::option::Option<&V<'_>>>;
    let _6: &std::cell::Cell<std::option::Option<&V<'_>>>;
    let mut _7: &std::vec::Vec<std::cell::Cell<std::option::Option<&V<'_>>>>;
    let mut _8: isize;
    let _10: ();
    scope 1 {
        debug child => _9;
        let _9: &V<'_>;
    }

    bb0: {
        _7 = &((*_1).2: std::vec::Vec<std::cell::Cell<std::option::Option<&V<'_>>>>);
        _6 = <Vec<Cell<Option<&V<'_>>>> as Index<usize>>::index(move _7, _3) -> bb1;
    }

    bb1: {
        _5 = _6;
        _4 = Cell::<Option<&V<'_>>>::get(move _5) -> bb2;
    }

    bb2: {
        _8 = discriminant(_4);
        switchInt(move _8) -> [1: bb3, otherwise: bb4];
    }

    bb3: {
        _9 = ((_4 as Some).0: &V<'_>);
        _10 = <V<'_> as Children<'_>>::descend_into_self::<C>(_9, _2) -> bb4;
    }

    bb4: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1003:1: 1003:32>::count_children(_1: &H<'_>) -> usize {
    debug self => _1;
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1003:1: 1003:32>::descend_one_child(_1: &H<'_>, _2: &mut C, _3: usize) -> () {
    debug self => _1;
    debug context => _2;
    let mut _0: ();
    let _4: ();
    let _5: &std::cell::Cell<std::option::Option<&H<'_>>>;

    bb0: {
        _5 = &((*_1).2: std::cell::Cell<std::option::Option<&H<'_>>>);
        _4 = <H<'_> as Children<'_>>::descend::<C>(_1, _5, _2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1012:1: 1012:33>::count_children(_1: &HM<'_>) -> usize {
    debug self => _1;
    let mut _0: usize;
    let mut _2: std::option::Option<&std::collections::HashMap<HM<'_>, HM<'_>>>;
    let mut _3: &std::cell::Cell<std::option::Option<&std::collections::HashMap<HM<'_>, HM<'_>>>>;
    let mut _4: isize;
    let mut _6: usize;
    let mut _7: std::collections::hash_map::Iter<'_, HM<'_>, HM<'_>>;
    scope 1 {
        debug m => _5;
        let _5: &std::collections::HashMap<HM<'_>, HM<'_>>;
    }

    bb0: {
        _3 = &((*_1).2: std::cell::Cell<std::option::Option<&std::collections::HashMap<HM<'_>, HM<'_>>>>);
        _2 = Cell::<Option<&HashMap<HM<'_>, HM<'_>>>>::get(move _3) -> bb1;
    }

    bb1: {
        _4 = discriminant(_2);
        switchInt(move _4) -> [1: bb2, otherwise: bb5];
    }

    bb2: {
        _5 = ((_2 as Some).0: &std::collections::HashMap<HM<'_>, HM<'_>>);
        _7 = HashMap::<HM<'_>, HM<'_>>::iter(_5) -> bb3;
    }

    bb3: {
        _6 = <std::collections::hash_map::Iter<'_, HM<'_>, HM<'_>> as Iterator>::count(move _7) -> bb4;
    }

    bb4: {
        _0 = Mul(const 2_usize, move _6);
        goto -> bb6;
    }

    bb5: {
        _0 = const 0_usize;
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1012:1: 1012:33>::descend_one_child(_1: &HM<'_>, _2: &mut C, _3: usize) -> () {
    debug self => _1;
    debug context => _2;
    debug index => _3;
    let mut _0: ();
    let mut _4: std::option::Option<&std::collections::HashMap<HM<'_>, HM<'_>>>;
    let mut _5: &std::cell::Cell<std::option::Option<&std::collections::HashMap<HM<'_>, HM<'_>>>>;
    let mut _6: isize;
    let mut _8: std::option::Option<(&HM<'_>, &HM<'_>)>;
    let mut _9: &mut std::collections::hash_map::Iter<'_, HM<'_>, HM<'_>>;
    let mut _10: std::collections::hash_map::Iter<'_, HM<'_>, HM<'_>>;
    let mut _11: usize;
    let mut _12: bool;
    let mut _13: isize;
    let _16: ();
    let _17: [&HM<'_>; 2];
    let _18: usize;
    let mut _19: bool;
    let mut _20: usize;
    let mut _21: bool;
    let mut _22: &std::collections::HashMap<HM<'_>, HM<'_>>;
    let mut _23: &HM<'_>;
    scope 1 {
        debug hm => _7;
        let _7: &&std::collections::HashMap<HM<'_>, HM<'_>>;
        scope 2 {
            debug k => _14;
            debug v => _15;
            let _14: &HM<'_>;
            let _15: &HM<'_>;
        }
    }

    bb0: {
        _5 = &((*_1).2: std::cell::Cell<std::option::Option<&std::collections::HashMap<HM<'_>, HM<'_>>>>);
        _4 = Cell::<Option<&HashMap<HM<'_>, HM<'_>>>>::get(move _5) -> bb1;
    }

    bb1: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [1: bb2, otherwise: bb9];
    }

    bb2: {
        _7 = &((_4 as Some).0: &std::collections::HashMap<HM<'_>, HM<'_>>);
        _22 = deref_copy (*_7);
        _10 = HashMap::<HM<'_>, HM<'_>>::iter(_22) -> bb3;
    }

    bb3: {
        _9 = &mut _10;
        _12 = Eq(const 2_usize, const 0_usize);
        assert(!move _12, "attempt to divide `{}` by zero", _3) -> bb4;
    }

    bb4: {
        _11 = Div(_3, const 2_usize);
        _8 = <std::collections::hash_map::Iter<'_, HM<'_>, HM<'_>> as Iterator>::nth(move _9, move _11) -> bb5;
    }

    bb5: {
        _13 = discriminant(_8);
        switchInt(move _13) -> [1: bb6, otherwise: bb9];
    }

    bb6: {
        _14 = (((_8 as Some).0: (&HM<'_>, &HM<'_>)).0: &HM<'_>);
        _15 = (((_8 as Some).0: (&HM<'_>, &HM<'_>)).1: &HM<'_>);
        _17 = [_14, _15];
        _19 = Eq(const 2_usize, const 0_usize);
        assert(!move _19, "attempt to calculate the remainder of `{}` with a divisor of zero", _3) -> bb7;
    }

    bb7: {
        _18 = Rem(_3, const 2_usize);
        _20 = const 2_usize;
        _21 = Lt(_18, _20);
        assert(move _21, "index out of bounds: the length is {} but the index is {}", move _20, _18) -> bb8;
    }

    bb8: {
        _23 = deref_copy _17[_18];
        _16 = <HM<'_> as Children<'_>>::descend_into_self::<C>(_23, _2) -> bb9;
    }

    bb9: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1027:1: 1027:33>::count_children(_1: &VD<'_>) -> usize {
    debug self => _1;
    let mut _0: usize;
    let mut _2: std::option::Option<&std::collections::VecDeque<VD<'_>>>;
    let mut _3: &std::cell::Cell<std::option::Option<&std::collections::VecDeque<VD<'_>>>>;
    let mut _4: isize;
    let mut _6: std::collections::vec_deque::Iter<'_, VD<'_>>;
    scope 1 {
        debug d => _5;
        let _5: &std::collections::VecDeque<VD<'_>>;
    }

    bb0: {
        _3 = &((*_1).2: std::cell::Cell<std::option::Option<&std::collections::VecDeque<VD<'_>>>>);
        _2 = Cell::<Option<&VecDeque<VD<'_>>>>::get(move _3) -> bb1;
    }

    bb1: {
        _4 = discriminant(_2);
        switchInt(move _4) -> [1: bb2, otherwise: bb4];
    }

    bb2: {
        _5 = ((_2 as Some).0: &std::collections::VecDeque<VD<'_>>);
        _6 = VecDeque::<VD<'_>>::iter(_5) -> bb3;
    }

    bb3: {
        _0 = <std::collections::vec_deque::Iter<'_, VD<'_>> as Iterator>::count(move _6) -> bb5;
    }

    bb4: {
        _0 = const 0_usize;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1027:1: 1027:33>::descend_one_child(_1: &VD<'_>, _2: &mut C, _3: usize) -> () {
    debug self => _1;
    debug context => _2;
    debug index => _3;
    let mut _0: ();
    let mut _4: std::option::Option<&std::collections::VecDeque<VD<'_>>>;
    let mut _5: &std::cell::Cell<std::option::Option<&std::collections::VecDeque<VD<'_>>>>;
    let mut _6: isize;
    let mut _8: std::option::Option<&VD<'_>>;
    let mut _9: &mut std::collections::vec_deque::Iter<'_, VD<'_>>;
    let mut _10: std::collections::vec_deque::Iter<'_, VD<'_>>;
    let mut _11: isize;
    let _13: ();
    let mut _14: &std::collections::VecDeque<VD<'_>>;
    scope 1 {
        debug vd => _7;
        let _7: &&std::collections::VecDeque<VD<'_>>;
        scope 2 {
            debug r => _12;
            let _12: &VD<'_>;
        }
    }

    bb0: {
        _5 = &((*_1).2: std::cell::Cell<std::option::Option<&std::collections::VecDeque<VD<'_>>>>);
        _4 = Cell::<Option<&VecDeque<VD<'_>>>>::get(move _5) -> bb1;
    }

    bb1: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [1: bb2, otherwise: bb6];
    }

    bb2: {
        _7 = &((_4 as Some).0: &std::collections::VecDeque<VD<'_>>);
        _14 = deref_copy (*_7);
        _10 = VecDeque::<VD<'_>>::iter(_14) -> bb3;
    }

    bb3: {
        _9 = &mut _10;
        _8 = <std::collections::vec_deque::Iter<'_, VD<'_>> as Iterator>::nth(move _9, _3) -> bb4;
    }

    bb4: {
        _11 = discriminant(_8);
        switchInt(move _11) -> [1: bb5, otherwise: bb6];
    }

    bb5: {
        _12 = ((_8 as Some).0: &VD<'_>);
        _13 = <VD<'_> as Children<'_>>::descend_into_self::<C>(_12, _2) -> bb6;
    }

    bb6: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1042:1: 1042:33>::count_children(_1: &VM<'_>) -> usize {
    debug self => _1;
    let mut _0: usize;
    let mut _2: std::option::Option<&std::collections::HashMap<usize, VM<'_>>>;
    let mut _3: &std::cell::Cell<std::option::Option<&std::collections::HashMap<usize, VM<'_>>>>;
    let mut _4: isize;
    let mut _6: std::collections::hash_map::Iter<'_, usize, VM<'_>>;
    scope 1 {
        debug m => _5;
        let _5: &std::collections::HashMap<usize, VM<'_>>;
    }

    bb0: {
        _3 = &((*_1).2: std::cell::Cell<std::option::Option<&std::collections::HashMap<usize, VM<'_>>>>);
        _2 = Cell::<Option<&HashMap<usize, VM<'_>>>>::get(move _3) -> bb1;
    }

    bb1: {
        _4 = discriminant(_2);
        switchInt(move _4) -> [1: bb2, otherwise: bb4];
    }

    bb2: {
        _5 = ((_2 as Some).0: &std::collections::HashMap<usize, VM<'_>>);
        _6 = HashMap::<usize, VM<'_>>::iter(_5) -> bb3;
    }

    bb3: {
        _0 = <std::collections::hash_map::Iter<'_, usize, VM<'_>> as Iterator>::count(move _6) -> bb5;
    }

    bb4: {
        _0 = const 0_usize;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1042:1: 1042:33>::descend_one_child(_1: &VM<'_>, _2: &mut C, _3: usize) -> () {
    debug self => _1;
    debug context => _2;
    debug index => _3;
    let mut _0: ();
    let mut _4: std::option::Option<&std::collections::HashMap<usize, VM<'_>>>;
    let mut _5: &std::cell::Cell<std::option::Option<&std::collections::HashMap<usize, VM<'_>>>>;
    let mut _6: isize;
    let mut _8: std::option::Option<(&usize, &VM<'_>)>;
    let mut _9: &mut std::collections::hash_map::Iter<'_, usize, VM<'_>>;
    let mut _10: std::collections::hash_map::Iter<'_, usize, VM<'_>>;
    let mut _11: isize;
    let _14: ();
    let mut _15: &std::collections::HashMap<usize, VM<'_>>;
    scope 1 {
        debug vd => _7;
        let _7: &&std::collections::HashMap<usize, VM<'_>>;
        scope 2 {
            debug _idx => _12;
            debug r => _13;
            let _12: &usize;
            let _13: &VM<'_>;
        }
    }

    bb0: {
        _5 = &((*_1).2: std::cell::Cell<std::option::Option<&std::collections::HashMap<usize, VM<'_>>>>);
        _4 = Cell::<Option<&HashMap<usize, VM<'_>>>>::get(move _5) -> bb1;
    }

    bb1: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [1: bb2, otherwise: bb6];
    }

    bb2: {
        _7 = &((_4 as Some).0: &std::collections::HashMap<usize, VM<'_>>);
        _15 = deref_copy (*_7);
        _10 = HashMap::<usize, VM<'_>>::iter(_15) -> bb3;
    }

    bb3: {
        _9 = &mut _10;
        _8 = <std::collections::hash_map::Iter<'_, usize, VM<'_>> as Iterator>::nth(move _9, _3) -> bb4;
    }

    bb4: {
        _11 = discriminant(_8);
        switchInt(move _11) -> [1: bb5, otherwise: bb6];
    }

    bb5: {
        _12 = (((_8 as Some).0: (&usize, &VM<'_>)).0: &usize);
        _13 = (((_8 as Some).0: (&usize, &VM<'_>)).1: &VM<'_>);
        _14 = <VM<'_> as Children<'_>>::descend_into_self::<C>(_13, _2) -> bb6;
    }

    bb6: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1057:1: 1057:33>::count_children(_1: &LL<'_>) -> usize {
    debug self => _1;
    let mut _0: usize;
    let mut _2: std::option::Option<&std::collections::LinkedList<LL<'_>>>;
    let mut _3: &std::cell::Cell<std::option::Option<&std::collections::LinkedList<LL<'_>>>>;
    let mut _4: isize;
    let mut _6: std::collections::linked_list::Iter<'_, LL<'_>>;
    scope 1 {
        debug l => _5;
        let _5: &std::collections::LinkedList<LL<'_>>;
    }

    bb0: {
        _3 = &((*_1).2: std::cell::Cell<std::option::Option<&std::collections::LinkedList<LL<'_>>>>);
        _2 = Cell::<Option<&LinkedList<LL<'_>>>>::get(move _3) -> bb1;
    }

    bb1: {
        _4 = discriminant(_2);
        switchInt(move _4) -> [1: bb2, otherwise: bb4];
    }

    bb2: {
        _5 = ((_2 as Some).0: &std::collections::LinkedList<LL<'_>>);
        _6 = LinkedList::<LL<'_>>::iter(_5) -> bb3;
    }

    bb3: {
        _0 = <std::collections::linked_list::Iter<'_, LL<'_>> as Iterator>::count(move _6) -> bb5;
    }

    bb4: {
        _0 = const 0_usize;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1057:1: 1057:33>::descend_one_child(_1: &LL<'_>, _2: &mut C, _3: usize) -> () {
    debug self => _1;
    debug context => _2;
    debug index => _3;
    let mut _0: ();
    let mut _4: std::option::Option<&std::collections::LinkedList<LL<'_>>>;
    let mut _5: &std::cell::Cell<std::option::Option<&std::collections::LinkedList<LL<'_>>>>;
    let mut _6: isize;
    let mut _8: std::option::Option<&LL<'_>>;
    let mut _9: &mut std::collections::linked_list::Iter<'_, LL<'_>>;
    let mut _10: std::collections::linked_list::Iter<'_, LL<'_>>;
    let mut _11: isize;
    let _13: ();
    let mut _14: &std::collections::LinkedList<LL<'_>>;
    scope 1 {
        debug ll => _7;
        let _7: &&std::collections::LinkedList<LL<'_>>;
        scope 2 {
            debug r => _12;
            let _12: &LL<'_>;
        }
    }

    bb0: {
        _5 = &((*_1).2: std::cell::Cell<std::option::Option<&std::collections::LinkedList<LL<'_>>>>);
        _4 = Cell::<Option<&LinkedList<LL<'_>>>>::get(move _5) -> bb1;
    }

    bb1: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [1: bb2, otherwise: bb6];
    }

    bb2: {
        _7 = &((_4 as Some).0: &std::collections::LinkedList<LL<'_>>);
        _14 = deref_copy (*_7);
        _10 = LinkedList::<LL<'_>>::iter(_14) -> bb3;
    }

    bb3: {
        _9 = &mut _10;
        _8 = <std::collections::linked_list::Iter<'_, LL<'_>> as Iterator>::nth(move _9, _3) -> bb4;
    }

    bb4: {
        _11 = discriminant(_8);
        switchInt(move _11) -> [1: bb5, otherwise: bb6];
    }

    bb5: {
        _12 = ((_8 as Some).0: &LL<'_>);
        _13 = <LL<'_> as Children<'_>>::descend_into_self::<C>(_12, _2) -> bb6;
    }

    bb6: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1072:1: 1072:33>::count_children(_1: &BH<'_>) -> usize {
    debug self => _1;
    let mut _0: usize;
    let mut _2: std::option::Option<&std::collections::BinaryHeap<BH<'_>>>;
    let mut _3: &std::cell::Cell<std::option::Option<&std::collections::BinaryHeap<BH<'_>>>>;
    let mut _4: isize;
    let mut _6: std::collections::binary_heap::Iter<'_, BH<'_>>;
    scope 1 {
        debug h => _5;
        let _5: &std::collections::BinaryHeap<BH<'_>>;
    }

    bb0: {
        _3 = &((*_1).2: std::cell::Cell<std::option::Option<&std::collections::BinaryHeap<BH<'_>>>>);
        _2 = Cell::<Option<&BinaryHeap<BH<'_>>>>::get(move _3) -> bb1;
    }

    bb1: {
        _4 = discriminant(_2);
        switchInt(move _4) -> [1: bb2, otherwise: bb4];
    }

    bb2: {
        _5 = ((_2 as Some).0: &std::collections::BinaryHeap<BH<'_>>);
        _6 = BinaryHeap::<BH<'_>>::iter(_5) -> bb3;
    }

    bb3: {
        _0 = <std::collections::binary_heap::Iter<'_, BH<'_>> as Iterator>::count(move _6) -> bb5;
    }

    bb4: {
        _0 = const 0_usize;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1072:1: 1072:33>::descend_one_child(_1: &BH<'_>, _2: &mut C, _3: usize) -> () {
    debug self => _1;
    debug context => _2;
    debug index => _3;
    let mut _0: ();
    let mut _4: std::option::Option<&std::collections::BinaryHeap<BH<'_>>>;
    let mut _5: &std::cell::Cell<std::option::Option<&std::collections::BinaryHeap<BH<'_>>>>;
    let mut _6: isize;
    let mut _8: std::option::Option<&BH<'_>>;
    let mut _9: &mut std::collections::binary_heap::Iter<'_, BH<'_>>;
    let mut _10: std::collections::binary_heap::Iter<'_, BH<'_>>;
    let mut _11: isize;
    let _13: ();
    let mut _14: &std::collections::BinaryHeap<BH<'_>>;
    scope 1 {
        debug bh => _7;
        let _7: &&std::collections::BinaryHeap<BH<'_>>;
        scope 2 {
            debug r => _12;
            let _12: &BH<'_>;
        }
    }

    bb0: {
        _5 = &((*_1).2: std::cell::Cell<std::option::Option<&std::collections::BinaryHeap<BH<'_>>>>);
        _4 = Cell::<Option<&BinaryHeap<BH<'_>>>>::get(move _5) -> bb1;
    }

    bb1: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [1: bb2, otherwise: bb6];
    }

    bb2: {
        _7 = &((_4 as Some).0: &std::collections::BinaryHeap<BH<'_>>);
        _14 = deref_copy (*_7);
        _10 = BinaryHeap::<BH<'_>>::iter(_14) -> bb3;
    }

    bb3: {
        _9 = &mut _10;
        _8 = <std::collections::binary_heap::Iter<'_, BH<'_>> as Iterator>::nth(move _9, _3) -> bb4;
    }

    bb4: {
        _11 = discriminant(_8);
        switchInt(move _11) -> [1: bb5, otherwise: bb6];
    }

    bb5: {
        _12 = ((_8 as Some).0: &BH<'_>);
        _13 = <BH<'_> as Children<'_>>::descend_into_self::<C>(_12, _2) -> bb6;
    }

    bb6: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1087:1: 1087:34>::count_children(_1: &BTM<'_>) -> usize {
    debug self => _1;
    let mut _0: usize;
    let mut _2: std::option::Option<&std::collections::BTreeMap<BTM<'_>, BTM<'_>>>;
    let mut _3: &std::cell::Cell<std::option::Option<&std::collections::BTreeMap<BTM<'_>, BTM<'_>>>>;
    let mut _4: isize;
    let mut _6: usize;
    let mut _7: std::collections::btree_map::Iter<'_, BTM<'_>, BTM<'_>>;
    scope 1 {
        debug m => _5;
        let _5: &std::collections::BTreeMap<BTM<'_>, BTM<'_>>;
    }

    bb0: {
        _3 = &((*_1).2: std::cell::Cell<std::option::Option<&std::collections::BTreeMap<BTM<'_>, BTM<'_>>>>);
        _2 = Cell::<Option<&BTreeMap<BTM<'_>, BTM<'_>>>>::get(move _3) -> bb1;
    }

    bb1: {
        _4 = discriminant(_2);
        switchInt(move _4) -> [1: bb2, otherwise: bb5];
    }

    bb2: {
        _5 = ((_2 as Some).0: &std::collections::BTreeMap<BTM<'_>, BTM<'_>>);
        _7 = BTreeMap::<BTM<'_>, BTM<'_>>::iter(_5) -> bb3;
    }

    bb3: {
        _6 = <std::collections::btree_map::Iter<'_, BTM<'_>, BTM<'_>> as Iterator>::count(move _7) -> bb4;
    }

    bb4: {
        _0 = Mul(const 2_usize, move _6);
        goto -> bb6;
    }

    bb5: {
        _0 = const 0_usize;
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1087:1: 1087:34>::descend_one_child(_1: &BTM<'_>, _2: &mut C, _3: usize) -> () {
    debug self => _1;
    debug context => _2;
    debug index => _3;
    let mut _0: ();
    let mut _4: std::option::Option<&std::collections::BTreeMap<BTM<'_>, BTM<'_>>>;
    let mut _5: &std::cell::Cell<std::option::Option<&std::collections::BTreeMap<BTM<'_>, BTM<'_>>>>;
    let mut _6: isize;
    let mut _8: std::option::Option<(&BTM<'_>, &BTM<'_>)>;
    let mut _9: &mut std::collections::btree_map::Iter<'_, BTM<'_>, BTM<'_>>;
    let mut _10: std::collections::btree_map::Iter<'_, BTM<'_>, BTM<'_>>;
    let mut _11: usize;
    let mut _12: bool;
    let mut _13: isize;
    let _16: ();
    let _17: [&BTM<'_>; 2];
    let _18: usize;
    let mut _19: bool;
    let mut _20: usize;
    let mut _21: bool;
    let mut _22: &std::collections::BTreeMap<BTM<'_>, BTM<'_>>;
    let mut _23: &BTM<'_>;
    scope 1 {
        debug bh => _7;
        let _7: &&std::collections::BTreeMap<BTM<'_>, BTM<'_>>;
        scope 2 {
            debug k => _14;
            debug v => _15;
            let _14: &BTM<'_>;
            let _15: &BTM<'_>;
        }
    }

    bb0: {
        _5 = &((*_1).2: std::cell::Cell<std::option::Option<&std::collections::BTreeMap<BTM<'_>, BTM<'_>>>>);
        _4 = Cell::<Option<&BTreeMap<BTM<'_>, BTM<'_>>>>::get(move _5) -> bb1;
    }

    bb1: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [1: bb2, otherwise: bb9];
    }

    bb2: {
        _7 = &((_4 as Some).0: &std::collections::BTreeMap<BTM<'_>, BTM<'_>>);
        _22 = deref_copy (*_7);
        _10 = BTreeMap::<BTM<'_>, BTM<'_>>::iter(_22) -> bb3;
    }

    bb3: {
        _9 = &mut _10;
        _12 = Eq(const 2_usize, const 0_usize);
        assert(!move _12, "attempt to divide `{}` by zero", _3) -> bb4;
    }

    bb4: {
        _11 = Div(_3, const 2_usize);
        _8 = <std::collections::btree_map::Iter<'_, BTM<'_>, BTM<'_>> as Iterator>::nth(move _9, move _11) -> bb5;
    }

    bb5: {
        _13 = discriminant(_8);
        switchInt(move _13) -> [1: bb6, otherwise: bb9];
    }

    bb6: {
        _14 = (((_8 as Some).0: (&BTM<'_>, &BTM<'_>)).0: &BTM<'_>);
        _15 = (((_8 as Some).0: (&BTM<'_>, &BTM<'_>)).1: &BTM<'_>);
        _17 = [_14, _15];
        _19 = Eq(const 2_usize, const 0_usize);
        assert(!move _19, "attempt to calculate the remainder of `{}` with a divisor of zero", _3) -> bb7;
    }

    bb7: {
        _18 = Rem(_3, const 2_usize);
        _20 = const 2_usize;
        _21 = Lt(_18, _20);
        assert(move _21, "index out of bounds: the length is {} but the index is {}", move _20, _18) -> bb8;
    }

    bb8: {
        _23 = deref_copy _17[_18];
        _16 = <BTM<'_> as Children<'_>>::descend_into_self::<C>(_23, _2) -> bb9;
    }

    bb9: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1102:1: 1102:34>::count_children(_1: &BTS<'_>) -> usize {
    debug self => _1;
    let mut _0: usize;
    let mut _2: std::option::Option<&std::collections::BTreeSet<BTS<'_>>>;
    let mut _3: &std::cell::Cell<std::option::Option<&std::collections::BTreeSet<BTS<'_>>>>;
    let mut _4: isize;
    let mut _6: std::collections::btree_set::Iter<'_, BTS<'_>>;
    scope 1 {
        debug s => _5;
        let _5: &std::collections::BTreeSet<BTS<'_>>;
    }

    bb0: {
        _3 = &((*_1).2: std::cell::Cell<std::option::Option<&std::collections::BTreeSet<BTS<'_>>>>);
        _2 = Cell::<Option<&BTreeSet<BTS<'_>>>>::get(move _3) -> bb1;
    }

    bb1: {
        _4 = discriminant(_2);
        switchInt(move _4) -> [1: bb2, otherwise: bb4];
    }

    bb2: {
        _5 = ((_2 as Some).0: &std::collections::BTreeSet<BTS<'_>>);
        _6 = BTreeSet::<BTS<'_>>::iter(_5) -> bb3;
    }

    bb3: {
        _0 = <std::collections::btree_set::Iter<'_, BTS<'_>> as Iterator>::count(move _6) -> bb5;
    }

    bb4: {
        _0 = const 0_usize;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1102:1: 1102:34>::descend_one_child(_1: &BTS<'_>, _2: &mut C, _3: usize) -> () {
    debug self => _1;
    debug context => _2;
    debug index => _3;
    let mut _0: ();
    let mut _4: std::option::Option<&std::collections::BTreeSet<BTS<'_>>>;
    let mut _5: &std::cell::Cell<std::option::Option<&std::collections::BTreeSet<BTS<'_>>>>;
    let mut _6: isize;
    let mut _8: std::option::Option<&BTS<'_>>;
    let mut _9: &mut std::collections::btree_set::Iter<'_, BTS<'_>>;
    let mut _10: std::collections::btree_set::Iter<'_, BTS<'_>>;
    let mut _11: isize;
    let _13: ();
    let mut _14: &std::collections::BTreeSet<BTS<'_>>;
    scope 1 {
        debug bh => _7;
        let _7: &&std::collections::BTreeSet<BTS<'_>>;
        scope 2 {
            debug r => _12;
            let _12: &BTS<'_>;
        }
    }

    bb0: {
        _5 = &((*_1).2: std::cell::Cell<std::option::Option<&std::collections::BTreeSet<BTS<'_>>>>);
        _4 = Cell::<Option<&BTreeSet<BTS<'_>>>>::get(move _5) -> bb1;
    }

    bb1: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [1: bb2, otherwise: bb6];
    }

    bb2: {
        _7 = &((_4 as Some).0: &std::collections::BTreeSet<BTS<'_>>);
        _14 = deref_copy (*_7);
        _10 = BTreeSet::<BTS<'_>>::iter(_14) -> bb3;
    }

    bb3: {
        _9 = &mut _10;
        _8 = <std::collections::btree_set::Iter<'_, BTS<'_>> as Iterator>::nth(move _9, _3) -> bb4;
    }

    bb4: {
        _11 = discriminant(_8);
        switchInt(move _11) -> [1: bb5, otherwise: bb6];
    }

    bb5: {
        _12 = ((_8 as Some).0: &BTS<'_>);
        _13 = <BTS<'_> as Children<'_>>::descend_into_self::<C>(_12, _2) -> bb6;
    }

    bb6: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1117:16: 1117:21>::clone(_1: &ContextData) -> ContextData {
    debug self => _1;
    let mut _0: ContextData;
    scope 1 {
        scope 2 {
            scope 3 {
                scope 4 {
                }
            }
        }
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1129:1: 1129:29>::next_index(_1: &mut ContextData, _2: usize) -> usize {
    debug self => _1;
    debug len => _2;
    let mut _0: usize;
    let mut _3: bool;
    let mut _4: usize;
    let mut _8: bool;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: usize;
    let mut _12: usize;
    let mut _13: u64;
    let mut _14: u64;
    let mut _15: u64;
    let mut _16: usize;
    let mut _17: usize;
    let mut _18: bool;
    let mut _19: u64;
    scope 1 {
        debug pow2 => _4;
        let _5: usize;
        scope 2 {
            debug _pow2_orig => _5;
            let mut _6: usize;
            scope 3 {
                debug idx => _6;
                let mut _7: u64;
                scope 4 {
                    debug bits => _7;
                }
            }
        }
    }

    bb0: {
        _3 = Lt(_2, const 2_usize);
        switchInt(move _3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _0 = const 0_usize;
        goto -> bb8;
    }

    bb2: {
        _4 = core::num::<impl usize>::next_power_of_two(_2) -> bb3;
    }

    bb3: {
        _5 = _4;
        _6 = const 0_usize;
        _7 = ((*_1).7: u64);
        goto -> bb4;
    }

    bb4: {
        _9 = _4;
        _8 = Gt(move _9, const 1_usize);
        switchInt(move _8) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _11 = _6;
        _10 = Shl(move _11, const 1_i32);
        _14 = _7;
        _13 = BitAnd(move _14, const 1_u64);
        _12 = move _13 as usize (IntToInt);
        _6 = BitOr(move _10, move _12);
        _15 = _7;
        _7 = Shr(move _15, const 1_i32);
        _16 = _4;
        _4 = Shr(move _16, const 1_i32);
        goto -> bb4;
    }

    bb6: {
        _17 = _6;
        _18 = Eq(_2, const 0_usize);
        assert(!move _18, "attempt to calculate the remainder of `{}` with a divisor of zero", _17) -> bb7;
    }

    bb7: {
        _6 = Rem(move _17, _2);
        _19 = _7;
        ((*_1).7: u64) = move _19;
        _0 = _6;
        goto -> bb8;
    }

    bb8: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1129:1: 1129:29>::should_act(_1: &ContextData) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: bool;
    let mut _3: usize;
    let mut _4: usize;
    let mut _5: bool;
    let mut _6: usize;
    let mut _7: usize;

    bb0: {
        _3 = ((*_1).0: usize);
        _4 = ((*_1).1: usize);
        _2 = Lt(move _3, move _4);
        switchInt(move _2) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = const false;
        goto -> bb3;
    }

    bb2: {
        _6 = ((*_1).2: usize);
        _7 = ((*_1).3: usize);
        _5 = Lt(move _6, move _7);
        _0 = move _5;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1129:1: 1129:29>::increase_visited(_1: &mut ContextData) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        ((*_1).2: usize) = Add(((*_1).2: usize), const 1_usize);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1129:1: 1129:29>::increase_skipped(_1: &mut ContextData) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        ((*_1).4: usize) = Add(((*_1).4: usize), const 1_usize);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1129:1: 1129:29>::increase_depth(_1: &mut ContextData) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        ((*_1).0: usize) = Add(((*_1).0: usize), const 1_usize);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1129:1: 1129:29>::decrease_depth(_1: &mut ContextData) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        ((*_1).0: usize) = Sub(((*_1).0: usize), const 1_usize);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1156:1: 1156:53>::pre(_1: &mut ContextData, _2: &T) -> () {
    debug self => _1;
    debug t => _2;
    let mut _0: ();
    let mut _3: std::ops::Range<usize>;
    let mut _4: std::ops::Range<usize>;
    let mut _5: usize;
    let mut _6: std::ops::Range<usize>;
    let mut _7: std::option::Option<usize>;
    let mut _8: &mut std::ops::Range<usize>;
    let mut _9: isize;
    let mut _10: bool;
    let _11: ();
    let mut _12: std::fmt::Arguments<'_>;
    let mut _13: &[&str];
    let _14: &[&str; 1];
    let _15: [&str; 1];
    let mut _16: bool;
    let _17: ();
    let mut _18: std::fmt::Arguments<'_>;
    let mut _19: &[&str];
    let _20: &[&str; 2];
    let _21: [&str; 2];
    let mut _22: &[core::fmt::rt::Argument<'_>];
    let _23: &[core::fmt::rt::Argument<'_>; 1];
    let _24: [core::fmt::rt::Argument<'_>; 1];
    let mut _25: core::fmt::rt::Argument<'_>;
    let _26: &&str;
    let _27: &str;
    let mut _28: bool;
    let mut _29: u32;
    let mut _30: u32;
    let mut _31: std::ops::Range<usize>;
    let mut _32: std::ops::Range<usize>;
    let mut _33: usize;
    let mut _34: std::ops::Range<usize>;
    let mut _35: std::option::Option<usize>;
    let mut _36: &mut std::ops::Range<usize>;
    let mut _37: isize;
    let mut _38: bool;
    let _39: ();
    let mut _40: std::fmt::Arguments<'_>;
    let mut _41: &[&str];
    let _42: &[&str; 1];
    let _43: [&str; 1];
    let mut _44: bool;
    let _45: ();
    let mut _46: std::fmt::Arguments<'_>;
    let mut _47: &[&str];
    let _48: &[&str; 1];
    let _49: [&str; 1];
    let _50: ();
    let mut _51: u32;
    scope 1 {
        debug iter => _6;
    }
    scope 2 {
        debug iter => _34;
    }

    bb0: {
        _5 = ((*_1).0: usize);
        _4 = std::ops::Range::<usize> { start: const 0_usize, end: move _5 };
        _3 = <std::ops::Range<usize> as IntoIterator>::into_iter(move _4) -> bb1;
    }

    bb1: {
        _6 = move _3;
        goto -> bb2;
    }

    bb2: {
        _8 = &mut _6;
        _7 = <std::ops::Range<usize> as Iterator>::next(_8) -> bb3;
    }

    bb3: {
        _9 = discriminant(_7);
        switchInt(move _9) -> [0: bb6, 1: bb4, otherwise: bb5];
    }

    bb4: {
        _10 = const _;
        switchInt(move _10) -> [0: bb2, otherwise: bb7];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _16 = const _;
        switchInt(move _16) -> [0: bb13, otherwise: bb9];
    }

    bb7: {
        _15 = [const " "];
        _14 = &_15;
        _13 = _14 as &[&str] (Pointer(Unsize));
        _12 = Arguments::<'_>::new_const(move _13) -> bb8;
    }

    bb8: {
        _11 = _print(move _12) -> bb2;
    }

    bb9: {
        _21 = [const "prev ", const "\n"];
        _20 = &_21;
        _19 = _20 as &[&str] (Pointer(Unsize));
        _27 = <T as Named>::name(_2) -> bb10;
    }

    bb10: {
        _26 = &_27;
        _25 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_26) -> bb11;
    }

    bb11: {
        _24 = [move _25];
        _23 = &_24;
        _22 = _23 as &[core::fmt::rt::Argument<'_>] (Pointer(Unsize));
        _18 = Arguments::<'_>::new_v1(move _19, move _22) -> bb12;
    }

    bb12: {
        _17 = _print(move _18) -> bb13;
    }

    bb13: {
        _29 = <T as Marked<u32>>::mark(_2) -> bb14;
    }

    bb14: {
        _30 = ((*_1).5: u32);
        _28 = Eq(move _29, move _30);
        switchInt(move _28) -> [0: bb26, otherwise: bb15];
    }

    bb15: {
        _33 = ((*_1).0: usize);
        _32 = std::ops::Range::<usize> { start: const 0_usize, end: move _33 };
        _31 = <std::ops::Range<usize> as IntoIterator>::into_iter(move _32) -> bb16;
    }

    bb16: {
        _34 = move _31;
        goto -> bb17;
    }

    bb17: {
        _36 = &mut _34;
        _35 = <std::ops::Range<usize> as Iterator>::next(_36) -> bb18;
    }

    bb18: {
        _37 = discriminant(_35);
        switchInt(move _37) -> [0: bb20, 1: bb19, otherwise: bb5];
    }

    bb19: {
        _38 = const _;
        switchInt(move _38) -> [0: bb17, otherwise: bb21];
    }

    bb20: {
        _44 = const _;
        switchInt(move _44) -> [0: bb25, otherwise: bb23];
    }

    bb21: {
        _43 = [const " "];
        _42 = &_43;
        _41 = _42 as &[&str] (Pointer(Unsize));
        _40 = Arguments::<'_>::new_const(move _41) -> bb22;
    }

    bb22: {
        _39 = _print(move _40) -> bb17;
    }

    bb23: {
        _49 = [const "(probably previously marked)\n"];
        _48 = &_49;
        _47 = _48 as &[&str] (Pointer(Unsize));
        _46 = Arguments::<'_>::new_const(move _47) -> bb24;
    }

    bb24: {
        _45 = _print(move _46) -> bb25;
    }

    bb25: {
        ((*_1).6: bool) = const true;
        goto -> bb26;
    }

    bb26: {
        _51 = ((*_1).5: u32);
        _50 = <T as Marked<u32>>::set_mark(_2, move _51) -> bb27;
    }

    bb27: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1156:1: 1156:53>::post(_1: &mut ContextData, _2: &T) -> () {
    debug self => _1;
    debug t => _2;
    let mut _0: ();
    let mut _3: std::ops::Range<usize>;
    let mut _4: std::ops::Range<usize>;
    let mut _5: usize;
    let mut _6: std::ops::Range<usize>;
    let mut _7: std::option::Option<usize>;
    let mut _8: &mut std::ops::Range<usize>;
    let mut _9: isize;
    let mut _10: bool;
    let _11: ();
    let mut _12: std::fmt::Arguments<'_>;
    let mut _13: &[&str];
    let _14: &[&str; 1];
    let _15: [&str; 1];
    let mut _16: bool;
    let _17: ();
    let mut _18: std::fmt::Arguments<'_>;
    let mut _19: &[&str];
    let _20: &[&str; 2];
    let _21: [&str; 2];
    let mut _22: &[core::fmt::rt::Argument<'_>];
    let _23: &[core::fmt::rt::Argument<'_>; 1];
    let _24: [core::fmt::rt::Argument<'_>; 1];
    let mut _25: core::fmt::rt::Argument<'_>;
    let _26: &&str;
    let _27: &str;
    scope 1 {
        debug iter => _6;
    }

    bb0: {
        _5 = ((*_1).0: usize);
        _4 = std::ops::Range::<usize> { start: const 0_usize, end: move _5 };
        _3 = <std::ops::Range<usize> as IntoIterator>::into_iter(move _4) -> bb1;
    }

    bb1: {
        _6 = move _3;
        goto -> bb2;
    }

    bb2: {
        _8 = &mut _6;
        _7 = <std::ops::Range<usize> as Iterator>::next(_8) -> bb3;
    }

    bb3: {
        _9 = discriminant(_7);
        switchInt(move _9) -> [0: bb6, 1: bb4, otherwise: bb5];
    }

    bb4: {
        _10 = const _;
        switchInt(move _10) -> [0: bb2, otherwise: bb7];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _16 = const _;
        switchInt(move _16) -> [0: bb13, otherwise: bb9];
    }

    bb7: {
        _15 = [const " "];
        _14 = &_15;
        _13 = _14 as &[&str] (Pointer(Unsize));
        _12 = Arguments::<'_>::new_const(move _13) -> bb8;
    }

    bb8: {
        _11 = _print(move _12) -> bb2;
    }

    bb9: {
        _21 = [const "post ", const "\n"];
        _20 = &_21;
        _19 = _20 as &[&str] (Pointer(Unsize));
        _27 = <T as Named>::name(_2) -> bb10;
    }

    bb10: {
        _26 = &_27;
        _25 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_26) -> bb11;
    }

    bb11: {
        _24 = [move _25];
        _23 = &_24;
        _22 = _23 as &[core::fmt::rt::Argument<'_>] (Pointer(Unsize));
        _18 = Arguments::<'_>::new_v1(move _19, move _22) -> bb12;
    }

    bb12: {
        _17 = _print(move _18) -> bb13;
    }

    bb13: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1156:1: 1156:53>::hit_limit(_1: &mut ContextData, _2: &T) -> () {
    debug self => _1;
    debug t => _2;
    let mut _0: ();
    let mut _3: std::ops::Range<usize>;
    let mut _4: std::ops::Range<usize>;
    let mut _5: usize;
    let mut _6: std::ops::Range<usize>;
    let mut _7: std::option::Option<usize>;
    let mut _8: &mut std::ops::Range<usize>;
    let mut _9: isize;
    let mut _10: bool;
    let _11: ();
    let mut _12: std::fmt::Arguments<'_>;
    let mut _13: &[&str];
    let _14: &[&str; 1];
    let _15: [&str; 1];
    let mut _16: bool;
    let _17: ();
    let mut _18: std::fmt::Arguments<'_>;
    let mut _19: &[&str];
    let _20: &[&str; 2];
    let _21: [&str; 2];
    let mut _22: &[core::fmt::rt::Argument<'_>];
    let _23: &[core::fmt::rt::Argument<'_>; 1];
    let _24: [core::fmt::rt::Argument<'_>; 1];
    let mut _25: core::fmt::rt::Argument<'_>;
    let _26: &&str;
    let _27: &str;
    scope 1 {
        debug iter => _6;
    }

    bb0: {
        _5 = ((*_1).0: usize);
        _4 = std::ops::Range::<usize> { start: const 0_usize, end: move _5 };
        _3 = <std::ops::Range<usize> as IntoIterator>::into_iter(move _4) -> bb1;
    }

    bb1: {
        _6 = move _3;
        goto -> bb2;
    }

    bb2: {
        _8 = &mut _6;
        _7 = <std::ops::Range<usize> as Iterator>::next(_8) -> bb3;
    }

    bb3: {
        _9 = discriminant(_7);
        switchInt(move _9) -> [0: bb6, 1: bb4, otherwise: bb5];
    }

    bb4: {
        _10 = const _;
        switchInt(move _10) -> [0: bb2, otherwise: bb7];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _16 = const _;
        switchInt(move _16) -> [0: bb13, otherwise: bb9];
    }

    bb7: {
        _15 = [const " "];
        _14 = &_15;
        _13 = _14 as &[&str] (Pointer(Unsize));
        _12 = Arguments::<'_>::new_const(move _13) -> bb8;
    }

    bb8: {
        _11 = _print(move _12) -> bb2;
    }

    bb9: {
        _21 = [const "LIMIT ", const "\n"];
        _20 = &_21;
        _19 = _20 as &[&str] (Pointer(Unsize));
        _27 = <T as Named>::name(_2) -> bb10;
    }

    bb10: {
        _26 = &_27;
        _25 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_26) -> bb11;
    }

    bb11: {
        _24 = [move _25];
        _23 = &_24;
        _22 = _23 as &[core::fmt::rt::Argument<'_>] (Pointer(Unsize));
        _18 = Arguments::<'_>::new_v1(move _19, move _22) -> bb12;
    }

    bb12: {
        _17 = _print(move _18) -> bb13;
    }

    bb13: {
        return;
    }
}

fn RCRC(_1: Rc<RefCell<RCRCData<'_>>>) -> RCRC<'_> {
    let mut _0: RCRC<'_>;

    bb0: {
        _0 = RCRC::<'_>(move _1);
        return;
    }
}

// MIR FOR CTFE
fn RCRC(_1: Rc<RefCell<RCRCData<'_>>>) -> RCRC<'_> {
    let mut _0: RCRC<'_>;

    bb0: {
        _0 = RCRC::<'_>(move _1);
        return;
    }
}

fn ARCRC(_1: Arc<RefCell<ARCRCData<'_>>>) -> ARCRC<'_> {
    let mut _0: ARCRC<'_>;

    bb0: {
        _0 = ARCRC::<'_>(move _1);
        return;
    }
}

// MIR FOR CTFE
fn ARCRC(_1: Arc<RefCell<ARCRCData<'_>>>) -> ARCRC<'_> {
    let mut _0: ARCRC<'_>;

    bb0: {
        _0 = ARCRC::<'_>(move _1);
        return;
    }
}

fn ARCM(_1: &str, _2: Arc<Mutex<ARCMData<'_>>>) -> ARCM<'_> {
    let mut _0: ARCM<'_>;

    bb0: {
        _0 = ARCM::<'_>(move _1, move _2);
        return;
    }
}

// MIR FOR CTFE
fn ARCM(_1: &str, _2: Arc<Mutex<ARCMData<'_>>>) -> ARCM<'_> {
    let mut _0: ARCM<'_>;

    bb0: {
        _0 = ARCM::<'_>(move _1, move _2);
        return;
    }
}

fn ARCRW(_1: Arc<RwLock<ARCRWData<'_>>>) -> ARCRW<'_> {
    let mut _0: ARCRW<'_>;

    bb0: {
        _0 = ARCRW::<'_>(move _1);
        return;
    }
}

// MIR FOR CTFE
fn ARCRW(_1: Arc<RwLock<ARCRWData<'_>>>) -> ARCRW<'_> {
    let mut _0: ARCRW<'_>;

    bb0: {
        _0 = ARCRW::<'_>(move _1);
        return;
    }
}
