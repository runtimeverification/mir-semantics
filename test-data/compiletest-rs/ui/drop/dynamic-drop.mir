// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn <impl at ui/drop/dynamic-drop.rs:26:1: 26:24>::drop(_1: &mut Allocator) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: std::cell::Ref<'_, std::vec::Vec<bool>>;
    let mut _3: &std::cell::RefCell<std::vec::Vec<bool>>;
    let mut _4: bool;
    let mut _5: &mut std::slice::Iter<'_, bool>;
    let mut _6: std::slice::Iter<'_, bool>;
    let mut _7: &[bool];
    let _8: &[bool];
    let mut _9: &std::vec::Vec<bool>;
    let _10: &std::vec::Vec<bool>;
    let mut _11: &std::cell::Ref<'_, std::vec::Vec<bool>>;
    let _12: !;
    let mut _13: std::fmt::Arguments<'_>;
    let mut _14: &[&str];
    let _15: &[&str; 1];
    let _16: [&str; 1];
    let mut _17: &[core::fmt::rt::Argument<'_>];
    let _18: &[core::fmt::rt::Argument<'_>; 1];
    let _19: [core::fmt::rt::Argument<'_>; 1];
    let mut _20: core::fmt::rt::Argument<'_>;
    let _21: &std::cell::Ref<'_, std::vec::Vec<bool>>;
    scope 1 {
        debug data => _2;
    }

    bb0: {
        _3 = &((*_1).0: std::cell::RefCell<std::vec::Vec<bool>>);
        _2 = RefCell::<Vec<bool>>::borrow(move _3) -> bb1;
    }

    bb1: {
        _11 = &_2;
        _10 = <Ref<'_, Vec<bool>> as Deref>::deref(move _11) -> [return: bb2, unwind: bb11];
    }

    bb2: {
        _9 = _10;
        _8 = <Vec<bool> as Deref>::deref(move _9) -> [return: bb3, unwind: bb11];
    }

    bb3: {
        _7 = _8;
        _6 = core::slice::<impl [bool]>::iter(move _7) -> [return: bb4, unwind: bb11];
    }

    bb4: {
        _5 = &mut _6;
        _4 = <std::slice::Iter<'_, bool> as Iterator>::any::<[closure@ui/drop/dynamic-drop.rs:29:28: 29:31]>(move _5, const ZeroSized: [closure@ui/drop/dynamic-drop.rs:29:28: 29:31]) -> [return: bb5, unwind: bb11];
    }

    bb5: {
        switchInt(move _4) -> [0: bb9, otherwise: bb6];
    }

    bb6: {
        _16 = [const "missing free: "];
        _15 = &_16;
        _14 = _15 as &[&str] (Pointer(Unsize));
        _21 = &_2;
        _20 = core::fmt::rt::Argument::<'_>::new_debug::<Ref<'_, Vec<bool>>>(_21) -> [return: bb7, unwind: bb11];
    }

    bb7: {
        _19 = [move _20];
        _18 = &_19;
        _17 = _18 as &[core::fmt::rt::Argument<'_>] (Pointer(Unsize));
        _13 = Arguments::<'_>::new_v1(move _14, move _17) -> [return: bb8, unwind: bb11];
    }

    bb8: {
        _12 = panic_fmt(move _13) -> bb11;
    }

    bb9: {
        drop(_2) -> bb10;
    }

    bb10: {
        return;
    }

    bb11 (cleanup): {
        drop(_2) -> [return: bb12, unwind terminate];
    }

    bb12 (cleanup): {
        resume;
    }
}

fn <impl at ui/drop/dynamic-drop.rs:26:1: 26:24>::drop::{closure#0}(_1: &mut [closure@ui/drop/dynamic-drop.rs:29:28: 29:31], _2: &bool) -> bool {
    debug d => _2;
    let mut _0: bool;

    bb0: {
        _0 = (*_2);
        return;
    }
}

fn <impl at ui/drop/dynamic-drop.rs:35:1: 35:15>::new(_1: usize) -> Allocator {
    debug failing_op => _1;
    let mut _0: Allocator;
    let mut _2: std::cell::Cell<usize>;
    let mut _3: std::cell::RefCell<std::vec::Vec<bool>>;
    let mut _4: std::vec::Vec<bool>;

    bb0: {
        _2 = Cell::<usize>::new(const 0_usize) -> bb1;
    }

    bb1: {
        _4 = Vec::<bool>::new() -> bb2;
    }

    bb2: {
        _3 = RefCell::<Vec<bool>>::new(move _4) -> bb3;
    }

    bb3: {
        _0 = Allocator { data: move _3, failing_op: _1, cur_ops: move _2 };
        return;
    }
}

fn <impl at ui/drop/dynamic-drop.rs:35:1: 35:15>::alloc(_1: &Allocator) -> Ptr<'_> {
    debug self => _1;
    let mut _0: Ptr<'_>;
    let _2: ();
    let mut _3: &std::cell::Cell<usize>;
    let mut _4: usize;
    let mut _5: usize;
    let mut _6: &std::cell::Cell<usize>;
    let mut _7: bool;
    let mut _8: usize;
    let mut _9: &std::cell::Cell<usize>;
    let mut _10: usize;
    let _11: !;
    let mut _12: std::cell::RefMut<'_, std::vec::Vec<bool>>;
    let mut _13: &std::cell::RefCell<std::vec::Vec<bool>>;
    let mut _15: &std::vec::Vec<bool>;
    let _16: &std::vec::Vec<bool>;
    let mut _17: &std::cell::RefMut<'_, std::vec::Vec<bool>>;
    let _18: ();
    let mut _19: &mut std::vec::Vec<bool>;
    let mut _20: &mut std::vec::Vec<bool>;
    let mut _21: &mut std::cell::RefMut<'_, std::vec::Vec<bool>>;
    let mut _22: usize;
    scope 1 {
        debug data => _12;
        let _14: usize;
        scope 2 {
            debug addr => _14;
        }
    }

    bb0: {
        _3 = &((*_1).2: std::cell::Cell<usize>);
        _6 = &((*_1).2: std::cell::Cell<usize>);
        _5 = Cell::<usize>::get(move _6) -> bb1;
    }

    bb1: {
        _4 = Add(move _5, const 1_usize);
        _2 = Cell::<usize>::set(move _3, move _4) -> bb2;
    }

    bb2: {
        _9 = &((*_1).2: std::cell::Cell<usize>);
        _8 = Cell::<usize>::get(move _9) -> bb3;
    }

    bb3: {
        _10 = ((*_1).1: usize);
        _7 = Eq(move _8, move _10);
        switchInt(move _7) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _11 = panic_any::<InjectedFailure>(const InjectedFailure);
    }

    bb5: {
        _13 = &((*_1).0: std::cell::RefCell<std::vec::Vec<bool>>);
        _12 = RefCell::<Vec<bool>>::borrow_mut(move _13) -> bb6;
    }

    bb6: {
        _17 = &_12;
        _16 = <RefMut<'_, Vec<bool>> as Deref>::deref(move _17) -> [return: bb7, unwind: bb12];
    }

    bb7: {
        _15 = _16;
        _14 = Vec::<bool>::len(move _15) -> [return: bb8, unwind: bb12];
    }

    bb8: {
        _21 = &mut _12;
        _20 = <RefMut<'_, Vec<bool>> as DerefMut>::deref_mut(move _21) -> [return: bb9, unwind: bb12];
    }

    bb9: {
        _19 = _20;
        _18 = Vec::<bool>::push(move _19, const true) -> [return: bb10, unwind: bb12];
    }

    bb10: {
        _22 = _14;
        _0 = Ptr::<'_>(move _22, _1);
        drop(_12) -> bb11;
    }

    bb11: {
        return;
    }

    bb12 (cleanup): {
        drop(_12) -> [return: bb13, unwind terminate];
    }

    bb13 (cleanup): {
        resume;
    }
}

fn <impl at ui/drop/dynamic-drop.rs:35:1: 35:15>::alloc_leaked(_1: &Allocator, _2: Vec<usize>) -> Ptr<'_> {
    debug self => _1;
    debug exceptions => _2;
    let mut _0: Ptr<'_>;
    let _3: Ptr<'_>;
    let mut _4: &Allocator;
    let mut _5: bool;
    let mut _6: &mut std::slice::Iter<'_, usize>;
    let mut _7: std::slice::Iter<'_, usize>;
    let mut _8: &[usize];
    let _9: &[usize];
    let mut _10: &std::vec::Vec<usize>;
    let mut _11: [closure@ui/drop/dynamic-drop.rs:63:34: 63:45];
    let mut _12: &&Allocator;
    let mut _14: &std::cell::RefCell<std::vec::Vec<bool>>;
    let mut _15: &mut bool;
    let mut _16: &mut std::vec::Vec<bool>;
    let mut _17: &mut std::vec::Vec<bool>;
    let mut _18: &mut std::cell::RefMut<'_, std::vec::Vec<bool>>;
    let mut _19: usize;
    scope 1 {
        debug ptr => _3;
        let mut _13: std::cell::RefMut<'_, std::vec::Vec<bool>>;
        scope 2 {
            debug data => _13;
        }
    }

    bb0: {
        _4 = _1;
        _3 = Allocator::alloc(move _4) -> [return: bb1, unwind: bb13];
    }

    bb1: {
        _10 = &_2;
        _9 = <Vec<usize> as Deref>::deref(move _10) -> [return: bb2, unwind: bb12];
    }

    bb2: {
        _8 = _9;
        _7 = core::slice::<impl [usize]>::iter(move _8) -> [return: bb3, unwind: bb12];
    }

    bb3: {
        _6 = &mut _7;
        _12 = &_1;
        _11 = [closure@ui/drop/dynamic-drop.rs:63:34: 63:45] { self: move _12 };
        _5 = <std::slice::Iter<'_, usize> as Iterator>::any::<[closure@ui/drop/dynamic-drop.rs:63:34: 63:45]>(move _6, move _11) -> [return: bb4, unwind: bb12];
    }

    bb4: {
        switchInt(move _5) -> [0: bb9, otherwise: bb5];
    }

    bb5: {
        _14 = &((*_1).0: std::cell::RefCell<std::vec::Vec<bool>>);
        _13 = RefCell::<Vec<bool>>::borrow_mut(move _14) -> [return: bb6, unwind: bb12];
    }

    bb6: {
        _18 = &mut _13;
        _17 = <RefMut<'_, Vec<bool>> as DerefMut>::deref_mut(move _18) -> [return: bb7, unwind: bb11];
    }

    bb7: {
        _16 = _17;
        _19 = (_3.0: usize);
        _15 = <Vec<bool> as IndexMut<usize>>::index_mut(move _16, move _19) -> [return: bb8, unwind: bb11];
    }

    bb8: {
        (*_15) = const false;
        drop(_13) -> [return: bb9, unwind: bb12];
    }

    bb9: {
        _0 = move _3;
        drop(_2) -> bb10;
    }

    bb10: {
        return;
    }

    bb11 (cleanup): {
        drop(_13) -> [return: bb12, unwind terminate];
    }

    bb12 (cleanup): {
        drop(_3) -> [return: bb13, unwind terminate];
    }

    bb13 (cleanup): {
        drop(_2) -> [return: bb14, unwind terminate];
    }

    bb14 (cleanup): {
        resume;
    }
}

fn <impl at ui/drop/dynamic-drop.rs:35:1: 35:15>::alloc_leaked::{closure#0}(_1: &mut [closure@ui/drop/dynamic-drop.rs:63:34: 63:45], _2: &usize) -> bool {
    debug operation => _2;
    debug self => (*((*_1).0: &&Allocator));
    let mut _0: bool;
    let mut _3: usize;
    let mut _4: usize;
    let mut _5: &&Allocator;
    let mut _6: &Allocator;

    bb0: {
        _3 = (*_2);
        _5 = deref_copy ((*_1).0: &&Allocator);
        _6 = deref_copy (*_5);
        _4 = ((*_6).1: usize);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn <impl at ui/drop/dynamic-drop.rs:72:1: 72:26>::drop(_1: &mut Ptr<'_>) -> () {
    debug self => _1;
    let mut _0: ();
    let mut _2: &mut bool;
    let mut _3: &mut std::vec::Vec<bool>;
    let mut _4: &mut std::vec::Vec<bool>;
    let mut _5: &mut std::cell::RefMut<'_, std::vec::Vec<bool>>;
    let mut _6: std::cell::RefMut<'_, std::vec::Vec<bool>>;
    let mut _7: &std::cell::RefCell<std::vec::Vec<bool>>;
    let mut _8: usize;
    let _9: !;
    let mut _10: std::fmt::Arguments<'_>;
    let mut _11: &[&str];
    let _12: &[&str; 1];
    let _13: [&str; 1];
    let mut _14: &[core::fmt::rt::Argument<'_>];
    let _15: &[core::fmt::rt::Argument<'_>; 1];
    let _16: [core::fmt::rt::Argument<'_>; 1];
    let mut _17: core::fmt::rt::Argument<'_>;
    let _18: &usize;
    let _19: &mut bool;
    let _20: ();
    let mut _21: &std::cell::Cell<usize>;
    let mut _22: usize;
    let mut _23: usize;
    let mut _24: &std::cell::Cell<usize>;
    let mut _25: bool;
    let mut _26: usize;
    let mut _27: &std::cell::Cell<usize>;
    let mut _28: usize;
    let _29: !;
    let mut _30: &Allocator;
    let mut _31: &Allocator;
    let mut _32: &Allocator;
    let mut _33: &Allocator;
    let mut _34: &Allocator;
    scope 1 {
        debug d => _19;
    }

    bb0: {
        _30 = deref_copy ((*_1).1: &Allocator);
        _7 = &((*_30).0: std::cell::RefCell<std::vec::Vec<bool>>);
        _6 = RefCell::<Vec<bool>>::borrow_mut(move _7) -> bb1;
    }

    bb1: {
        _5 = &mut _6;
        _4 = <RefMut<'_, Vec<bool>> as DerefMut>::deref_mut(move _5) -> [return: bb2, unwind: bb14];
    }

    bb2: {
        _3 = _4;
        _8 = ((*_1).0: usize);
        _2 = <Vec<bool> as IndexMut<usize>>::index_mut(move _3, move _8) -> [return: bb3, unwind: bb14];
    }

    bb3: {
        switchInt((*_2)) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _19 = _2;
        (*_19) = const false;
        drop(_6) -> bb8;
    }

    bb5: {
        _13 = [const "double free at index "];
        _12 = &_13;
        _11 = _12 as &[&str] (Pointer(Unsize));
        _18 = &((*_1).0: usize);
        _17 = core::fmt::rt::Argument::<'_>::new_debug::<usize>(_18) -> [return: bb6, unwind: bb14];
    }

    bb6: {
        _16 = [move _17];
        _15 = &_16;
        _14 = _15 as &[core::fmt::rt::Argument<'_>] (Pointer(Unsize));
        _10 = Arguments::<'_>::new_v1(move _11, move _14) -> [return: bb7, unwind: bb14];
    }

    bb7: {
        _9 = panic_fmt(move _10) -> bb14;
    }

    bb8: {
        _31 = deref_copy ((*_1).1: &Allocator);
        _21 = &((*_31).2: std::cell::Cell<usize>);
        _32 = deref_copy ((*_1).1: &Allocator);
        _24 = &((*_32).2: std::cell::Cell<usize>);
        _23 = Cell::<usize>::get(move _24) -> bb9;
    }

    bb9: {
        _22 = Add(move _23, const 1_usize);
        _20 = Cell::<usize>::set(move _21, move _22) -> bb10;
    }

    bb10: {
        _33 = deref_copy ((*_1).1: &Allocator);
        _27 = &((*_33).2: std::cell::Cell<usize>);
        _26 = Cell::<usize>::get(move _27) -> bb11;
    }

    bb11: {
        _34 = deref_copy ((*_1).1: &Allocator);
        _28 = ((*_34).1: usize);
        _25 = Eq(move _26, move _28);
        switchInt(move _25) -> [0: bb13, otherwise: bb12];
    }

    bb12: {
        _29 = panic_any::<InjectedFailure>(const InjectedFailure);
    }

    bb13: {
        return;
    }

    bb14 (cleanup): {
        drop(_6) -> [return: bb15, unwind terminate];
    }

    bb15 (cleanup): {
        resume;
    }
}

fn dynamic_init(_1: &Allocator, _2: bool) -> () {
    debug a => _1;
    debug c => _2;
    let mut _0: ();
    let _3: std::option::Option<Ptr<'_>>;
    let mut _4: std::option::Option<Ptr<'_>>;
    let mut _5: Ptr<'_>;
    let mut _6: bool;
    scope 1 {
        debug _x => _3;
    }

    bb0: {
        _6 = const false;
        switchInt(_2) -> [0: bb3, otherwise: bb1];
    }

    bb1: {
        _5 = Allocator::alloc(_1) -> bb2;
    }

    bb2: {
        _4 = Option::<Ptr<'_>>::Some(move _5);
        _6 = const true;
        _3 = move _4;
        goto -> bb3;
    }

    bb3: {
        switchInt(_6) -> [0: bb4, otherwise: bb5];
    }

    bb4: {
        _6 = const false;
        return;
    }

    bb5: {
        drop(_3) -> bb4;
    }
}

fn dynamic_drop(_1: &Allocator, _2: bool) -> () {
    debug a => _1;
    debug c => _2;
    let mut _0: ();
    let _3: Ptr<'_>;
    let _4: std::option::Option<Ptr<'_>>;
    let mut _5: Ptr<'_>;
    let mut _6: bool;
    scope 1 {
        debug x => _3;
    }

    bb0: {
        _6 = const false;
        _6 = const true;
        _3 = Allocator::alloc(_1) -> bb1;
    }

    bb1: {
        switchInt(_2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = const false;
        _5 = move _3;
        _4 = Option::<Ptr<'_>>::Some(move _5);
        goto -> bb4;
    }

    bb3: {
        _4 = Option::<Ptr<'_>>::None;
        goto -> bb4;
    }

    bb4: {
        drop(_4) -> [return: bb5, unwind: bb10];
    }

    bb5: {
        switchInt(_6) -> [0: bb6, otherwise: bb8];
    }

    bb6: {
        _6 = const false;
        return;
    }

    bb7 (cleanup): {
        resume;
    }

    bb8: {
        drop(_3) -> bb6;
    }

    bb9 (cleanup): {
        drop(_3) -> [return: bb7, unwind terminate];
    }

    bb10 (cleanup): {
        switchInt(_6) -> [0: bb7, otherwise: bb9];
    }
}

fn struct_dynamic_drop(_1: &Allocator, _2: bool, _3: bool, _4: bool) -> () {
    debug a => _1;
    debug c0 => _2;
    debug c1 => _3;
    debug c => _4;
    let mut _0: ();
    let mut _5: std::ops::Range<i32>;
    let mut _6: std::ops::Range<i32>;
    let mut _7: std::ops::Range<i32>;
    let mut _8: std::option::Option<i32>;
    let mut _9: &mut std::ops::Range<i32>;
    let mut _10: isize;
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: bool;
    let mut _17: bool;
    let mut _18: bool;
    let mut _19: Ptr<'_>;
    let mut _20: Ptr<'_>;
    let mut _21: Ptr<'_>;
    let mut _22: TwoPtrs<'_>;
    let mut _23: Ptr<'_>;
    let mut _24: Ptr<'_>;
    let _25: ();
    let mut _26: Ptr<'_>;
    let _27: ();
    let mut _28: Ptr<'_>;
    let mut _29: bool;
    let mut _30: bool;
    let mut _31: bool;
    let mut _32: bool;
    scope 1 {
        debug iter => _7;
        let _11: i32;
        scope 2 {
            debug i => _11;
            let _12: (Ptr<'_>, Ptr<'_>, Ptr<'_>);
            scope 3 {
                debug x => _12;
                let _13: TwoPtrs<'_>;
                scope 4 {
                    debug y => _13;
                }
            }
        }
    }

    bb0: {
        _31 = const false;
        _29 = const false;
        _32 = const false;
        _30 = const false;
        _6 = std::ops::Range::<i32> { start: const 0_i32, end: const 2_i32 };
        _5 = <std::ops::Range<i32> as IntoIterator>::into_iter(move _6) -> bb1;
    }

    bb1: {
        _7 = move _5;
        goto -> bb2;
    }

    bb2: {
        _9 = &mut _7;
        _8 = <std::ops::Range<i32> as Iterator>::next(_9) -> bb3;
    }

    bb3: {
        _10 = discriminant(_8);
        switchInt(move _10) -> [0: bb6, 1: bb4, otherwise: bb5];
    }

    bb4: {
        _11 = ((_8 as Some).0: i32);
        switchInt(_2) -> [0: bb10, otherwise: bb11];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        return;
    }

    bb7: {
        _14 = const true;
        goto -> bb9;
    }

    bb8: {
        switchInt(_3) -> [0: bb13, otherwise: bb14];
    }

    bb9: {
        switchInt(move _14) -> [0: bb24, otherwise: bb16];
    }

    bb10: {
        _15 = const false;
        goto -> bb12;
    }

    bb11: {
        _16 = Eq(_11, const 0_i32);
        _15 = move _16;
        goto -> bb12;
    }

    bb12: {
        switchInt(move _15) -> [0: bb8, otherwise: bb7];
    }

    bb13: {
        _17 = const false;
        goto -> bb15;
    }

    bb14: {
        _18 = Eq(_11, const 1_i32);
        _17 = move _18;
        goto -> bb15;
    }

    bb15: {
        _14 = move _17;
        goto -> bb9;
    }

    bb16: {
        _19 = Allocator::alloc(_1) -> [return: bb17, unwind: bb49];
    }

    bb17: {
        _20 = Allocator::alloc(_1) -> [return: bb18, unwind: bb27];
    }

    bb18: {
        _21 = Allocator::alloc(_1) -> [return: bb19, unwind: bb26];
    }

    bb19: {
        _31 = const true;
        _32 = const true;
        _12 = (move _19, move _20, move _21);
        _23 = Allocator::alloc(_1) -> [return: bb20, unwind: bb49];
    }

    bb20: {
        _24 = Allocator::alloc(_1) -> [return: bb21, unwind: bb25];
    }

    bb21: {
        _22 = TwoPtrs::<'_>(move _23, move _24);
        _29 = const true;
        _30 = const true;
        _13 = move _22;
        switchInt(_4) -> [0: bb24, otherwise: bb22];
    }

    bb22: {
        _32 = const false;
        _26 = move (_12.1: Ptr<'_>);
        _25 = std::mem::drop::<Ptr<'_>>(move _26) -> [return: bb23, unwind: bb49];
    }

    bb23: {
        _30 = const false;
        _28 = move (_13.0: Ptr<'_>);
        _27 = std::mem::drop::<Ptr<'_>>(move _28) -> [return: bb55, unwind: bb49];
    }

    bb24: {
        switchInt(_30) -> [0: bb34, otherwise: bb35];
    }

    bb25 (cleanup): {
        drop(_23) -> [return: bb49, unwind terminate];
    }

    bb26 (cleanup): {
        drop(_20) -> [return: bb27, unwind terminate];
    }

    bb27 (cleanup): {
        drop(_19) -> [return: bb49, unwind terminate];
    }

    bb28 (cleanup): {
        switchInt(_31) -> [0: bb52, otherwise: bb54];
    }

    bb29 (cleanup): {
        resume;
    }

    bb30: {
        _29 = const false;
        _29 = const false;
        _30 = const false;
        switchInt(_31) -> [0: bb43, otherwise: bb45];
    }

    bb31 (cleanup): {
        drop((_13.1: Ptr<'_>)) -> [return: bb28, unwind terminate];
    }

    bb32 (cleanup): {
        switchInt(_29) -> [0: bb28, otherwise: bb31];
    }

    bb33: {
        drop((_13.1: Ptr<'_>)) -> [return: bb30, unwind: bb28];
    }

    bb34: {
        switchInt(_29) -> [0: bb30, otherwise: bb33];
    }

    bb35: {
        drop((_13.0: Ptr<'_>)) -> [return: bb34, unwind: bb32];
    }

    bb36: {
        _31 = const false;
        _31 = const false;
        _32 = const false;
        goto -> bb2;
    }

    bb37 (cleanup): {
        drop((_12.2: Ptr<'_>)) -> [return: bb29, unwind terminate];
    }

    bb38 (cleanup): {
        switchInt(_31) -> [0: bb29, otherwise: bb37];
    }

    bb39 (cleanup): {
        switchInt(_32) -> [0: bb38, otherwise: bb40];
    }

    bb40 (cleanup): {
        drop((_12.1: Ptr<'_>)) -> [return: bb38, unwind terminate];
    }

    bb41: {
        drop((_12.2: Ptr<'_>)) -> bb36;
    }

    bb42: {
        switchInt(_31) -> [0: bb36, otherwise: bb41];
    }

    bb43: {
        switchInt(_32) -> [0: bb42, otherwise: bb44];
    }

    bb44: {
        drop((_12.1: Ptr<'_>)) -> [return: bb42, unwind: bb38];
    }

    bb45: {
        drop((_12.0: Ptr<'_>)) -> [return: bb43, unwind: bb39];
    }

    bb46 (cleanup): {
        drop((_13.1: Ptr<'_>)) -> [return: bb28, unwind terminate];
    }

    bb47 (cleanup): {
        switchInt(_29) -> [0: bb28, otherwise: bb46];
    }

    bb48 (cleanup): {
        drop((_13.0: Ptr<'_>)) -> [return: bb47, unwind terminate];
    }

    bb49 (cleanup): {
        switchInt(_30) -> [0: bb47, otherwise: bb48];
    }

    bb50 (cleanup): {
        drop((_12.2: Ptr<'_>)) -> [return: bb29, unwind terminate];
    }

    bb51 (cleanup): {
        switchInt(_31) -> [0: bb29, otherwise: bb50];
    }

    bb52 (cleanup): {
        switchInt(_32) -> [0: bb51, otherwise: bb53];
    }

    bb53 (cleanup): {
        drop((_12.1: Ptr<'_>)) -> [return: bb51, unwind terminate];
    }

    bb54 (cleanup): {
        drop((_12.0: Ptr<'_>)) -> [return: bb52, unwind terminate];
    }

    bb55: {
        goto -> bb24;
    }
}

fn field_assignment(_1: &Allocator, _2: bool) -> () {
    debug a => _1;
    debug c0 => _2;
    let mut _0: ();
    let mut _3: (TwoPtrs<'_>, Ptr<'_>);
    let mut _4: TwoPtrs<'_>;
    let mut _5: Ptr<'_>;
    let mut _6: Ptr<'_>;
    let mut _7: Ptr<'_>;
    let mut _8: Ptr<'_>;
    let mut _9: Ptr<'_>;
    let mut _11: Ptr<'_>;
    let mut _12: bool;
    let mut _13: bool;
    scope 1 {
        debug x => _3;
        let _10: Ptr<'_>;
        scope 2 {
            debug f => _10;
        }
    }

    bb0: {
        _12 = const false;
        _13 = const false;
        _5 = Allocator::alloc(_1) -> bb1;
    }

    bb1: {
        _6 = Allocator::alloc(_1) -> [return: bb2, unwind: bb14];
    }

    bb2: {
        _4 = TwoPtrs::<'_>(move _5, move _6);
        _7 = Allocator::alloc(_1) -> [return: bb3, unwind: bb13];
    }

    bb3: {
        _13 = const true;
        _3 = (move _4, move _7);
        _8 = Allocator::alloc(_1) -> [return: bb4, unwind: bb26];
    }

    bb4: {
        drop((_3.1: Ptr<'_>)) -> [return: bb5, unwind: bb6];
    }

    bb5: {
        (_3.1: Ptr<'_>) = move _8;
        _9 = Allocator::alloc(_1) -> [return: bb7, unwind: bb26];
    }

    bb6 (cleanup): {
        (_3.1: Ptr<'_>) = move _8;
        goto -> bb26;
    }

    bb7: {
        drop((_3.1: Ptr<'_>)) -> [return: bb8, unwind: bb9];
    }

    bb8: {
        (_3.1: Ptr<'_>) = move _9;
        _13 = const false;
        _12 = const true;
        _10 = move ((_3.0: TwoPtrs<'_>).0: Ptr<'_>);
        switchInt(_2) -> [0: bb11, otherwise: bb10];
    }

    bb9 (cleanup): {
        (_3.1: Ptr<'_>) = move _9;
        goto -> bb26;
    }

    bb10: {
        _12 = const false;
        _11 = move _10;
        _13 = const true;
        ((_3.0: TwoPtrs<'_>).0: Ptr<'_>) = move _11;
        goto -> bb11;
    }

    bb11: {
        switchInt(_12) -> [0: bb12, otherwise: bb16];
    }

    bb12: {
        _12 = const false;
        switchInt(_13) -> [0: bb21, otherwise: bb22];
    }

    bb13 (cleanup): {
        drop(_4) -> [return: bb15, unwind terminate];
    }

    bb14 (cleanup): {
        drop(_5) -> [return: bb15, unwind terminate];
    }

    bb15 (cleanup): {
        resume;
    }

    bb16: {
        drop(_10) -> [return: bb12, unwind: bb26];
    }

    bb17: {
        _13 = const false;
        return;
    }

    bb18 (cleanup): {
        drop((_3.1: Ptr<'_>)) -> [return: bb15, unwind terminate];
    }

    bb19: {
        drop((_3.1: Ptr<'_>)) -> bb17;
    }

    bb20 (cleanup): {
        drop(((_3.0: TwoPtrs<'_>).1: Ptr<'_>)) -> [return: bb18, unwind terminate];
    }

    bb21: {
        drop(((_3.0: TwoPtrs<'_>).1: Ptr<'_>)) -> [return: bb19, unwind: bb18];
    }

    bb22: {
        drop(((_3.0: TwoPtrs<'_>).0: Ptr<'_>)) -> [return: bb21, unwind: bb20];
    }

    bb23 (cleanup): {
        drop((_3.1: Ptr<'_>)) -> [return: bb15, unwind terminate];
    }

    bb24 (cleanup): {
        drop(((_3.0: TwoPtrs<'_>).1: Ptr<'_>)) -> [return: bb23, unwind terminate];
    }

    bb25 (cleanup): {
        drop(((_3.0: TwoPtrs<'_>).0: Ptr<'_>)) -> [return: bb24, unwind terminate];
    }

    bb26 (cleanup): {
        switchInt(_13) -> [0: bb24, otherwise: bb25];
    }
}

fn assignment2(_1: &Allocator, _2: bool, _3: bool) -> () {
    debug a => _1;
    debug c0 => _2;
    debug c1 => _3;
    let mut _0: ();
    let mut _4: Ptr<'_>;
    let _6: ();
    let mut _7: Ptr<'_>;
    let mut _8: Ptr<'_>;
    let mut _9: Ptr<'_>;
    let mut _10: bool;
    let mut _11: bool;
    scope 1 {
        debug _v => _4;
        let mut _5: Ptr<'_>;
        scope 2 {
            debug _w => _5;
        }
    }

    bb0: {
        _10 = const false;
        _11 = const false;
        _10 = const true;
        _4 = Allocator::alloc(_1) -> bb1;
    }

    bb1: {
        _5 = Allocator::alloc(_1) -> [return: bb2, unwind: bb18];
    }

    bb2: {
        _11 = const true;
        switchInt(_2) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _10 = const false;
        _7 = move _4;
        _6 = std::mem::drop::<Ptr<'_>>(move _7) -> [return: bb19, unwind: bb16];
    }

    bb4: {
        _11 = const false;
        _8 = move _5;
        switchInt(_10) -> [0: bb5, otherwise: bb13];
    }

    bb5: {
        _10 = const true;
        _4 = move _8;
        switchInt(_3) -> [0: bb9, otherwise: bb7];
    }

    bb6 (cleanup): {
        _10 = const true;
        _4 = move _8;
        goto -> bb16;
    }

    bb7: {
        _9 = Allocator::alloc(_1) -> [return: bb8, unwind: bb16];
    }

    bb8: {
        _11 = const true;
        _5 = move _9;
        goto -> bb9;
    }

    bb9: {
        switchInt(_11) -> [0: bb10, otherwise: bb14];
    }

    bb10: {
        _11 = const false;
        drop(_4) -> bb11;
    }

    bb11: {
        _10 = const false;
        return;
    }

    bb12 (cleanup): {
        resume;
    }

    bb13: {
        drop(_4) -> [return: bb5, unwind: bb6];
    }

    bb14: {
        drop(_5) -> [return: bb10, unwind: bb18];
    }

    bb15 (cleanup): {
        drop(_5) -> [return: bb18, unwind terminate];
    }

    bb16 (cleanup): {
        switchInt(_11) -> [0: bb18, otherwise: bb15];
    }

    bb17 (cleanup): {
        drop(_4) -> [return: bb12, unwind terminate];
    }

    bb18 (cleanup): {
        switchInt(_10) -> [0: bb12, otherwise: bb17];
    }

    bb19: {
        goto -> bb4;
    }
}

fn assignment1(_1: &Allocator, _2: bool) -> () {
    debug a => _1;
    debug c0 => _2;
    let mut _0: ();
    let mut _3: Ptr<'_>;
    let _5: ();
    let mut _6: Ptr<'_>;
    let mut _7: Ptr<'_>;
    let mut _8: bool;
    let mut _9: bool;
    scope 1 {
        debug _v => _3;
        let mut _4: Ptr<'_>;
        scope 2 {
            debug _w => _4;
        }
    }

    bb0: {
        _8 = const false;
        _9 = const false;
        _8 = const true;
        _3 = Allocator::alloc(_1) -> bb1;
    }

    bb1: {
        _4 = Allocator::alloc(_1) -> [return: bb2, unwind: bb13];
    }

    bb2: {
        _9 = const true;
        switchInt(_2) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _8 = const false;
        _6 = move _3;
        _5 = std::mem::drop::<Ptr<'_>>(move _6) -> [return: bb14, unwind: bb11];
    }

    bb4: {
        _9 = const false;
        _7 = move _4;
        switchInt(_8) -> [0: bb5, otherwise: bb9];
    }

    bb5: {
        _8 = const true;
        _3 = move _7;
        _9 = const false;
        drop(_3) -> bb7;
    }

    bb6 (cleanup): {
        _8 = const true;
        _3 = move _7;
        goto -> bb11;
    }

    bb7: {
        _8 = const false;
        return;
    }

    bb8 (cleanup): {
        resume;
    }

    bb9: {
        drop(_3) -> [return: bb5, unwind: bb6];
    }

    bb10 (cleanup): {
        drop(_4) -> [return: bb13, unwind terminate];
    }

    bb11 (cleanup): {
        switchInt(_9) -> [0: bb13, otherwise: bb10];
    }

    bb12 (cleanup): {
        drop(_3) -> [return: bb8, unwind terminate];
    }

    bb13 (cleanup): {
        switchInt(_8) -> [0: bb8, otherwise: bb12];
    }

    bb14: {
        goto -> bb4;
    }
}

fn union1(_1: &Allocator) -> () {
    debug a => _1;
    let mut _0: ();
    let mut _3: std::mem::ManuallyDrop<Ptr<'_>>;
    let mut _4: Ptr<'_>;
    let mut _5: Ptr<'_>;
    let mut _6: &mut Ptr<'_>;
    let mut _7: &mut std::mem::ManuallyDrop<Ptr<'_>>;
    let _8: ();
    let mut _9: Ptr<'_>;
    let mut _10: std::mem::ManuallyDrop<Ptr<'_>>;
    let mut _11: bool;
    scope 1 {
        let mut _2: Boxy<Ptr<'_>>;
        scope 2 {
            debug u => _2;
        }
    }

    bb0: {
        _11 = const false;
        _4 = Allocator::alloc(_1) -> bb1;
    }

    bb1: {
        _3 = ManuallyDrop::<Ptr<'_>>::new(move _4) -> bb2;
    }

    bb2: {
        _2 = Boxy::<Ptr<'_>> { a: move _3 };
        _11 = const true;
        _5 = Allocator::alloc(_1) -> bb3;
    }

    bb3: {
        _7 = &mut (_2.1: std::mem::ManuallyDrop<Ptr<'_>>);
        _6 = <ManuallyDrop<Ptr<'_>> as DerefMut>::deref_mut(move _7) -> [return: bb4, unwind: bb11];
    }

    bb4: {
        drop((*_6)) -> [return: bb5, unwind: bb6];
    }

    bb5: {
        _11 = const false;
        (*_6) = move _5;
        _11 = const false;
        _10 = move (_2.0: std::mem::ManuallyDrop<Ptr<'_>>);
        _9 = ManuallyDrop::<Ptr<'_>>::into_inner(move _10) -> bb7;
    }

    bb6 (cleanup): {
        _11 = const false;
        (*_6) = move _5;
        goto -> bb11;
    }

    bb7: {
        _8 = std::mem::drop::<Ptr<'_>>(move _9) -> bb8;
    }

    bb8: {
        return;
    }

    bb9 (cleanup): {
        resume;
    }

    bb10 (cleanup): {
        drop(_5) -> [return: bb9, unwind terminate];
    }

    bb11 (cleanup): {
        switchInt(_11) -> [0: bb9, otherwise: bb10];
    }
}

fn array_simple(_1: &Allocator) -> () {
    debug a => _1;
    let mut _0: ();
    let _2: [Ptr<'_>; 4];
    let mut _3: Ptr<'_>;
    let mut _4: Ptr<'_>;
    let mut _5: Ptr<'_>;
    let mut _6: Ptr<'_>;
    scope 1 {
        debug _x => _2;
    }

    bb0: {
        _3 = Allocator::alloc(_1) -> bb1;
    }

    bb1: {
        _4 = Allocator::alloc(_1) -> [return: bb2, unwind: bb8];
    }

    bb2: {
        _5 = Allocator::alloc(_1) -> [return: bb3, unwind: bb7];
    }

    bb3: {
        _6 = Allocator::alloc(_1) -> [return: bb4, unwind: bb6];
    }

    bb4: {
        _2 = [move _3, move _4, move _5, move _6];
        drop(_2) -> bb5;
    }

    bb5: {
        return;
    }

    bb6 (cleanup): {
        drop(_5) -> [return: bb7, unwind terminate];
    }

    bb7 (cleanup): {
        drop(_4) -> [return: bb8, unwind terminate];
    }

    bb8 (cleanup): {
        drop(_3) -> [return: bb9, unwind terminate];
    }

    bb9 (cleanup): {
        resume;
    }
}

fn vec_simple(_1: &Allocator) -> () {
    debug a => _1;
    let mut _0: ();
    let _2: std::vec::Vec<Ptr<'_>>;
    let mut _3: std::boxed::Box<[Ptr<'_>]>;
    let mut _4: std::boxed::Box<[Ptr<'_>; 4]>;
    let mut _5: usize;
    let mut _6: usize;
    let mut _7: *mut u8;
    let mut _8: std::boxed::Box<[Ptr<'_>; 4]>;
    let mut _9: Ptr<'_>;
    let mut _10: Ptr<'_>;
    let mut _11: Ptr<'_>;
    let mut _12: Ptr<'_>;
    let mut _13: &mut std::boxed::Box<[Ptr<'_>; 4]>;
    let mut _14: ();
    let mut _15: *const [Ptr<'_>; 4];
    let mut _16: *const ();
    let mut _17: usize;
    let mut _18: usize;
    let mut _19: usize;
    let mut _20: usize;
    let mut _21: bool;
    scope 1 {
        debug _x => _2;
    }
    scope 2 {
    }

    bb0: {
        _5 = SizeOf([Ptr<'_>; 4]);
        _6 = AlignOf([Ptr<'_>; 4]);
        _7 = alloc::alloc::exchange_malloc(move _5, move _6) -> bb1;
    }

    bb1: {
        _8 = ShallowInitBox(move _7, [Ptr<'_>; 4]);
        _9 = Allocator::alloc(_1) -> [return: bb2, unwind: bb12];
    }

    bb2: {
        _10 = Allocator::alloc(_1) -> [return: bb3, unwind: bb10];
    }

    bb3: {
        _11 = Allocator::alloc(_1) -> [return: bb4, unwind: bb9];
    }

    bb4: {
        _12 = Allocator::alloc(_1) -> [return: bb5, unwind: bb8];
    }

    bb5: {
        _15 = (((_8.0: std::ptr::Unique<[Ptr<'_>; 4]>).0: std::ptr::NonNull<[Ptr<'_>; 4]>).0: *const [Ptr<'_>; 4]);
        _16 = _15 as *const () (PtrToPtr);
        _17 = _16 as usize (Transmute);
        _18 = AlignOf(Ptr<'_>);
        _19 = Sub(_18, const 1_usize);
        _20 = BitAnd(_17, _19);
        _21 = Eq(_20, const 0_usize);
        assert(_21, "misaligned pointer dereference: address must be a multiple of {} but is {}", _18, _17) -> [success: bb13, unwind unreachable];
    }

    bb6: {
        drop(_2) -> bb7;
    }

    bb7: {
        return;
    }

    bb8 (cleanup): {
        drop(_11) -> [return: bb9, unwind terminate];
    }

    bb9 (cleanup): {
        drop(_10) -> [return: bb10, unwind terminate];
    }

    bb10 (cleanup): {
        drop(_9) -> [return: bb12, unwind terminate];
    }

    bb11 (cleanup): {
        resume;
    }

    bb12 (cleanup): {
        _13 = &mut _8;
        _14 = <Box<[Ptr<'_>; 4]> as Drop>::drop(move _13) -> [return: bb11, unwind terminate];
    }

    bb13: {
        (*_15) = [move _9, move _10, move _11, move _12];
        _4 = move _8;
        _3 = move _4 as std::boxed::Box<[Ptr<'_>]> (Pointer(Unsize));
        _2 = slice::<impl [Ptr<'_>]>::into_vec::<std::alloc::Global>(move _3) -> bb6;
    }
}

fn generator(_1: &Allocator, _2: usize) -> () {
    debug a => _1;
    debug run_count => _2;
    let mut _0: ();
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: !;
    let mut _6: [generator@ui/drop/dynamic-drop.rs:178:19: 178:21];
    let mut _7: &&Allocator;
    let mut _8: std::ops::Range<usize>;
    let mut _9: std::ops::Range<usize>;
    let mut _11: std::option::Option<usize>;
    let mut _12: &mut std::ops::Range<usize>;
    let mut _13: isize;
    let _14: std::ops::GeneratorState<Ptr<'_>, ()>;
    let mut _15: std::pin::Pin<&mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21]>;
    let mut _16: &mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21];
    scope 1 {
        debug gen => _6;
        let mut _10: std::ops::Range<usize>;
        scope 2 {
            debug iter => _10;
        }
    }

    bb0: {
        _4 = Lt(_2, const 4_usize);
        _3 = Not(move _4);
        switchInt(move _3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _5 = core::panicking::panic(const "assertion failed: run_count < 4");
    }

    bb2: {
        _7 = &_1;
        _6 = [generator@ui/drop/dynamic-drop.rs:178:19: 178:21 (#0)] { a: move _7 };
        _9 = std::ops::Range::<usize> { start: const 0_usize, end: _2 };
        _8 = <std::ops::Range<usize> as IntoIterator>::into_iter(move _9) -> [return: bb3, unwind: bb12];
    }

    bb3: {
        _10 = move _8;
        goto -> bb4;
    }

    bb4: {
        _12 = &mut _10;
        _11 = <std::ops::Range<usize> as Iterator>::next(_12) -> [return: bb5, unwind: bb12];
    }

    bb5: {
        _13 = discriminant(_11);
        switchInt(move _13) -> [0: bb8, 1: bb6, otherwise: bb7];
    }

    bb6: {
        _16 = &mut _6;
        _15 = Pin::<&mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21]>::new(move _16) -> [return: bb9, unwind: bb12];
    }

    bb7: {
        unreachable;
    }

    bb8: {
        drop(_6) -> bb11;
    }

    bb9: {
        _14 = <[generator@ui/drop/dynamic-drop.rs:178:19: 178:21] as Generator>::resume(move _15, const ()) -> [return: bb10, unwind: bb12];
    }

    bb10: {
        drop(_14) -> [return: bb4, unwind: bb12];
    }

    bb11: {
        return;
    }

    bb12 (cleanup): {
        drop(_6) -> [return: bb13, unwind terminate];
    }

    bb13 (cleanup): {
        resume;
    }
}

fn generator::{closure#0}(_1: Pin<&mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21]>, _2: ()) -> GeneratorState<Ptr<'_>, ()> {
    debug a => (*((*(_1.0: &mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21])).0: &&Allocator));
    let mut _0: std::ops::GeneratorState<Ptr<'_>, ()>;
    let _3: (Ptr<'_>, (), Ptr<'_>, ());
    let mut _4: Ptr<'_>;
    let mut _5: Ptr<'_>;
    let mut _6: &&Allocator;
    let mut _7: &Allocator;
    let mut _8: &&Allocator;
    let mut _9: &Allocator;
    let mut _10: &&Allocator;
    let mut _11: &Allocator;
    let mut _12: &&Allocator;
    let mut _13: &Allocator;
    let mut _14: ();
    let mut _15: u32;
    let mut _16: &mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21];
    let mut _17: &mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21];
    let mut _18: &mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21];
    let mut _19: &mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21];
    let mut _20: &mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21];
    let mut _21: &mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21];
    let mut _22: &mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21];
    let mut _23: &mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21];
    let mut _24: &mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21];
    let mut _25: &mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21];
    let mut _26: &mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21];
    let mut _27: &mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21];
    let mut _28: &mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21];
    let mut _29: &mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21];
    let mut _30: &mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21];
    let mut _31: &mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21];
    let mut _32: &mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21];

    bb0: {
        _16 = deref_copy (_1.0: &mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21]);
        _15 = discriminant((*_16));
        switchInt(move _15) -> [0: bb1, 1: bb13, 2: bb12, 3: bb10, 4: bb11, otherwise: bb14];
    }

    bb1: {
        _17 = deref_copy (_1.0: &mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21]);
        _6 = deref_copy ((*_17).0: &&Allocator);
        _7 = deref_copy (*_6);
        _18 = deref_copy (_1.0: &mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21]);
        (((*_18) as variant#3).0: Ptr<'_>) = Allocator::alloc(_7) -> [return: bb2, unwind: bb9];
    }

    bb2: {
        _19 = deref_copy (_1.0: &mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21]);
        _8 = deref_copy ((*_19).0: &&Allocator);
        _9 = deref_copy (*_8);
        _4 = Allocator::alloc(_9) -> [return: bb3, unwind: bb8];
    }

    bb3: {
        _0 = GeneratorState::<Ptr<'_>, ()>::Yielded(move _4);
        _20 = deref_copy (_1.0: &mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21]);
        discriminant((*_20)) = 3;
        return;
    }

    bb4: {
        _23 = deref_copy (_1.0: &mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21]);
        _12 = deref_copy ((*_23).0: &&Allocator);
        _13 = deref_copy (*_12);
        _5 = Allocator::alloc(_13) -> [return: bb5, unwind: bb7];
    }

    bb5: {
        _0 = GeneratorState::<Ptr<'_>, ()>::Yielded(move _5);
        _24 = deref_copy (_1.0: &mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21]);
        discriminant((*_24)) = 4;
        return;
    }

    bb6: {
        _14 = const ();
        _0 = GeneratorState::<Ptr<'_>, ()>::Complete(move _14);
        _28 = deref_copy (_1.0: &mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21]);
        discriminant((*_28)) = 1;
        return;
    }

    bb7 (cleanup): {
        _29 = deref_copy (_1.0: &mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21]);
        drop((((*_29) as variant#4).2: Ptr<'_>)) -> [return: bb8, unwind terminate];
    }

    bb8 (cleanup): {
        _30 = deref_copy (_1.0: &mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21]);
        drop((((*_30) as variant#3).0: Ptr<'_>)) -> [return: bb9, unwind terminate];
    }

    bb9 (cleanup): {
        _31 = deref_copy (_1.0: &mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21]);
        discriminant((*_31)) = 2;
        resume;
    }

    bb10: {
        _32 = deref_copy (_1.0: &mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21]);
        (((*_32) as variant#4).1: ()) = move _2;
        _21 = deref_copy (_1.0: &mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21]);
        _10 = deref_copy ((*_21).0: &&Allocator);
        _11 = deref_copy (*_10);
        _22 = deref_copy (_1.0: &mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21]);
        (((*_22) as variant#4).2: Ptr<'_>) = Allocator::alloc(_11) -> [return: bb4, unwind: bb8];
    }

    bb11: {
        _25 = deref_copy (_1.0: &mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21]);
        _26 = deref_copy (_1.0: &mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21]);
        _27 = deref_copy (_1.0: &mut [generator@ui/drop/dynamic-drop.rs:178:19: 178:21]);
        _3 = (move (((*_25) as variant#3).0: Ptr<'_>), move (((*_26) as variant#4).1: ()), move (((*_27) as variant#4).2: Ptr<'_>), move _2);
        drop(_3) -> [return: bb6, unwind: bb9];
    }

    bb12: {
        assert(const false, "generator resumed after panicking") -> bb12;
    }

    bb13: {
        assert(const false, "generator resumed after completion") -> bb13;
    }

    bb14: {
        unreachable;
    }
}

fn mixed_drop_and_nondrop(_1: &Allocator) -> () {
    debug a => _1;
    let mut _0: ();
    let _2: Ptr<'_>;
    let _3: i32;
    let _4: Ptr<'_>;
    let mut _5: Ptr<'_>;
    let mut _6: Ptr<'_>;
    let mut _7: bool;
    scope 1 {
        debug x => _2;
        debug y => _3;
        debug z => _4;
    }

    bb0: {
        _7 = const false;
        _5 = Allocator::alloc(_1) -> [return: bb1, unwind: bb7];
    }

    bb1: {
        _7 = const true;
        _2 = move _5;
        _3 = const 5_i32;
        _6 = Allocator::alloc(_1) -> [return: bb2, unwind: bb7];
    }

    bb2: {
        _4 = move _6;
        drop(_4) -> [return: bb3, unwind: bb7];
    }

    bb3: {
        drop(_2) -> bb4;
    }

    bb4: {
        _7 = const false;
        return;
    }

    bb5 (cleanup): {
        resume;
    }

    bb6 (cleanup): {
        drop(_2) -> [return: bb5, unwind terminate];
    }

    bb7 (cleanup): {
        switchInt(_7) -> [0: bb5, otherwise: bb6];
    }
}

fn vec_unreachable(_1: &Allocator) -> () {
    debug a => _1;
    let mut _0: ();
    let _2: std::vec::Vec<Ptr<'_>>;
    let mut _3: usize;
    let mut _4: usize;
    let mut _5: *mut u8;
    let mut _6: std::boxed::Box<[Ptr<'_>; 4]>;
    let mut _7: Ptr<'_>;
    let mut _8: Ptr<'_>;
    let mut _9: Ptr<'_>;
    let mut _10: &mut std::boxed::Box<[Ptr<'_>; 4]>;
    let mut _11: ();
    let mut _12: &mut std::boxed::Box<[Ptr<'_>; 4]>;
    let mut _13: ();
    scope 1 {
        debug _x => _2;
    }
    scope 2 {
    }

    bb0: {
        _3 = SizeOf([Ptr<'_>; 4]);
        _4 = AlignOf([Ptr<'_>; 4]);
        _5 = alloc::alloc::exchange_malloc(move _3, move _4) -> bb1;
    }

    bb1: {
        _6 = ShallowInitBox(move _5, [Ptr<'_>; 4]);
        _7 = Allocator::alloc(_1) -> [return: bb2, unwind: bb12];
    }

    bb2: {
        _8 = Allocator::alloc(_1) -> [return: bb3, unwind: bb9];
    }

    bb3: {
        _9 = Allocator::alloc(_1) -> [return: bb4, unwind: bb8];
    }

    bb4: {
        drop(_9) -> [return: bb5, unwind: bb8];
    }

    bb5: {
        drop(_8) -> [return: bb6, unwind: bb9];
    }

    bb6: {
        drop(_7) -> [return: bb7, unwind: bb12];
    }

    bb7: {
        _10 = &mut _6;
        _11 = <Box<[Ptr<'_>; 4]> as Drop>::drop(move _10) -> bb11;
    }

    bb8 (cleanup): {
        drop(_8) -> [return: bb9, unwind terminate];
    }

    bb9 (cleanup): {
        drop(_7) -> [return: bb12, unwind terminate];
    }

    bb10 (cleanup): {
        resume;
    }

    bb11: {
        return;
    }

    bb12 (cleanup): {
        _12 = &mut _6;
        _13 = <Box<[Ptr<'_>; 4]> as Drop>::drop(move _12) -> [return: bb10, unwind terminate];
    }
}

fn slice_pattern_first(_1: &Allocator) -> () {
    debug a => _1;
    let mut _0: ();
    let _2: Ptr<'_>;
    let mut _3: [Ptr<'_>; 3];
    let mut _4: Ptr<'_>;
    let mut _5: Ptr<'_>;
    let mut _6: Ptr<'_>;
    scope 1 {
        debug _x => _2;
    }

    bb0: {
        _4 = Allocator::alloc(_1) -> bb1;
    }

    bb1: {
        _5 = Allocator::alloc(_1) -> [return: bb2, unwind: bb6];
    }

    bb2: {
        _6 = Allocator::alloc(_1) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        _3 = [move _4, move _5, move _6];
        _2 = move _3[0 of 3];
        drop(_3[1..3]) -> [return: bb9, unwind: bb8];
    }

    bb4: {
        return;
    }

    bb5 (cleanup): {
        drop(_5) -> [return: bb6, unwind terminate];
    }

    bb6 (cleanup): {
        drop(_4) -> [return: bb7, unwind terminate];
    }

    bb7 (cleanup): {
        resume;
    }

    bb8 (cleanup): {
        drop(_2) -> [return: bb7, unwind terminate];
    }

    bb9: {
        drop(_2) -> bb4;
    }
}

fn slice_pattern_middle(_1: &Allocator) -> () {
    debug a => _1;
    let mut _0: ();
    let _2: Ptr<'_>;
    let mut _3: [Ptr<'_>; 3];
    let mut _4: Ptr<'_>;
    let mut _5: Ptr<'_>;
    let mut _6: Ptr<'_>;
    scope 1 {
        debug _x => _2;
    }

    bb0: {
        _4 = Allocator::alloc(_1) -> bb1;
    }

    bb1: {
        _5 = Allocator::alloc(_1) -> [return: bb2, unwind: bb7];
    }

    bb2: {
        _6 = Allocator::alloc(_1) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        _3 = [move _4, move _5, move _6];
        _2 = move _3[1 of 3];
        drop(_3[2..3]) -> [return: bb11, unwind: bb10];
    }

    bb4: {
        return;
    }

    bb5 (cleanup): {
        drop(_2) -> [return: bb8, unwind terminate];
    }

    bb6 (cleanup): {
        drop(_5) -> [return: bb7, unwind terminate];
    }

    bb7 (cleanup): {
        drop(_4) -> [return: bb8, unwind terminate];
    }

    bb8 (cleanup): {
        resume;
    }

    bb9: {
        drop(_2) -> bb4;
    }

    bb10 (cleanup): {
        drop(_3[0..1]) -> [return: bb5, unwind terminate];
    }

    bb11: {
        drop(_3[0..1]) -> [return: bb9, unwind: bb5];
    }
}

fn slice_pattern_two(_1: &Allocator) -> () {
    debug a => _1;
    let mut _0: ();
    let _2: Ptr<'_>;
    let _3: Ptr<'_>;
    let mut _4: [Ptr<'_>; 4];
    let mut _5: Ptr<'_>;
    let mut _6: Ptr<'_>;
    let mut _7: Ptr<'_>;
    let mut _8: Ptr<'_>;
    scope 1 {
        debug _x => _2;
        debug _y => _3;
    }

    bb0: {
        _5 = Allocator::alloc(_1) -> bb1;
    }

    bb1: {
        _6 = Allocator::alloc(_1) -> [return: bb2, unwind: bb10];
    }

    bb2: {
        _7 = Allocator::alloc(_1) -> [return: bb3, unwind: bb9];
    }

    bb3: {
        _8 = Allocator::alloc(_1) -> [return: bb4, unwind: bb8];
    }

    bb4: {
        _4 = [move _5, move _6, move _7, move _8];
        _2 = move _4[0 of 4];
        _3 = move _4[2 of 4];
        drop(_4[3..4]) -> [return: bb15, unwind: bb13];
    }

    bb5: {
        drop(_2) -> bb6;
    }

    bb6: {
        return;
    }

    bb7 (cleanup): {
        drop(_2) -> [return: bb11, unwind terminate];
    }

    bb8 (cleanup): {
        drop(_7) -> [return: bb9, unwind terminate];
    }

    bb9 (cleanup): {
        drop(_6) -> [return: bb10, unwind terminate];
    }

    bb10 (cleanup): {
        drop(_5) -> [return: bb11, unwind terminate];
    }

    bb11 (cleanup): {
        resume;
    }

    bb12 (cleanup): {
        drop(_3) -> [return: bb7, unwind terminate];
    }

    bb13 (cleanup): {
        drop(_4[1..2]) -> [return: bb12, unwind terminate];
    }

    bb14: {
        drop(_3) -> [return: bb5, unwind: bb7];
    }

    bb15: {
        drop(_4[1..2]) -> [return: bb14, unwind: bb12];
    }
}

fn slice_pattern_last(_1: &Allocator) -> () {
    debug a => _1;
    let mut _0: ();
    let _2: Ptr<'_>;
    let mut _3: [Ptr<'_>; 4];
    let mut _4: Ptr<'_>;
    let mut _5: Ptr<'_>;
    let mut _6: Ptr<'_>;
    let mut _7: Ptr<'_>;
    scope 1 {
        debug _y => _2;
    }

    bb0: {
        _4 = Allocator::alloc(_1) -> bb1;
    }

    bb1: {
        _5 = Allocator::alloc(_1) -> [return: bb2, unwind: bb9];
    }

    bb2: {
        _6 = Allocator::alloc(_1) -> [return: bb3, unwind: bb8];
    }

    bb3: {
        _7 = Allocator::alloc(_1) -> [return: bb4, unwind: bb7];
    }

    bb4: {
        _3 = [move _4, move _5, move _6, move _7];
        _2 = move _3[3 of 4];
        drop(_3[0..3]) -> [return: bb11, unwind: bb6];
    }

    bb5: {
        return;
    }

    bb6 (cleanup): {
        drop(_2) -> [return: bb10, unwind terminate];
    }

    bb7 (cleanup): {
        drop(_6) -> [return: bb8, unwind terminate];
    }

    bb8 (cleanup): {
        drop(_5) -> [return: bb9, unwind terminate];
    }

    bb9 (cleanup): {
        drop(_4) -> [return: bb10, unwind terminate];
    }

    bb10 (cleanup): {
        resume;
    }

    bb11: {
        drop(_2) -> bb5;
    }
}

fn slice_pattern_one_of(_1: &Allocator, _2: usize) -> () {
    debug a => _1;
    debug i => _2;
    let mut _0: ();
    let _3: [Ptr<'_>; 4];
    let mut _4: Ptr<'_>;
    let mut _5: Ptr<'_>;
    let mut _6: Ptr<'_>;
    let mut _7: Ptr<'_>;
    let _13: !;
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: bool;
    let mut _17: bool;
    scope 1 {
        debug array => _3;
        let _8: Ptr<'_>;
        let _9: Ptr<'_>;
        let _10: Ptr<'_>;
        let _11: Ptr<'_>;
        let _12: Ptr<'_>;
        scope 2 {
            debug _x => _8;
        }
        scope 3 {
            debug a => _9;
        }
        scope 4 {
            debug a => _10;
        }
        scope 5 {
            debug a => _11;
        }
        scope 6 {
            debug a => _12;
        }
    }

    bb0: {
        _17 = const false;
        _16 = const false;
        _15 = const false;
        _14 = const false;
        _4 = Allocator::alloc(_1) -> bb1;
    }

    bb1: {
        _5 = Allocator::alloc(_1) -> [return: bb2, unwind: bb14];
    }

    bb2: {
        _6 = Allocator::alloc(_1) -> [return: bb3, unwind: bb13];
    }

    bb3: {
        _7 = Allocator::alloc(_1) -> [return: bb4, unwind: bb12];
    }

    bb4: {
        _14 = const true;
        _15 = const true;
        _16 = const true;
        _17 = const true;
        _3 = [move _4, move _5, move _6, move _7];
        switchInt(_2) -> [0: bb6, 1: bb7, 2: bb8, 3: bb9, otherwise: bb5];
    }

    bb5: {
        _13 = begin_panic::<&str>(const "unmatched") -> bb37;
    }

    bb6: {
        _17 = const false;
        _9 = move _3[0 of 4];
        _8 = move _9;
        goto -> bb10;
    }

    bb7: {
        _16 = const false;
        _10 = move _3[1 of 4];
        _8 = move _10;
        goto -> bb10;
    }

    bb8: {
        _15 = const false;
        _11 = move _3[2 of 4];
        _8 = move _11;
        goto -> bb10;
    }

    bb9: {
        _14 = const false;
        _12 = move _3[3 of 4];
        _8 = move _12;
        goto -> bb10;
    }

    bb10: {
        drop(_8) -> [return: bb11, unwind: bb37];
    }

    bb11: {
        switchInt(_14) -> [0: bb27, otherwise: bb29];
    }

    bb12 (cleanup): {
        drop(_6) -> [return: bb13, unwind terminate];
    }

    bb13 (cleanup): {
        drop(_5) -> [return: bb14, unwind terminate];
    }

    bb14 (cleanup): {
        drop(_4) -> [return: bb15, unwind terminate];
    }

    bb15 (cleanup): {
        resume;
    }

    bb16: {
        _14 = const false;
        _15 = const false;
        _16 = const false;
        _17 = const false;
        return;
    }

    bb17 (cleanup): {
        switchInt(_17) -> [0: bb15, otherwise: bb18];
    }

    bb18 (cleanup): {
        drop(_3[0 of 4]) -> [return: bb15, unwind terminate];
    }

    bb19 (cleanup): {
        switchInt(_16) -> [0: bb17, otherwise: bb20];
    }

    bb20 (cleanup): {
        drop(_3[1 of 4]) -> [return: bb17, unwind terminate];
    }

    bb21 (cleanup): {
        switchInt(_15) -> [0: bb19, otherwise: bb22];
    }

    bb22 (cleanup): {
        drop(_3[2 of 4]) -> [return: bb19, unwind terminate];
    }

    bb23: {
        switchInt(_17) -> [0: bb16, otherwise: bb24];
    }

    bb24: {
        drop(_3[0 of 4]) -> bb16;
    }

    bb25: {
        switchInt(_16) -> [0: bb23, otherwise: bb26];
    }

    bb26: {
        drop(_3[1 of 4]) -> [return: bb23, unwind: bb17];
    }

    bb27: {
        switchInt(_15) -> [0: bb25, otherwise: bb28];
    }

    bb28: {
        drop(_3[2 of 4]) -> [return: bb25, unwind: bb19];
    }

    bb29: {
        drop(_3[3 of 4]) -> [return: bb27, unwind: bb21];
    }

    bb30 (cleanup): {
        switchInt(_17) -> [0: bb15, otherwise: bb31];
    }

    bb31 (cleanup): {
        drop(_3[0 of 4]) -> [return: bb15, unwind terminate];
    }

    bb32 (cleanup): {
        switchInt(_16) -> [0: bb30, otherwise: bb33];
    }

    bb33 (cleanup): {
        drop(_3[1 of 4]) -> [return: bb30, unwind terminate];
    }

    bb34 (cleanup): {
        switchInt(_15) -> [0: bb32, otherwise: bb35];
    }

    bb35 (cleanup): {
        drop(_3[2 of 4]) -> [return: bb32, unwind terminate];
    }

    bb36 (cleanup): {
        drop(_3[3 of 4]) -> [return: bb34, unwind terminate];
    }

    bb37 (cleanup): {
        switchInt(_14) -> [0: bb34, otherwise: bb36];
    }
}

fn subslice_pattern_from_end(_1: &Allocator, _2: bool) -> () {
    debug a => _1;
    debug arg => _2;
    let mut _0: ();
    let _3: [Ptr<'_>; 3];
    let mut _4: Ptr<'_>;
    let mut _5: Ptr<'_>;
    let mut _6: Ptr<'_>;
    let mut _9: bool;
    scope 1 {
        debug a => _3;
        let _7: Ptr<'_>;
        let _8: [Ptr<'_>; 2];
        scope 2 {
            debug _x => _7;
        }
        scope 3 {
            debug _y => _8;
        }
    }

    bb0: {
        _9 = const false;
        _4 = Allocator::alloc(_1) -> bb1;
    }

    bb1: {
        _5 = Allocator::alloc(_1) -> [return: bb2, unwind: bb8];
    }

    bb2: {
        _6 = Allocator::alloc(_1) -> [return: bb3, unwind: bb7];
    }

    bb3: {
        _9 = const true;
        _3 = [move _4, move _5, move _6];
        switchInt(_2) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _7 = move _3[1 of 3];
        drop(_7) -> [return: bb6, unwind: bb16];
    }

    bb5: {
        _9 = const false;
        _8 = move _3[1..3];
        drop(_8) -> [return: bb6, unwind: bb16];
    }

    bb6: {
        switchInt(_9) -> [0: bb12, otherwise: bb13];
    }

    bb7 (cleanup): {
        drop(_5) -> [return: bb8, unwind terminate];
    }

    bb8 (cleanup): {
        drop(_4) -> [return: bb9, unwind terminate];
    }

    bb9 (cleanup): {
        resume;
    }

    bb10: {
        _9 = const false;
        return;
    }

    bb11 (cleanup): {
        drop(_3[0..1]) -> [return: bb9, unwind terminate];
    }

    bb12: {
        drop(_3[0..1]) -> bb10;
    }

    bb13: {
        drop(_3[2 of 3]) -> [return: bb12, unwind: bb11];
    }

    bb14 (cleanup): {
        drop(_3[0..1]) -> [return: bb9, unwind terminate];
    }

    bb15 (cleanup): {
        drop(_3[2 of 3]) -> [return: bb14, unwind terminate];
    }

    bb16 (cleanup): {
        switchInt(_9) -> [0: bb14, otherwise: bb15];
    }
}

fn subslice_pattern_from_end_with_drop(_1: &Allocator, _2: bool, _3: bool) -> () {
    debug a => _1;
    debug arg => _2;
    debug arg2 => _3;
    let mut _0: ();
    let _4: [Ptr<'_>; 5];
    let mut _5: Ptr<'_>;
    let mut _6: Ptr<'_>;
    let mut _7: Ptr<'_>;
    let mut _8: Ptr<'_>;
    let mut _9: Ptr<'_>;
    let _10: ();
    let mut _11: [Ptr<'_>; 5];
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: bool;
    let mut _17: bool;
    scope 1 {
        debug a => _4;
        let _12: Ptr<'_>;
        let _13: [Ptr<'_>; 4];
        scope 2 {
            debug _x => _12;
        }
        scope 3 {
            debug _y => _13;
        }
    }

    bb0: {
        _17 = const false;
        _16 = const false;
        _15 = const false;
        _14 = const false;
        _5 = Allocator::alloc(_1) -> bb1;
    }

    bb1: {
        _6 = Allocator::alloc(_1) -> [return: bb2, unwind: bb16];
    }

    bb2: {
        _7 = Allocator::alloc(_1) -> [return: bb3, unwind: bb15];
    }

    bb3: {
        _8 = Allocator::alloc(_1) -> [return: bb4, unwind: bb14];
    }

    bb4: {
        _9 = Allocator::alloc(_1) -> [return: bb5, unwind: bb13];
    }

    bb5: {
        _17 = const true;
        _14 = const true;
        _15 = const true;
        _16 = const true;
        _4 = [move _5, move _6, move _7, move _8, move _9];
        switchInt(_3) -> [0: bb8, otherwise: bb6];
    }

    bb6: {
        _17 = const false;
        _14 = const false;
        _15 = const false;
        _16 = const false;
        _11 = move _4;
        _10 = std::mem::drop::<[Ptr<'_>; 5]>(move _11) -> [return: bb7, unwind: bb37];
    }

    bb7: {
        _17 = const false;
        _14 = const false;
        _15 = const false;
        _16 = const false;
        goto -> bb12;
    }

    bb8: {
        switchInt(_2) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _12 = move _4[3 of 5];
        drop(_12) -> [return: bb11, unwind: bb37];
    }

    bb10: {
        _16 = const false;
        _15 = const false;
        _14 = const false;
        _13 = move _4[1..5];
        drop(_13) -> [return: bb11, unwind: bb37];
    }

    bb11: {
        switchInt(_14) -> [0: bb28, otherwise: bb29];
    }

    bb12: {
        return;
    }

    bb13 (cleanup): {
        drop(_8) -> [return: bb14, unwind terminate];
    }

    bb14 (cleanup): {
        drop(_7) -> [return: bb15, unwind terminate];
    }

    bb15 (cleanup): {
        drop(_6) -> [return: bb16, unwind terminate];
    }

    bb16 (cleanup): {
        drop(_5) -> [return: bb17, unwind terminate];
    }

    bb17 (cleanup): {
        resume;
    }

    bb18: {
        _17 = const false;
        _17 = const false;
        _14 = const false;
        _15 = const false;
        _16 = const false;
        goto -> bb12;
    }

    bb19 (cleanup): {
        drop(_4[0..1]) -> [return: bb17, unwind terminate];
    }

    bb20 (cleanup): {
        switchInt(_16) -> [0: bb19, otherwise: bb21];
    }

    bb21 (cleanup): {
        drop(_4[1 of 5]) -> [return: bb19, unwind terminate];
    }

    bb22 (cleanup): {
        drop(_4[2 of 5]) -> [return: bb20, unwind terminate];
    }

    bb23 (cleanup): {
        switchInt(_15) -> [0: bb20, otherwise: bb22];
    }

    bb24: {
        drop(_4[0..1]) -> bb18;
    }

    bb25: {
        switchInt(_16) -> [0: bb24, otherwise: bb26];
    }

    bb26: {
        drop(_4[1 of 5]) -> [return: bb24, unwind: bb19];
    }

    bb27: {
        drop(_4[2 of 5]) -> [return: bb25, unwind: bb20];
    }

    bb28: {
        switchInt(_15) -> [0: bb25, otherwise: bb27];
    }

    bb29: {
        drop(_4[4 of 5]) -> [return: bb28, unwind: bb23];
    }

    bb30 (cleanup): {
        drop(_4[0..1]) -> [return: bb17, unwind terminate];
    }

    bb31 (cleanup): {
        switchInt(_17) -> [0: bb17, otherwise: bb30];
    }

    bb32 (cleanup): {
        switchInt(_16) -> [0: bb31, otherwise: bb33];
    }

    bb33 (cleanup): {
        drop(_4[1 of 5]) -> [return: bb31, unwind terminate];
    }

    bb34 (cleanup): {
        drop(_4[2 of 5]) -> [return: bb32, unwind terminate];
    }

    bb35 (cleanup): {
        switchInt(_15) -> [0: bb32, otherwise: bb34];
    }

    bb36 (cleanup): {
        drop(_4[4 of 5]) -> [return: bb35, unwind terminate];
    }

    bb37 (cleanup): {
        switchInt(_14) -> [0: bb35, otherwise: bb36];
    }
}

fn slice_pattern_reassign(_1: &Allocator) -> () {
    debug a => _1;
    let mut _0: ();
    let mut _2: [Ptr<'_>; 2];
    let mut _3: Ptr<'_>;
    let mut _4: Ptr<'_>;
    let mut _6: Ptr<'_>;
    let mut _7: Ptr<'_>;
    let mut _9: bool;
    let mut _10: bool;
    scope 1 {
        debug ar => _2;
        let _5: Ptr<'_>;
        scope 2 {
            debug _x => _5;
            let _8: Ptr<'_>;
            scope 3 {
                debug _y => _8;
            }
        }
    }

    bb0: {
        _9 = const false;
        _10 = const false;
        _3 = Allocator::alloc(_1) -> bb1;
    }

    bb1: {
        _4 = Allocator::alloc(_1) -> [return: bb2, unwind: bb9];
    }

    bb2: {
        _10 = const true;
        _2 = [move _3, move _4];
        _10 = const false;
        _5 = move _2[1 of 2];
        _6 = Allocator::alloc(_1) -> [return: bb3, unwind: bb8];
    }

    bb3: {
        _9 = const true;
        _7 = Allocator::alloc(_1) -> [return: bb4, unwind: bb14];
    }

    bb4: {
        drop(_2[0..1]) -> [return: bb11, unwind: bb5];
    }

    bb5 (cleanup): {
        _9 = const false;
        _10 = const true;
        _2 = [move _6, move _7];
        goto -> bb14;
    }

    bb6: {
        drop(_5) -> [return: bb7, unwind: bb17];
    }

    bb7: {
        drop(_2[0..1]) -> bb12;
    }

    bb8 (cleanup): {
        drop(_5) -> [return: bb17, unwind terminate];
    }

    bb9 (cleanup): {
        drop(_3) -> [return: bb10, unwind terminate];
    }

    bb10 (cleanup): {
        resume;
    }

    bb11: {
        _9 = const false;
        _10 = const true;
        _2 = [move _6, move _7];
        _9 = const false;
        _10 = const false;
        _8 = move _2[1 of 2];
        drop(_8) -> [return: bb6, unwind: bb8];
    }

    bb12: {
        _10 = const false;
        return;
    }

    bb13 (cleanup): {
        drop(_6) -> [return: bb8, unwind terminate];
    }

    bb14 (cleanup): {
        switchInt(_9) -> [0: bb8, otherwise: bb13];
    }

    bb15 (cleanup): {
        drop(_2[0..1]) -> [return: bb10, unwind terminate];
    }

    bb16 (cleanup): {
        drop(_2[1 of 2]) -> [return: bb15, unwind terminate];
    }

    bb17 (cleanup): {
        switchInt(_10) -> [0: bb15, otherwise: bb16];
    }
}

fn subslice_pattern_reassign(_1: &Allocator) -> () {
    debug a => _1;
    let mut _0: ();
    let mut _2: [Ptr<'_>; 3];
    let mut _3: Ptr<'_>;
    let mut _4: Ptr<'_>;
    let mut _5: Ptr<'_>;
    let mut _7: Ptr<'_>;
    let mut _8: Ptr<'_>;
    let mut _9: Ptr<'_>;
    let mut _11: bool;
    let mut _12: bool;
    let mut _13: bool;
    let mut _14: bool;
    scope 1 {
        debug ar => _2;
        let _6: Ptr<'_>;
        scope 2 {
            debug _x => _6;
            let _10: [Ptr<'_>; 2];
            scope 3 {
                debug _y => _10;
            }
        }
    }

    bb0: {
        _12 = const false;
        _11 = const false;
        _14 = const false;
        _13 = const false;
        _3 = Allocator::alloc(_1) -> bb1;
    }

    bb1: {
        _4 = Allocator::alloc(_1) -> [return: bb2, unwind: bb12];
    }

    bb2: {
        _5 = Allocator::alloc(_1) -> [return: bb3, unwind: bb11];
    }

    bb3: {
        _13 = const true;
        _14 = const true;
        _2 = [move _3, move _4, move _5];
        _14 = const false;
        _6 = move _2[2 of 3];
        _7 = Allocator::alloc(_1) -> [return: bb4, unwind: bb10];
    }

    bb4: {
        _12 = const true;
        _8 = Allocator::alloc(_1) -> [return: bb5, unwind: bb21];
    }

    bb5: {
        _11 = const true;
        _9 = Allocator::alloc(_1) -> [return: bb6, unwind: bb19];
    }

    bb6: {
        drop(_2[1 of 3]) -> [return: bb16, unwind: bb15];
    }

    bb7 (cleanup): {
        _12 = const false;
        _11 = const false;
        _13 = const true;
        _14 = const true;
        _2 = [move _7, move _8, move _9];
        goto -> bb19;
    }

    bb8: {
        drop(_6) -> [return: bb9, unwind: bb26];
    }

    bb9: {
        drop(_2[0..1]) -> bb17;
    }

    bb10 (cleanup): {
        drop(_6) -> [return: bb26, unwind terminate];
    }

    bb11 (cleanup): {
        drop(_4) -> [return: bb12, unwind terminate];
    }

    bb12 (cleanup): {
        drop(_3) -> [return: bb13, unwind terminate];
    }

    bb13 (cleanup): {
        resume;
    }

    bb14: {
        _12 = const false;
        _11 = const false;
        _13 = const true;
        _14 = const true;
        _2 = [move _7, move _8, move _9];
        _11 = const false;
        _12 = const false;
        _13 = const false;
        _14 = const false;
        _10 = move _2[1..3];
        drop(_10) -> [return: bb8, unwind: bb10];
    }

    bb15 (cleanup): {
        drop(_2[0..1]) -> [return: bb7, unwind terminate];
    }

    bb16: {
        drop(_2[0..1]) -> [return: bb14, unwind: bb7];
    }

    bb17: {
        _13 = const false;
        _14 = const false;
        return;
    }

    bb18 (cleanup): {
        drop(_8) -> [return: bb21, unwind terminate];
    }

    bb19 (cleanup): {
        switchInt(_11) -> [0: bb21, otherwise: bb18];
    }

    bb20 (cleanup): {
        drop(_7) -> [return: bb10, unwind terminate];
    }

    bb21 (cleanup): {
        switchInt(_12) -> [0: bb10, otherwise: bb20];
    }

    bb22 (cleanup): {
        drop(_2[0..1]) -> [return: bb13, unwind terminate];
    }

    bb23 (cleanup): {
        switchInt(_13) -> [0: bb22, otherwise: bb24];
    }

    bb24 (cleanup): {
        drop(_2[1 of 3]) -> [return: bb22, unwind terminate];
    }

    bb25 (cleanup): {
        drop(_2[2 of 3]) -> [return: bb23, unwind terminate];
    }

    bb26 (cleanup): {
        switchInt(_14) -> [0: bb23, otherwise: bb25];
    }
}

fn index_field_mixed_ends(_1: &Allocator) -> () {
    debug a => _1;
    let mut _0: ();
    let _2: [(Ptr<'_>, Ptr<'_>); 2];
    let mut _3: (Ptr<'_>, Ptr<'_>);
    let mut _4: Ptr<'_>;
    let mut _5: Ptr<'_>;
    let mut _6: (Ptr<'_>, Ptr<'_>);
    let mut _7: Ptr<'_>;
    let mut _8: Ptr<'_>;
    scope 1 {
        debug ar => _2;
        let _9: Ptr<'_>;
        scope 2 {
            debug _x => _9;
            let _10: Ptr<'_>;
            scope 3 {
                debug _y => _10;
                let _11: Ptr<'_>;
                scope 4 {
                    debug _w => _11;
                    let _12: Ptr<'_>;
                    scope 5 {
                        debug _z => _12;
                    }
                }
            }
        }
    }

    bb0: {
        _4 = Allocator::alloc(_1) -> bb1;
    }

    bb1: {
        _5 = Allocator::alloc(_1) -> [return: bb2, unwind: bb14];
    }

    bb2: {
        _3 = (move _4, move _5);
        _7 = Allocator::alloc(_1) -> [return: bb3, unwind: bb13];
    }

    bb3: {
        _8 = Allocator::alloc(_1) -> [return: bb4, unwind: bb12];
    }

    bb4: {
        _6 = (move _7, move _8);
        _2 = [move _3, move _6];
        _9 = move (_2[0 of 2].0: Ptr<'_>);
        _10 = move (_2[0 of 2].1: Ptr<'_>);
        _11 = move (_2[1 of 2].1: Ptr<'_>);
        _12 = move (_2[1 of 2].0: Ptr<'_>);
        drop(_12) -> [return: bb5, unwind: bb9];
    }

    bb5: {
        drop(_11) -> [return: bb6, unwind: bb10];
    }

    bb6: {
        drop(_10) -> [return: bb7, unwind: bb11];
    }

    bb7: {
        drop(_9) -> bb8;
    }

    bb8: {
        return;
    }

    bb9 (cleanup): {
        drop(_11) -> [return: bb10, unwind terminate];
    }

    bb10 (cleanup): {
        drop(_10) -> [return: bb11, unwind terminate];
    }

    bb11 (cleanup): {
        drop(_9) -> [return: bb15, unwind terminate];
    }

    bb12 (cleanup): {
        drop(_7) -> [return: bb13, unwind terminate];
    }

    bb13 (cleanup): {
        drop(_3) -> [return: bb15, unwind terminate];
    }

    bb14 (cleanup): {
        drop(_4) -> [return: bb15, unwind terminate];
    }

    bb15 (cleanup): {
        resume;
    }
}

fn subslice_mixed_min_lengths(_1: &Allocator, _2: i32) -> () {
    debug a => _1;
    debug c => _2;
    let mut _0: ();
    let _3: [(Ptr<'_>, Ptr<'_>); 2];
    let mut _4: (Ptr<'_>, Ptr<'_>);
    let mut _5: Ptr<'_>;
    let mut _6: Ptr<'_>;
    let mut _7: (Ptr<'_>, Ptr<'_>);
    let mut _8: Ptr<'_>;
    let mut _9: Ptr<'_>;
    let mut _18: bool;
    let mut _19: bool;
    let mut _20: bool;
    let mut _21: bool;
    scope 1 {
        debug ar => _3;
        let _10: (Ptr<'_>, Ptr<'_>);
        let _11: (Ptr<'_>, Ptr<'_>);
        let _12: (Ptr<'_>, Ptr<'_>);
        let _13: Ptr<'_>;
        let _14: Ptr<'_>;
        let _15: Ptr<'_>;
        let _16: [(Ptr<'_>, Ptr<'_>); 2];
        let _17: [(Ptr<'_>, Ptr<'_>); 1];
        scope 2 {
            debug _x => _10;
        }
        scope 3 {
            debug _x => _11;
        }
        scope 4 {
            debug _x => _12;
        }
        scope 5 {
            debug _x => _13;
        }
        scope 6 {
            debug _x => _14;
        }
        scope 7 {
            debug _x => _15;
        }
        scope 8 {
            debug _y => _16;
        }
        scope 9 {
            debug _y => _17;
        }
    }

    bb0: {
        _20 = const false;
        _21 = const false;
        _18 = const false;
        _19 = const false;
        _5 = Allocator::alloc(_1) -> bb1;
    }

    bb1: {
        _6 = Allocator::alloc(_1) -> [return: bb2, unwind: bb15];
    }

    bb2: {
        _4 = (move _5, move _6);
        _8 = Allocator::alloc(_1) -> [return: bb3, unwind: bb14];
    }

    bb3: {
        _9 = Allocator::alloc(_1) -> [return: bb4, unwind: bb13];
    }

    bb4: {
        _7 = (move _8, move _9);
        _18 = const true;
        _19 = const true;
        _20 = const true;
        _21 = const true;
        _3 = [move _4, move _7];
        switchInt(_2) -> [0: bb6, 1: bb7, 2: bb8, 3: bb9, 4: bb10, 5: bb11, 6: bb12, otherwise: bb5];
    }

    bb5: {
        _20 = const false;
        _21 = const false;
        _17 = move _3[0..1];
        drop(_17) -> [return: bb33, unwind: bb41];
    }

    bb6: {
        _20 = const false;
        _21 = const false;
        _10 = move _3[0 of 2];
        drop(_10) -> [return: bb33, unwind: bb41];
    }

    bb7: {
        _20 = const false;
        _21 = const false;
        _11 = move _3[0 of 2];
        drop(_11) -> [return: bb33, unwind: bb41];
    }

    bb8: {
        _20 = const false;
        _21 = const false;
        _12 = move _3[0 of 2];
        drop(_12) -> [return: bb33, unwind: bb41];
    }

    bb9: {
        _21 = const false;
        _13 = move (_3[0 of 2].0: Ptr<'_>);
        drop(_13) -> [return: bb33, unwind: bb41];
    }

    bb10: {
        _19 = const false;
        _14 = move (_3[1 of 2].0: Ptr<'_>);
        drop(_14) -> [return: bb33, unwind: bb41];
    }

    bb11: {
        _21 = const false;
        _15 = move (_3[0 of 2].0: Ptr<'_>);
        drop(_15) -> [return: bb33, unwind: bb41];
    }

    bb12: {
        _20 = const false;
        _21 = const false;
        _18 = const false;
        _19 = const false;
        _16 = move _3[0..2];
        drop(_16) -> [return: bb33, unwind: bb41];
    }

    bb13 (cleanup): {
        drop(_8) -> [return: bb14, unwind terminate];
    }

    bb14 (cleanup): {
        drop(_4) -> [return: bb16, unwind terminate];
    }

    bb15 (cleanup): {
        drop(_5) -> [return: bb16, unwind terminate];
    }

    bb16 (cleanup): {
        resume;
    }

    bb17 (cleanup): {
        switchInt(_21) -> [0: bb19, otherwise: bb20];
    }

    bb18 (cleanup): {
        drop((_3[0 of 2].1: Ptr<'_>)) -> [return: bb16, unwind terminate];
    }

    bb19 (cleanup): {
        switchInt(_20) -> [0: bb16, otherwise: bb18];
    }

    bb20 (cleanup): {
        drop((_3[0 of 2].0: Ptr<'_>)) -> [return: bb19, unwind terminate];
    }

    bb21: {
        _20 = const false;
        _18 = const false;
        _19 = const false;
        _20 = const false;
        _21 = const false;
        return;
    }

    bb22 (cleanup): {
        drop((_3[0 of 2].1: Ptr<'_>)) -> [return: bb16, unwind terminate];
    }

    bb23 (cleanup): {
        switchInt(_20) -> [0: bb16, otherwise: bb22];
    }

    bb24: {
        drop((_3[0 of 2].1: Ptr<'_>)) -> bb21;
    }

    bb25: {
        switchInt(_20) -> [0: bb21, otherwise: bb24];
    }

    bb26: {
        drop((_3[0 of 2].0: Ptr<'_>)) -> [return: bb25, unwind: bb23];
    }

    bb27: {
        _18 = const false;
        switchInt(_21) -> [0: bb25, otherwise: bb26];
    }

    bb28 (cleanup): {
        drop((_3[1 of 2].1: Ptr<'_>)) -> [return: bb17, unwind terminate];
    }

    bb29 (cleanup): {
        switchInt(_18) -> [0: bb17, otherwise: bb28];
    }

    bb30: {
        drop((_3[1 of 2].1: Ptr<'_>)) -> [return: bb27, unwind: bb17];
    }

    bb31: {
        switchInt(_18) -> [0: bb27, otherwise: bb30];
    }

    bb32: {
        drop((_3[1 of 2].0: Ptr<'_>)) -> [return: bb31, unwind: bb29];
    }

    bb33: {
        switchInt(_19) -> [0: bb31, otherwise: bb32];
    }

    bb34 (cleanup): {
        switchInt(_21) -> [0: bb36, otherwise: bb37];
    }

    bb35 (cleanup): {
        drop((_3[0 of 2].1: Ptr<'_>)) -> [return: bb16, unwind terminate];
    }

    bb36 (cleanup): {
        switchInt(_20) -> [0: bb16, otherwise: bb35];
    }

    bb37 (cleanup): {
        drop((_3[0 of 2].0: Ptr<'_>)) -> [return: bb36, unwind terminate];
    }

    bb38 (cleanup): {
        drop((_3[1 of 2].1: Ptr<'_>)) -> [return: bb34, unwind terminate];
    }

    bb39 (cleanup): {
        switchInt(_18) -> [0: bb34, otherwise: bb38];
    }

    bb40 (cleanup): {
        drop((_3[1 of 2].0: Ptr<'_>)) -> [return: bb39, unwind terminate];
    }

    bb41 (cleanup): {
        switchInt(_19) -> [0: bb39, otherwise: bb40];
    }
}

fn bindings_after_at_dynamic_init_move(_1: &Allocator, _2: bool) -> () {
    debug a => _1;
    debug c => _2;
    let mut _0: ();
    let _3: std::option::Option<Ptr<'_>>;
    let mut _4: Ptr<'_>;
    let mut _6: isize;
    let mut _8: bool;
    let mut _9: bool;
    scope 1 {
        debug foo => _3;
        let _5: std::option::Option<Ptr<'_>>;
        scope 2 {
            debug _x => _5;
            scope 3 {
                debug bar => _7;
                let _7: std::option::Option<Ptr<'_>>;
            }
        }
    }

    bb0: {
        _9 = const false;
        _8 = const false;
        switchInt(_2) -> [0: bb3, otherwise: bb1];
    }

    bb1: {
        _4 = Allocator::alloc(_1) -> bb2;
    }

    bb2: {
        _9 = const true;
        _3 = Option::<Ptr<'_>>::Some(move _4);
        goto -> bb4;
    }

    bb3: {
        _9 = const true;
        _3 = Option::<Ptr<'_>>::None;
        goto -> bb4;
    }

    bb4: {
        _6 = discriminant(_3);
        switchInt(move _6) -> [1: bb5, otherwise: bb11];
    }

    bb5: {
        _9 = const false;
        _7 = move _3;
        _8 = const true;
        _5 = move _7;
        goto -> bb11;
    }

    bb6: {
        _8 = const false;
        switchInt(_9) -> [0: bb7, otherwise: bb12];
    }

    bb7: {
        _9 = const false;
        return;
    }

    bb8 (cleanup): {
        switchInt(_9) -> [0: bb9, otherwise: bb13];
    }

    bb9 (cleanup): {
        resume;
    }

    bb10: {
        drop(_5) -> [return: bb6, unwind: bb8];
    }

    bb11: {
        switchInt(_8) -> [0: bb6, otherwise: bb10];
    }

    bb12: {
        drop(_3) -> bb7;
    }

    bb13 (cleanup): {
        drop(_3) -> [return: bb9, unwind terminate];
    }
}

fn bindings_after_at_dynamic_init_ref(_1: &Allocator, _2: bool) -> () {
    debug a => _1;
    debug c => _2;
    let mut _0: ();
    let _3: std::option::Option<Ptr<'_>>;
    let mut _4: Ptr<'_>;
    let mut _5: &std::option::Option<Ptr<'_>>;
    let mut _6: isize;
    scope 1 {
        debug foo => _3;
        scope 2 {
            debug _x => _5;
            scope 3 {
                debug bar => _5;
                debug _baz => _7;
                let _7: &Ptr<'_>;
            }
        }
    }

    bb0: {
        switchInt(_2) -> [0: bb3, otherwise: bb1];
    }

    bb1: {
        _4 = Allocator::alloc(_1) -> bb2;
    }

    bb2: {
        _3 = Option::<Ptr<'_>>::Some(move _4);
        goto -> bb4;
    }

    bb3: {
        _3 = Option::<Ptr<'_>>::None;
        goto -> bb4;
    }

    bb4: {
        _5 = &_3;
        _6 = discriminant((*_5));
        switchInt(move _6) -> [1: bb5, otherwise: bb6];
    }

    bb5: {
        _7 = &(((*_5) as Some).0: Ptr<'_>);
        goto -> bb6;
    }

    bb6: {
        drop(_3) -> bb7;
    }

    bb7: {
        return;
    }
}

fn bindings_after_at_dynamic_drop_move(_1: &Allocator, _2: bool) -> () {
    debug a => _1;
    debug c => _2;
    let mut _0: ();
    let _3: std::option::Option<Ptr<'_>>;
    let mut _4: Ptr<'_>;
    let _5: std::option::Option<Ptr<'_>>;
    let mut _6: isize;
    let mut _8: bool;
    scope 1 {
        debug foo => _3;
        scope 2 {
            debug bar => _7;
            let _7: std::option::Option<Ptr<'_>>;
        }
    }

    bb0: {
        _8 = const false;
        switchInt(_2) -> [0: bb3, otherwise: bb1];
    }

    bb1: {
        _4 = Allocator::alloc(_1) -> bb2;
    }

    bb2: {
        _8 = const true;
        _3 = Option::<Ptr<'_>>::Some(move _4);
        goto -> bb4;
    }

    bb3: {
        _8 = const true;
        _3 = Option::<Ptr<'_>>::None;
        goto -> bb4;
    }

    bb4: {
        _6 = discriminant(_3);
        switchInt(move _6) -> [1: bb5, otherwise: bb6];
    }

    bb5: {
        _8 = const false;
        _7 = move _3;
        _5 = move _7;
        goto -> bb7;
    }

    bb6: {
        _5 = Option::<Ptr<'_>>::None;
        goto -> bb7;
    }

    bb7: {
        drop(_5) -> [return: bb8, unwind: bb13];
    }

    bb8: {
        switchInt(_8) -> [0: bb9, otherwise: bb11];
    }

    bb9: {
        _8 = const false;
        return;
    }

    bb10 (cleanup): {
        resume;
    }

    bb11: {
        drop(_3) -> bb9;
    }

    bb12 (cleanup): {
        drop(_3) -> [return: bb10, unwind terminate];
    }

    bb13 (cleanup): {
        switchInt(_8) -> [0: bb10, otherwise: bb12];
    }
}

fn bindings_after_at_dynamic_drop_ref(_1: &Allocator, _2: bool) -> () {
    debug a => _1;
    debug c => _2;
    let mut _0: ();
    let _3: std::option::Option<Ptr<'_>>;
    let mut _4: Ptr<'_>;
    let mut _5: &std::option::Option<Ptr<'_>>;
    let mut _6: isize;
    let _8: std::option::Option<Ptr<'_>>;
    scope 1 {
        debug foo => _3;
        scope 2 {
            debug bar => _5;
            debug _baz => _7;
            let _7: &Ptr<'_>;
        }
    }

    bb0: {
        switchInt(_2) -> [0: bb3, otherwise: bb1];
    }

    bb1: {
        _4 = Allocator::alloc(_1) -> bb2;
    }

    bb2: {
        _3 = Option::<Ptr<'_>>::Some(move _4);
        goto -> bb4;
    }

    bb3: {
        _3 = Option::<Ptr<'_>>::None;
        goto -> bb4;
    }

    bb4: {
        _5 = &_3;
        _6 = discriminant((*_5));
        switchInt(move _6) -> [1: bb5, otherwise: bb6];
    }

    bb5: {
        _7 = &(((*_5) as Some).0: Ptr<'_>);
        goto -> bb7;
    }

    bb6: {
        _8 = Option::<Ptr<'_>>::None;
        drop(_8) -> [return: bb7, unwind: bb9];
    }

    bb7: {
        drop(_3) -> bb8;
    }

    bb8: {
        return;
    }

    bb9 (cleanup): {
        drop(_3) -> [return: bb10, unwind terminate];
    }

    bb10 (cleanup): {
        resume;
    }
}

fn move_ref_pattern(_1: &Allocator) -> () {
    debug a => _1;
    let mut _0: ();
    let mut _2: (Ptr<'_>, Ptr<'_>, Ptr<'_>, Ptr<'_>);
    let mut _3: Ptr<'_>;
    let mut _4: Ptr<'_>;
    let mut _5: Ptr<'_>;
    let mut _6: Ptr<'_>;
    scope 1 {
        debug tup => _2;
        let _7: &Ptr<'_>;
        let _8: &mut Ptr<'_>;
        let _9: Ptr<'_>;
        let mut _10: Ptr<'_>;
        scope 2 {
            debug _a => _7;
            debug _b => _8;
            debug _c => _9;
            debug _d => _10;
        }
    }

    bb0: {
        _3 = Allocator::alloc(_1) -> bb1;
    }

    bb1: {
        _4 = Allocator::alloc(_1) -> [return: bb2, unwind: bb10];
    }

    bb2: {
        _5 = Allocator::alloc(_1) -> [return: bb3, unwind: bb9];
    }

    bb3: {
        _6 = Allocator::alloc(_1) -> [return: bb4, unwind: bb8];
    }

    bb4: {
        _2 = (move _3, move _4, move _5, move _6);
        _7 = &(_2.0: Ptr<'_>);
        _8 = &mut (_2.1: Ptr<'_>);
        _9 = move (_2.2: Ptr<'_>);
        _10 = move (_2.3: Ptr<'_>);
        drop(_10) -> [return: bb5, unwind: bb7];
    }

    bb5: {
        drop(_9) -> [return: bb6, unwind: bb16];
    }

    bb6: {
        drop((_2.0: Ptr<'_>)) -> [return: bb14, unwind: bb12];
    }

    bb7 (cleanup): {
        drop(_9) -> [return: bb16, unwind terminate];
    }

    bb8 (cleanup): {
        drop(_5) -> [return: bb9, unwind terminate];
    }

    bb9 (cleanup): {
        drop(_4) -> [return: bb10, unwind terminate];
    }

    bb10 (cleanup): {
        drop(_3) -> [return: bb11, unwind terminate];
    }

    bb11 (cleanup): {
        resume;
    }

    bb12 (cleanup): {
        drop((_2.1: Ptr<'_>)) -> [return: bb11, unwind terminate];
    }

    bb13: {
        return;
    }

    bb14: {
        drop((_2.1: Ptr<'_>)) -> bb13;
    }

    bb15 (cleanup): {
        drop((_2.1: Ptr<'_>)) -> [return: bb11, unwind terminate];
    }

    bb16 (cleanup): {
        drop((_2.0: Ptr<'_>)) -> [return: bb15, unwind terminate];
    }
}

fn panic_after_return(_1: &Allocator) -> Ptr<'_> {
    debug a => _1;
    let mut _0: Ptr<'_>;
    let _2: std::vec::Vec<usize>;
    let mut _3: std::boxed::Box<[usize]>;
    let mut _4: usize;
    let mut _5: usize;
    let mut _6: *mut u8;
    let mut _7: std::boxed::Box<[usize; 2]>;
    let _8: Ptr<'_>;
    let _10: Ptr<'_>;
    let mut _12: std::vec::Vec<usize>;
    let mut _13: bool;
    let mut _14: *const [usize; 2];
    let mut _15: *const ();
    let mut _16: usize;
    let mut _17: usize;
    let mut _18: usize;
    let mut _19: usize;
    let mut _20: bool;
    scope 1 {
        debug exceptions => _2;
        let _9: Ptr<'_>;
        scope 3 {
            debug p => _9;
            let _11: Ptr<'_>;
            scope 4 {
                debug p => _11;
            }
        }
    }
    scope 2 {
    }

    bb0: {
        _13 = const false;
        _4 = SizeOf([usize; 2]);
        _5 = AlignOf([usize; 2]);
        _6 = alloc::alloc::exchange_malloc(move _4, move _5) -> bb1;
    }

    bb1: {
        _7 = ShallowInitBox(move _6, [usize; 2]);
        _14 = (((_7.0: std::ptr::Unique<[usize; 2]>).0: std::ptr::NonNull<[usize; 2]>).0: *const [usize; 2]);
        _15 = _14 as *const () (PtrToPtr);
        _16 = _15 as usize (Transmute);
        _17 = AlignOf(usize);
        _18 = Sub(_17, const 1_usize);
        _19 = BitAnd(_16, _18);
        _20 = Eq(_19, const 0_usize);
        assert(_20, "misaligned pointer dereference: address must be a multiple of {} but is {}", _17, _16) -> [success: bb17, unwind unreachable];
    }

    bb2: {
        _13 = const true;
        _8 = Allocator::alloc(_1) -> [return: bb3, unwind: bb16];
    }

    bb3: {
        drop(_8) -> [return: bb4, unwind: bb16];
    }

    bb4: {
        _9 = Allocator::alloc(_1) -> [return: bb5, unwind: bb16];
    }

    bb5: {
        _10 = Allocator::alloc(_1) -> [return: bb6, unwind: bb13];
    }

    bb6: {
        drop(_10) -> [return: bb7, unwind: bb13];
    }

    bb7: {
        _11 = Allocator::alloc(_1) -> [return: bb8, unwind: bb13];
    }

    bb8: {
        _13 = const false;
        _12 = move _2;
        _0 = Allocator::alloc_leaked(_1, move _12) -> [return: bb9, unwind: bb12];
    }

    bb9: {
        drop(_11) -> [return: bb10, unwind: bb13];
    }

    bb10: {
        drop(_9) -> [return: bb11, unwind: bb16];
    }

    bb11: {
        _13 = const false;
        return;
    }

    bb12 (cleanup): {
        drop(_11) -> [return: bb13, unwind terminate];
    }

    bb13 (cleanup): {
        drop(_9) -> [return: bb16, unwind terminate];
    }

    bb14 (cleanup): {
        resume;
    }

    bb15 (cleanup): {
        drop(_2) -> [return: bb14, unwind terminate];
    }

    bb16 (cleanup): {
        switchInt(_13) -> [0: bb14, otherwise: bb15];
    }

    bb17: {
        (*_14) = [const 8_usize, const 9_usize];
        _3 = move _7 as std::boxed::Box<[usize]> (Pointer(Unsize));
        _2 = slice::<impl [usize]>::into_vec::<std::alloc::Global>(move _3) -> bb2;
    }
}

fn panic_after_return_expr(_1: &Allocator) -> Ptr<'_> {
    debug a => _1;
    let mut _0: Ptr<'_>;
    let _2: std::vec::Vec<usize>;
    let mut _3: std::boxed::Box<[usize]>;
    let mut _4: usize;
    let mut _5: usize;
    let mut _6: *mut u8;
    let mut _7: std::boxed::Box<[usize; 2]>;
    let _8: Ptr<'_>;
    let _10: Ptr<'_>;
    let mut _12: std::vec::Vec<usize>;
    let mut _13: bool;
    let mut _14: *const [usize; 2];
    let mut _15: *const ();
    let mut _16: usize;
    let mut _17: usize;
    let mut _18: usize;
    let mut _19: usize;
    let mut _20: bool;
    scope 1 {
        debug exceptions => _2;
        let _9: Ptr<'_>;
        scope 3 {
            debug p => _9;
            let _11: Ptr<'_>;
            scope 4 {
                debug q => _11;
            }
        }
    }
    scope 2 {
    }

    bb0: {
        _13 = const false;
        _4 = SizeOf([usize; 2]);
        _5 = AlignOf([usize; 2]);
        _6 = alloc::alloc::exchange_malloc(move _4, move _5) -> bb1;
    }

    bb1: {
        _7 = ShallowInitBox(move _6, [usize; 2]);
        _14 = (((_7.0: std::ptr::Unique<[usize; 2]>).0: std::ptr::NonNull<[usize; 2]>).0: *const [usize; 2]);
        _15 = _14 as *const () (PtrToPtr);
        _16 = _15 as usize (Transmute);
        _17 = AlignOf(usize);
        _18 = Sub(_17, const 1_usize);
        _19 = BitAnd(_16, _18);
        _20 = Eq(_19, const 0_usize);
        assert(_20, "misaligned pointer dereference: address must be a multiple of {} but is {}", _17, _16) -> [success: bb17, unwind unreachable];
    }

    bb2: {
        _13 = const true;
        _8 = Allocator::alloc(_1) -> [return: bb3, unwind: bb16];
    }

    bb3: {
        drop(_8) -> [return: bb4, unwind: bb16];
    }

    bb4: {
        _9 = Allocator::alloc(_1) -> [return: bb5, unwind: bb16];
    }

    bb5: {
        _10 = Allocator::alloc(_1) -> [return: bb6, unwind: bb13];
    }

    bb6: {
        drop(_10) -> [return: bb7, unwind: bb13];
    }

    bb7: {
        _11 = Allocator::alloc(_1) -> [return: bb8, unwind: bb13];
    }

    bb8: {
        _13 = const false;
        _12 = move _2;
        _0 = Allocator::alloc_leaked(_1, move _12) -> [return: bb9, unwind: bb12];
    }

    bb9: {
        drop(_11) -> [return: bb10, unwind: bb13];
    }

    bb10: {
        drop(_9) -> [return: bb11, unwind: bb16];
    }

    bb11: {
        _13 = const false;
        return;
    }

    bb12 (cleanup): {
        drop(_11) -> [return: bb13, unwind terminate];
    }

    bb13 (cleanup): {
        drop(_9) -> [return: bb16, unwind terminate];
    }

    bb14 (cleanup): {
        resume;
    }

    bb15 (cleanup): {
        drop(_2) -> [return: bb14, unwind terminate];
    }

    bb16 (cleanup): {
        switchInt(_13) -> [0: bb14, otherwise: bb15];
    }

    bb17: {
        (*_14) = [const 8_usize, const 9_usize];
        _3 = move _7 as std::boxed::Box<[usize]> (Pointer(Unsize));
        _2 = slice::<impl [usize]>::into_vec::<std::alloc::Global>(move _3) -> bb2;
    }
}

fn panic_after_init(_1: &Allocator) -> () {
    debug a => _1;
    let mut _0: ();
    let _2: std::vec::Vec<usize>;
    let mut _3: std::boxed::Box<[usize]>;
    let mut _4: usize;
    let mut _5: usize;
    let mut _6: *mut u8;
    let mut _7: std::boxed::Box<[usize; 1]>;
    let _8: Ptr<'_>;
    let _11: Ptr<'_>;
    let mut _13: std::vec::Vec<usize>;
    let mut _14: bool;
    let mut _15: *const [usize; 1];
    let mut _16: *const ();
    let mut _17: usize;
    let mut _18: usize;
    let mut _19: usize;
    let mut _20: usize;
    let mut _21: bool;
    scope 1 {
        debug exceptions => _2;
        let _9: Ptr<'_>;
        scope 3 {
            debug p => _9;
            let _10: Ptr<'_>;
            let _12: Ptr<'_>;
            scope 4 {
                debug q => _10;
            }
            scope 5 {
                debug r => _12;
            }
        }
    }
    scope 2 {
    }

    bb0: {
        _14 = const false;
        _4 = SizeOf([usize; 1]);
        _5 = AlignOf([usize; 1]);
        _6 = alloc::alloc::exchange_malloc(move _4, move _5) -> bb1;
    }

    bb1: {
        _7 = ShallowInitBox(move _6, [usize; 1]);
        _15 = (((_7.0: std::ptr::Unique<[usize; 1]>).0: std::ptr::NonNull<[usize; 1]>).0: *const [usize; 1]);
        _16 = _15 as *const () (PtrToPtr);
        _17 = _16 as usize (Transmute);
        _18 = AlignOf(usize);
        _19 = Sub(_18, const 1_usize);
        _20 = BitAnd(_17, _19);
        _21 = Eq(_20, const 0_usize);
        assert(_21, "misaligned pointer dereference: address must be a multiple of {} but is {}", _18, _17) -> [success: bb18, unwind unreachable];
    }

    bb2: {
        _14 = const true;
        _8 = Allocator::alloc(_1) -> [return: bb3, unwind: bb17];
    }

    bb3: {
        drop(_8) -> [return: bb4, unwind: bb17];
    }

    bb4: {
        _9 = Allocator::alloc(_1) -> [return: bb5, unwind: bb17];
    }

    bb5: {
        _11 = Allocator::alloc(_1) -> [return: bb6, unwind: bb14];
    }

    bb6: {
        drop(_11) -> [return: bb7, unwind: bb14];
    }

    bb7: {
        _12 = Allocator::alloc(_1) -> [return: bb8, unwind: bb14];
    }

    bb8: {
        _14 = const false;
        _13 = move _2;
        _10 = Allocator::alloc_leaked(_1, move _13) -> [return: bb9, unwind: bb13];
    }

    bb9: {
        drop(_12) -> [return: bb10, unwind: bb14];
    }

    bb10: {
        drop(_10) -> [return: bb11, unwind: bb14];
    }

    bb11: {
        drop(_9) -> [return: bb12, unwind: bb17];
    }

    bb12: {
        _14 = const false;
        return;
    }

    bb13 (cleanup): {
        drop(_12) -> [return: bb14, unwind terminate];
    }

    bb14 (cleanup): {
        drop(_9) -> [return: bb17, unwind terminate];
    }

    bb15 (cleanup): {
        resume;
    }

    bb16 (cleanup): {
        drop(_2) -> [return: bb15, unwind terminate];
    }

    bb17 (cleanup): {
        switchInt(_14) -> [0: bb15, otherwise: bb16];
    }

    bb18: {
        (*_15) = [const 8_usize];
        _3 = move _7 as std::boxed::Box<[usize]> (Pointer(Unsize));
        _2 = slice::<impl [usize]>::into_vec::<std::alloc::Global>(move _3) -> bb2;
    }
}

fn panic_after_init_temp(_1: &Allocator) -> () {
    debug a => _1;
    let mut _0: ();
    let _2: std::vec::Vec<usize>;
    let mut _3: std::boxed::Box<[usize]>;
    let mut _4: usize;
    let mut _5: usize;
    let mut _6: *mut u8;
    let mut _7: std::boxed::Box<[usize; 1]>;
    let _8: Ptr<'_>;
    let _10: Ptr<'_>;
    let _11: Ptr<'_>;
    let mut _13: std::vec::Vec<usize>;
    let mut _14: bool;
    let mut _15: *const [usize; 1];
    let mut _16: *const ();
    let mut _17: usize;
    let mut _18: usize;
    let mut _19: usize;
    let mut _20: usize;
    let mut _21: bool;
    scope 1 {
        debug exceptions => _2;
        let _9: Ptr<'_>;
        scope 3 {
            debug p => _9;
            let _12: Ptr<'_>;
            scope 4 {
                debug r => _12;
            }
        }
    }
    scope 2 {
    }

    bb0: {
        _14 = const false;
        _4 = SizeOf([usize; 1]);
        _5 = AlignOf([usize; 1]);
        _6 = alloc::alloc::exchange_malloc(move _4, move _5) -> bb1;
    }

    bb1: {
        _7 = ShallowInitBox(move _6, [usize; 1]);
        _15 = (((_7.0: std::ptr::Unique<[usize; 1]>).0: std::ptr::NonNull<[usize; 1]>).0: *const [usize; 1]);
        _16 = _15 as *const () (PtrToPtr);
        _17 = _16 as usize (Transmute);
        _18 = AlignOf(usize);
        _19 = Sub(_18, const 1_usize);
        _20 = BitAnd(_17, _19);
        _21 = Eq(_20, const 0_usize);
        assert(_21, "misaligned pointer dereference: address must be a multiple of {} but is {}", _18, _17) -> [success: bb18, unwind unreachable];
    }

    bb2: {
        _14 = const true;
        _8 = Allocator::alloc(_1) -> [return: bb3, unwind: bb17];
    }

    bb3: {
        drop(_8) -> [return: bb4, unwind: bb17];
    }

    bb4: {
        _9 = Allocator::alloc(_1) -> [return: bb5, unwind: bb17];
    }

    bb5: {
        _11 = Allocator::alloc(_1) -> [return: bb6, unwind: bb14];
    }

    bb6: {
        drop(_11) -> [return: bb7, unwind: bb14];
    }

    bb7: {
        _12 = Allocator::alloc(_1) -> [return: bb8, unwind: bb14];
    }

    bb8: {
        _14 = const false;
        _13 = move _2;
        _10 = Allocator::alloc_leaked(_1, move _13) -> [return: bb9, unwind: bb13];
    }

    bb9: {
        drop(_12) -> [return: bb10, unwind: bb14];
    }

    bb10: {
        drop(_10) -> [return: bb11, unwind: bb14];
    }

    bb11: {
        drop(_9) -> [return: bb12, unwind: bb17];
    }

    bb12: {
        _14 = const false;
        return;
    }

    bb13 (cleanup): {
        drop(_12) -> [return: bb14, unwind terminate];
    }

    bb14 (cleanup): {
        drop(_9) -> [return: bb17, unwind terminate];
    }

    bb15 (cleanup): {
        resume;
    }

    bb16 (cleanup): {
        drop(_2) -> [return: bb15, unwind terminate];
    }

    bb17 (cleanup): {
        switchInt(_14) -> [0: bb15, otherwise: bb16];
    }

    bb18: {
        (*_15) = [const 8_usize];
        _3 = move _7 as std::boxed::Box<[usize]> (Pointer(Unsize));
        _2 = slice::<impl [usize]>::into_vec::<std::alloc::Global>(move _3) -> bb2;
    }
}

fn panic_after_init_by_loop(_1: &Allocator) -> () {
    debug a => _1;
    let mut _0: ();
    let _2: std::vec::Vec<usize>;
    let mut _3: std::boxed::Box<[usize]>;
    let mut _4: usize;
    let mut _5: usize;
    let mut _6: *mut u8;
    let mut _7: std::boxed::Box<[usize; 1]>;
    let _8: Ptr<'_>;
    let _11: Ptr<'_>;
    let mut _13: std::vec::Vec<usize>;
    let mut _14: bool;
    let mut _15: *const [usize; 1];
    let mut _16: *const ();
    let mut _17: usize;
    let mut _18: usize;
    let mut _19: usize;
    let mut _20: usize;
    let mut _21: bool;
    scope 1 {
        debug exceptions => _2;
        let _9: Ptr<'_>;
        scope 3 {
            debug p => _9;
            let _10: Ptr<'_>;
            let _12: Ptr<'_>;
            scope 4 {
                debug q => _10;
            }
            scope 5 {
                debug r => _12;
            }
        }
    }
    scope 2 {
    }

    bb0: {
        _14 = const false;
        _4 = SizeOf([usize; 1]);
        _5 = AlignOf([usize; 1]);
        _6 = alloc::alloc::exchange_malloc(move _4, move _5) -> bb1;
    }

    bb1: {
        _7 = ShallowInitBox(move _6, [usize; 1]);
        _15 = (((_7.0: std::ptr::Unique<[usize; 1]>).0: std::ptr::NonNull<[usize; 1]>).0: *const [usize; 1]);
        _16 = _15 as *const () (PtrToPtr);
        _17 = _16 as usize (Transmute);
        _18 = AlignOf(usize);
        _19 = Sub(_18, const 1_usize);
        _20 = BitAnd(_17, _19);
        _21 = Eq(_20, const 0_usize);
        assert(_21, "misaligned pointer dereference: address must be a multiple of {} but is {}", _18, _17) -> [success: bb18, unwind unreachable];
    }

    bb2: {
        _14 = const true;
        _8 = Allocator::alloc(_1) -> [return: bb3, unwind: bb17];
    }

    bb3: {
        drop(_8) -> [return: bb4, unwind: bb17];
    }

    bb4: {
        _9 = Allocator::alloc(_1) -> [return: bb5, unwind: bb17];
    }

    bb5: {
        _11 = Allocator::alloc(_1) -> [return: bb6, unwind: bb14];
    }

    bb6: {
        drop(_11) -> [return: bb7, unwind: bb14];
    }

    bb7: {
        _12 = Allocator::alloc(_1) -> [return: bb8, unwind: bb14];
    }

    bb8: {
        _14 = const false;
        _13 = move _2;
        _10 = Allocator::alloc_leaked(_1, move _13) -> [return: bb9, unwind: bb13];
    }

    bb9: {
        drop(_12) -> [return: bb10, unwind: bb14];
    }

    bb10: {
        drop(_10) -> [return: bb11, unwind: bb14];
    }

    bb11: {
        drop(_9) -> [return: bb12, unwind: bb17];
    }

    bb12: {
        _14 = const false;
        return;
    }

    bb13 (cleanup): {
        drop(_12) -> [return: bb14, unwind terminate];
    }

    bb14 (cleanup): {
        drop(_9) -> [return: bb17, unwind terminate];
    }

    bb15 (cleanup): {
        resume;
    }

    bb16 (cleanup): {
        drop(_2) -> [return: bb15, unwind terminate];
    }

    bb17 (cleanup): {
        switchInt(_14) -> [0: bb15, otherwise: bb16];
    }

    bb18: {
        (*_15) = [const 8_usize];
        _3 = move _7 as std::boxed::Box<[usize]> (Pointer(Unsize));
        _2 = slice::<impl [usize]>::into_vec::<std::alloc::Global>(move _3) -> bb2;
    }
}

fn run_test(_1: F) -> () {
    debug f => _1;
    let mut _0: ();
    let _2: Allocator;
    let _3: ();
    let mut _4: &mut F;
    let mut _5: (&Allocator,);
    let _6: &Allocator;
    let mut _7: std::ops::Range<usize>;
    let mut _8: std::ops::Range<usize>;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: &std::cell::Cell<usize>;
    let mut _13: std::option::Option<usize>;
    let mut _14: &mut std::ops::Range<usize>;
    let mut _15: isize;
    let mut _20: &mut F;
    let mut _22: [closure@ui/drop/dynamic-drop.rs:411:42: 411:49];
    let mut _23: isize;
    let _24: !;
    let mut _25: std::fmt::Arguments<'_>;
    let mut _26: &[&str];
    let _27: &[&str; 2];
    let _28: [&str; 2];
    let mut _29: &[core::fmt::rt::Argument<'_>];
    let _30: &[core::fmt::rt::Argument<'_>; 2];
    let _31: [core::fmt::rt::Argument<'_>; 2];
    let mut _32: core::fmt::rt::Argument<'_>;
    let _33: &usize;
    let _34: usize;
    let mut _35: &std::cell::Cell<usize>;
    let mut _36: core::fmt::rt::Argument<'_>;
    let _37: &usize;
    let _38: usize;
    let mut _39: &std::cell::Cell<usize>;
    let mut _41: bool;
    let mut _42: &std::option::Option<&InjectedFailure>;
    let _43: std::option::Option<&InjectedFailure>;
    let mut _44: &dyn std::any::Any + std::marker::Send;
    let _45: !;
    let mut _46: std::boxed::Box<dyn std::any::Any + std::marker::Send>;
    let mut _47: bool;
    let mut _48: *const dyn std::any::Any + std::marker::Send;
    scope 1 {
        debug first_alloc => _2;
        let mut _12: std::ops::Range<usize>;
        scope 2 {
            debug iter => _12;
            let _16: usize;
            scope 3 {
                debug failing_op => _16;
                let _17: Allocator;
                scope 4 {
                    debug alloc => _17;
                    let _18: &Allocator;
                    scope 5 {
                        debug alloc => _18;
                        let _19: std::panic::AssertUnwindSafe<&mut F>;
                        scope 6 {
                            debug f => _19;
                            let _21: std::result::Result<(), std::boxed::Box<dyn std::any::Any + std::marker::Send>>;
                            scope 7 {
                                debug result => _21;
                                let _40: std::boxed::Box<dyn std::any::Any + std::marker::Send>;
                                scope 8 {
                                    debug e => _40;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _47 = const false;
        _2 = Allocator::new(const _) -> [return: bb1, unwind: bb28];
    }

    bb1: {
        _4 = &mut _1;
        _6 = &_2;
        _5 = (_6,);
        _3 = <F as FnMut<(&Allocator,)>>::call_mut(move _4, move _5) -> [return: bb2, unwind: bb27];
    }

    bb2: {
        _11 = &(_2.2: std::cell::Cell<usize>);
        _10 = Cell::<usize>::get(move _11) -> [return: bb3, unwind: bb27];
    }

    bb3: {
        _9 = Add(move _10, const 1_usize);
        _8 = std::ops::Range::<usize> { start: const 1_usize, end: move _9 };
        _7 = <std::ops::Range<usize> as IntoIterator>::into_iter(move _8) -> [return: bb4, unwind: bb27];
    }

    bb4: {
        _12 = move _7;
        goto -> bb5;
    }

    bb5: {
        _14 = &mut _12;
        _13 = <std::ops::Range<usize> as Iterator>::next(_14) -> [return: bb6, unwind: bb27];
    }

    bb6: {
        _15 = discriminant(_13);
        switchInt(move _15) -> [0: bb9, 1: bb7, otherwise: bb8];
    }

    bb7: {
        _16 = ((_13 as Some).0: usize);
        _17 = Allocator::new(_16) -> [return: bb10, unwind: bb27];
    }

    bb8: {
        unreachable;
    }

    bb9: {
        drop(_2) -> [return: bb24, unwind: bb28];
    }

    bb10: {
        _18 = &_17;
        _20 = &mut _1;
        _19 = AssertUnwindSafe::<&mut F>(move _20);
        _22 = [closure@ui/drop/dynamic-drop.rs:411:42: 411:49] { f: move _19, alloc: _18 };
        _21 = catch_unwind::<[closure@ui/drop/dynamic-drop.rs:411:42: 411:49], ()>(move _22) -> [return: bb11, unwind: bb26];
    }

    bb11: {
        _23 = discriminant(_21);
        switchInt(move _23) -> [0: bb13, 1: bb12, otherwise: bb8];
    }

    bb12: {
        _47 = const true;
        _40 = move ((_21 as Err).0: std::boxed::Box<dyn std::any::Any + std::marker::Send>);
        _48 = (((_40.0: std::ptr::Unique<dyn std::any::Any + std::marker::Send>).0: std::ptr::NonNull<dyn std::any::Any + std::marker::Send>).0: *const dyn std::any::Any + std::marker::Send);
        _44 = &(*_48);
        _43 = <(dyn Any + Send + 'static)>::downcast_ref::<InjectedFailure>(move _44) -> [return: bb19, unwind: bb31];
    }

    bb13: {
        _28 = [const "test executed ", const " ops but now "];
        _27 = &_28;
        _26 = _27 as &[&str] (Pointer(Unsize));
        _35 = &(_2.2: std::cell::Cell<usize>);
        _34 = Cell::<usize>::get(move _35) -> [return: bb14, unwind: bb26];
    }

    bb14: {
        _33 = &_34;
        _32 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_33) -> [return: bb15, unwind: bb26];
    }

    bb15: {
        _39 = &((*_18).2: std::cell::Cell<usize>);
        _38 = Cell::<usize>::get(move _39) -> [return: bb16, unwind: bb26];
    }

    bb16: {
        _37 = &_38;
        _36 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_37) -> [return: bb17, unwind: bb26];
    }

    bb17: {
        _31 = [move _32, move _36];
        _30 = &_31;
        _29 = _30 as &[core::fmt::rt::Argument<'_>] (Pointer(Unsize));
        _25 = Arguments::<'_>::new_v1(move _26, move _29) -> [return: bb18, unwind: bb26];
    }

    bb18: {
        _24 = panic_fmt(move _25) -> bb26;
    }

    bb19: {
        _42 = &_43;
        _41 = Option::<&InjectedFailure>::is_none(move _42) -> [return: bb20, unwind: bb31];
    }

    bb20: {
        switchInt(move _41) -> [0: bb22, otherwise: bb21];
    }

    bb21: {
        _47 = const false;
        _46 = move _40;
        _45 = resume_unwind(move _46) -> bb31;
    }

    bb22: {
        drop(_40) -> [return: bb23, unwind: bb26];
    }

    bb23: {
        _47 = const false;
        drop(_17) -> [return: bb5, unwind: bb27];
    }

    bb24: {
        drop(_1) -> bb25;
    }

    bb25: {
        return;
    }

    bb26 (cleanup): {
        drop(_17) -> [return: bb27, unwind terminate];
    }

    bb27 (cleanup): {
        drop(_2) -> [return: bb28, unwind terminate];
    }

    bb28 (cleanup): {
        drop(_1) -> [return: bb29, unwind terminate];
    }

    bb29 (cleanup): {
        resume;
    }

    bb30 (cleanup): {
        drop(_40) -> [return: bb26, unwind terminate];
    }

    bb31 (cleanup): {
        switchInt(_47) -> [0: bb26, otherwise: bb30];
    }
}

fn run_test::{closure#0}(_1: [closure@ui/drop/dynamic-drop.rs:411:42: 411:49]) -> () {
    debug f => (_1.0: std::panic::AssertUnwindSafe<&mut F>);
    debug alloc => (_1.1: &Allocator);
    let mut _0: ();
    let _2: ();
    let mut _3: (&Allocator,);
    let mut _4: &mut F;
    let mut _5: &Allocator;

    bb0: {
        _4 = deref_copy ((_1.0: std::panic::AssertUnwindSafe<&mut F>).0: &mut F);
        _5 = deref_copy (_1.1: &Allocator);
        _3 = (_5,);
        _2 = <F as FnMut<(&Allocator,)>>::call_mut(_4, move _3) -> bb1;
    }

    bb1: {
        return;
    }
}

fn run_test_nopanic(_1: F) -> () {
    debug f => _1;
    let mut _0: ();
    let _2: Allocator;
    let _3: ();
    let mut _4: &mut F;
    let mut _5: (&Allocator,);
    let _6: &Allocator;
    scope 1 {
        debug first_alloc => _2;
    }

    bb0: {
        _2 = Allocator::new(const _) -> [return: bb1, unwind: bb6];
    }

    bb1: {
        _4 = &mut _1;
        _6 = &_2;
        _5 = (_6,);
        _3 = <F as FnMut<(&Allocator,)>>::call_mut(move _4, move _5) -> [return: bb2, unwind: bb5];
    }

    bb2: {
        drop(_2) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        drop(_1) -> bb4;
    }

    bb4: {
        return;
    }

    bb5 (cleanup): {
        drop(_2) -> [return: bb6, unwind terminate];
    }

    bb6 (cleanup): {
        drop(_1) -> [return: bb7, unwind terminate];
    }

    bb7 (cleanup): {
        resume;
    }
}

fn main() -> () {
    let mut _0: ();
    let _1: ();
    let _2: ();
    let _3: ();
    let _4: ();
    let _5: ();
    let _6: ();
    let _7: ();
    let _8: ();
    let _9: ();
    let _10: ();
    let _11: ();
    let _12: ();
    let _13: ();
    let _14: ();
    let _15: ();
    let _16: ();
    let _17: ();
    let _18: ();
    let _19: ();
    let _20: ();
    let _21: ();
    let _22: ();
    let _23: ();
    let _24: ();
    let _25: ();
    let _26: ();
    let _27: ();
    let _28: ();
    let _29: ();
    let _30: ();
    let _31: ();
    let _32: ();
    let _33: ();
    let _34: ();
    let _35: ();
    let _36: ();
    let _37: ();
    let _38: ();
    let _39: ();
    let _40: ();
    let _41: ();
    let _42: ();
    let _43: ();
    let _44: ();
    let _45: ();
    let _46: ();
    let _47: ();
    let _48: ();
    let _49: ();
    let _50: ();
    let _51: ();
    let _52: ();
    let _53: ();
    let _54: ();
    let _55: ();
    let _56: ();
    let _57: ();
    let _58: ();
    let _59: ();
    let _60: ();
    let _61: ();
    let _62: ();
    let _63: ();
    let _64: ();
    let _65: ();
    let _66: ();
    let _67: ();
    let _68: ();

    bb0: {
        _1 = run_test::<[closure@ui/drop/dynamic-drop.rs:434:14: 434:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:434:14: 434:17]) -> bb1;
    }

    bb1: {
        _2 = run_test::<[closure@ui/drop/dynamic-drop.rs:435:14: 435:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:435:14: 435:17]) -> bb2;
    }

    bb2: {
        _3 = run_test::<[closure@ui/drop/dynamic-drop.rs:436:14: 436:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:436:14: 436:17]) -> bb3;
    }

    bb3: {
        _4 = run_test::<[closure@ui/drop/dynamic-drop.rs:437:14: 437:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:437:14: 437:17]) -> bb4;
    }

    bb4: {
        _5 = run_test::<[closure@ui/drop/dynamic-drop.rs:439:14: 439:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:439:14: 439:17]) -> bb5;
    }

    bb5: {
        _6 = run_test::<[closure@ui/drop/dynamic-drop.rs:440:14: 440:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:440:14: 440:17]) -> bb6;
    }

    bb6: {
        _7 = run_test::<[closure@ui/drop/dynamic-drop.rs:441:14: 441:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:441:14: 441:17]) -> bb7;
    }

    bb7: {
        _8 = run_test::<[closure@ui/drop/dynamic-drop.rs:442:14: 442:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:442:14: 442:17]) -> bb8;
    }

    bb8: {
        _9 = run_test::<[closure@ui/drop/dynamic-drop.rs:444:14: 444:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:444:14: 444:17]) -> bb9;
    }

    bb9: {
        _10 = run_test::<[closure@ui/drop/dynamic-drop.rs:445:14: 445:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:445:14: 445:17]) -> bb10;
    }

    bb10: {
        _11 = run_test::<[closure@ui/drop/dynamic-drop.rs:447:14: 447:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:447:14: 447:17]) -> bb11;
    }

    bb11: {
        _12 = run_test::<[closure@ui/drop/dynamic-drop.rs:448:14: 448:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:448:14: 448:17]) -> bb12;
    }

    bb12: {
        _13 = run_test::<[closure@ui/drop/dynamic-drop.rs:449:14: 449:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:449:14: 449:17]) -> bb13;
    }

    bb13: {
        _14 = run_test::<[closure@ui/drop/dynamic-drop.rs:451:14: 451:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:451:14: 451:17]) -> bb14;
    }

    bb14: {
        _15 = run_test::<[closure@ui/drop/dynamic-drop.rs:452:14: 452:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:452:14: 452:17]) -> bb15;
    }

    bb15: {
        _16 = run_test::<[closure@ui/drop/dynamic-drop.rs:453:14: 453:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:453:14: 453:17]) -> bb16;
    }

    bb16: {
        _17 = run_test::<[closure@ui/drop/dynamic-drop.rs:454:14: 454:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:454:14: 454:17]) -> bb17;
    }

    bb17: {
        _18 = run_test::<[closure@ui/drop/dynamic-drop.rs:455:14: 455:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:455:14: 455:17]) -> bb18;
    }

    bb18: {
        _19 = run_test::<[closure@ui/drop/dynamic-drop.rs:456:14: 456:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:456:14: 456:17]) -> bb19;
    }

    bb19: {
        _20 = run_test::<[closure@ui/drop/dynamic-drop.rs:457:14: 457:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:457:14: 457:17]) -> bb20;
    }

    bb20: {
        _21 = run_test::<[closure@ui/drop/dynamic-drop.rs:458:14: 458:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:458:14: 458:17]) -> bb21;
    }

    bb21: {
        _22 = run_test::<[closure@ui/drop/dynamic-drop.rs:460:14: 460:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:460:14: 460:17]) -> bb22;
    }

    bb22: {
        _23 = run_test::<[closure@ui/drop/dynamic-drop.rs:461:14: 461:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:461:14: 461:17]) -> bb23;
    }

    bb23: {
        _24 = run_test::<[closure@ui/drop/dynamic-drop.rs:463:14: 463:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:463:14: 463:17]) -> bb24;
    }

    bb24: {
        _25 = run_test::<[closure@ui/drop/dynamic-drop.rs:464:14: 464:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:464:14: 464:17]) -> bb25;
    }

    bb25: {
        _26 = run_test::<[closure@ui/drop/dynamic-drop.rs:465:14: 465:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:465:14: 465:17]) -> bb26;
    }

    bb26: {
        _27 = run_test::<[closure@ui/drop/dynamic-drop.rs:466:14: 466:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:466:14: 466:17]) -> bb27;
    }

    bb27: {
        _28 = run_test::<[closure@ui/drop/dynamic-drop.rs:468:14: 468:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:468:14: 468:17]) -> bb28;
    }

    bb28: {
        _29 = run_test::<[closure@ui/drop/dynamic-drop.rs:470:14: 470:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:470:14: 470:17]) -> bb29;
    }

    bb29: {
        _30 = run_test::<[closure@ui/drop/dynamic-drop.rs:471:14: 471:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:471:14: 471:17]) -> bb30;
    }

    bb30: {
        _31 = run_test::<[closure@ui/drop/dynamic-drop.rs:472:14: 472:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:472:14: 472:17]) -> bb31;
    }

    bb31: {
        _32 = run_test::<[closure@ui/drop/dynamic-drop.rs:473:14: 473:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:473:14: 473:17]) -> bb32;
    }

    bb32: {
        _33 = run_test::<[closure@ui/drop/dynamic-drop.rs:474:14: 474:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:474:14: 474:17]) -> bb33;
    }

    bb33: {
        _34 = run_test::<[closure@ui/drop/dynamic-drop.rs:475:14: 475:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:475:14: 475:17]) -> bb34;
    }

    bb34: {
        _35 = run_test::<[closure@ui/drop/dynamic-drop.rs:476:14: 476:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:476:14: 476:17]) -> bb35;
    }

    bb35: {
        _36 = run_test::<[closure@ui/drop/dynamic-drop.rs:477:14: 477:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:477:14: 477:17]) -> bb36;
    }

    bb36: {
        _37 = run_test::<[closure@ui/drop/dynamic-drop.rs:479:14: 479:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:479:14: 479:17]) -> bb37;
    }

    bb37: {
        _38 = run_test::<[closure@ui/drop/dynamic-drop.rs:480:14: 480:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:480:14: 480:17]) -> bb38;
    }

    bb38: {
        _39 = run_test::<[closure@ui/drop/dynamic-drop.rs:481:14: 481:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:481:14: 481:17]) -> bb39;
    }

    bb39: {
        _40 = run_test::<[closure@ui/drop/dynamic-drop.rs:482:14: 482:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:482:14: 482:17]) -> bb40;
    }

    bb40: {
        _41 = run_test::<[closure@ui/drop/dynamic-drop.rs:483:14: 483:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:483:14: 483:17]) -> bb41;
    }

    bb41: {
        _42 = run_test::<[closure@ui/drop/dynamic-drop.rs:484:14: 484:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:484:14: 484:17]) -> bb42;
    }

    bb42: {
        _43 = run_test::<[closure@ui/drop/dynamic-drop.rs:485:14: 485:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:485:14: 485:17]) -> bb43;
    }

    bb43: {
        _44 = run_test::<[closure@ui/drop/dynamic-drop.rs:486:14: 486:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:486:14: 486:17]) -> bb44;
    }

    bb44: {
        _45 = run_test::<[closure@ui/drop/dynamic-drop.rs:488:14: 488:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:488:14: 488:17]) -> bb45;
    }

    bb45: {
        _46 = run_test::<[closure@ui/drop/dynamic-drop.rs:489:14: 489:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:489:14: 489:17]) -> bb46;
    }

    bb46: {
        _47 = run_test::<[closure@ui/drop/dynamic-drop.rs:490:14: 490:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:490:14: 490:17]) -> bb47;
    }

    bb47: {
        _48 = run_test::<[closure@ui/drop/dynamic-drop.rs:491:14: 491:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:491:14: 491:17]) -> bb48;
    }

    bb48: {
        _49 = run_test::<[closure@ui/drop/dynamic-drop.rs:492:14: 492:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:492:14: 492:17]) -> bb49;
    }

    bb49: {
        _50 = run_test::<[closure@ui/drop/dynamic-drop.rs:493:14: 493:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:493:14: 493:17]) -> bb50;
    }

    bb50: {
        _51 = run_test::<[closure@ui/drop/dynamic-drop.rs:494:14: 494:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:494:14: 494:17]) -> bb51;
    }

    bb51: {
        _52 = run_test::<[closure@ui/drop/dynamic-drop.rs:495:14: 495:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:495:14: 495:17]) -> bb52;
    }

    bb52: {
        _53 = run_test::<[closure@ui/drop/dynamic-drop.rs:496:14: 496:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:496:14: 496:17]) -> bb53;
    }

    bb53: {
        _54 = run_test::<[closure@ui/drop/dynamic-drop.rs:498:14: 498:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:498:14: 498:17]) -> bb54;
    }

    bb54: {
        _55 = run_test::<[closure@ui/drop/dynamic-drop.rs:500:14: 500:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:500:14: 500:17]) -> bb55;
    }

    bb55: {
        _56 = run_test::<[closure@ui/drop/dynamic-drop.rs:503:14: 503:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:503:14: 503:17]) -> bb56;
    }

    bb56: {
        _57 = run_test::<[closure@ui/drop/dynamic-drop.rs:506:14: 506:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:506:14: 506:17]) -> bb57;
    }

    bb57: {
        _58 = run_test::<[closure@ui/drop/dynamic-drop.rs:507:14: 507:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:507:14: 507:17]) -> bb58;
    }

    bb58: {
        _59 = run_test::<[closure@ui/drop/dynamic-drop.rs:508:14: 508:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:508:14: 508:17]) -> bb59;
    }

    bb59: {
        _60 = run_test::<[closure@ui/drop/dynamic-drop.rs:510:14: 510:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:510:14: 510:17]) -> bb60;
    }

    bb60: {
        _61 = run_test::<[closure@ui/drop/dynamic-drop.rs:511:14: 511:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:511:14: 511:17]) -> bb61;
    }

    bb61: {
        _62 = run_test::<[closure@ui/drop/dynamic-drop.rs:512:14: 512:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:512:14: 512:17]) -> bb62;
    }

    bb62: {
        _63 = run_test::<[closure@ui/drop/dynamic-drop.rs:513:14: 513:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:513:14: 513:17]) -> bb63;
    }

    bb63: {
        _64 = run_test::<[closure@ui/drop/dynamic-drop.rs:514:14: 514:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:514:14: 514:17]) -> bb64;
    }

    bb64: {
        _65 = run_test::<[closure@ui/drop/dynamic-drop.rs:515:14: 515:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:515:14: 515:17]) -> bb65;
    }

    bb65: {
        _66 = run_test::<[closure@ui/drop/dynamic-drop.rs:516:14: 516:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:516:14: 516:17]) -> bb66;
    }

    bb66: {
        _67 = run_test::<[closure@ui/drop/dynamic-drop.rs:517:14: 517:17]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:517:14: 517:17]) -> bb67;
    }

    bb67: {
        _68 = run_test_nopanic::<[closure@ui/drop/dynamic-drop.rs:519:22: 519:25]>(const ZeroSized: [closure@ui/drop/dynamic-drop.rs:519:22: 519:25]) -> bb68;
    }

    bb68: {
        return;
    }
}

fn main::{closure#0}(_1: &mut [closure@ui/drop/dynamic-drop.rs:434:14: 434:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = dynamic_init(_2, const false) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#1}(_1: &mut [closure@ui/drop/dynamic-drop.rs:435:14: 435:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = dynamic_init(_2, const true) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#2}(_1: &mut [closure@ui/drop/dynamic-drop.rs:436:14: 436:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = dynamic_drop(_2, const false) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#3}(_1: &mut [closure@ui/drop/dynamic-drop.rs:437:14: 437:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = dynamic_drop(_2, const true) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#4}(_1: &mut [closure@ui/drop/dynamic-drop.rs:439:14: 439:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = assignment2(_2, const false, const false) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#5}(_1: &mut [closure@ui/drop/dynamic-drop.rs:440:14: 440:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = assignment2(_2, const false, const true) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#6}(_1: &mut [closure@ui/drop/dynamic-drop.rs:441:14: 441:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = assignment2(_2, const true, const false) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#7}(_1: &mut [closure@ui/drop/dynamic-drop.rs:442:14: 442:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = assignment2(_2, const true, const true) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#8}(_1: &mut [closure@ui/drop/dynamic-drop.rs:444:14: 444:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = assignment1(_2, const false) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#9}(_1: &mut [closure@ui/drop/dynamic-drop.rs:445:14: 445:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = assignment1(_2, const true) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#10}(_1: &mut [closure@ui/drop/dynamic-drop.rs:447:14: 447:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = array_simple(_2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#11}(_1: &mut [closure@ui/drop/dynamic-drop.rs:448:14: 448:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = vec_simple(_2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#12}(_1: &mut [closure@ui/drop/dynamic-drop.rs:449:14: 449:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = vec_unreachable(_2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#13}(_1: &mut [closure@ui/drop/dynamic-drop.rs:451:14: 451:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = struct_dynamic_drop(_2, const false, const false, const false) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#14}(_1: &mut [closure@ui/drop/dynamic-drop.rs:452:14: 452:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = struct_dynamic_drop(_2, const false, const false, const true) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#15}(_1: &mut [closure@ui/drop/dynamic-drop.rs:453:14: 453:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = struct_dynamic_drop(_2, const false, const true, const false) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#16}(_1: &mut [closure@ui/drop/dynamic-drop.rs:454:14: 454:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = struct_dynamic_drop(_2, const false, const true, const true) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#17}(_1: &mut [closure@ui/drop/dynamic-drop.rs:455:14: 455:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = struct_dynamic_drop(_2, const true, const false, const false) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#18}(_1: &mut [closure@ui/drop/dynamic-drop.rs:456:14: 456:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = struct_dynamic_drop(_2, const true, const false, const true) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#19}(_1: &mut [closure@ui/drop/dynamic-drop.rs:457:14: 457:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = struct_dynamic_drop(_2, const true, const true, const false) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#20}(_1: &mut [closure@ui/drop/dynamic-drop.rs:458:14: 458:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = struct_dynamic_drop(_2, const true, const true, const true) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#21}(_1: &mut [closure@ui/drop/dynamic-drop.rs:460:14: 460:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = field_assignment(_2, const false) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#22}(_1: &mut [closure@ui/drop/dynamic-drop.rs:461:14: 461:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = field_assignment(_2, const true) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#23}(_1: &mut [closure@ui/drop/dynamic-drop.rs:463:14: 463:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = generator(_2, const 0_usize) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#24}(_1: &mut [closure@ui/drop/dynamic-drop.rs:464:14: 464:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = generator(_2, const 1_usize) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#25}(_1: &mut [closure@ui/drop/dynamic-drop.rs:465:14: 465:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = generator(_2, const 2_usize) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#26}(_1: &mut [closure@ui/drop/dynamic-drop.rs:466:14: 466:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = generator(_2, const 3_usize) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#27}(_1: &mut [closure@ui/drop/dynamic-drop.rs:468:14: 468:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = mixed_drop_and_nondrop(_2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#28}(_1: &mut [closure@ui/drop/dynamic-drop.rs:470:14: 470:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = slice_pattern_first(_2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#29}(_1: &mut [closure@ui/drop/dynamic-drop.rs:471:14: 471:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = slice_pattern_middle(_2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#30}(_1: &mut [closure@ui/drop/dynamic-drop.rs:472:14: 472:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = slice_pattern_two(_2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#31}(_1: &mut [closure@ui/drop/dynamic-drop.rs:473:14: 473:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = slice_pattern_last(_2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#32}(_1: &mut [closure@ui/drop/dynamic-drop.rs:474:14: 474:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = slice_pattern_one_of(_2, const 0_usize) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#33}(_1: &mut [closure@ui/drop/dynamic-drop.rs:475:14: 475:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = slice_pattern_one_of(_2, const 1_usize) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#34}(_1: &mut [closure@ui/drop/dynamic-drop.rs:476:14: 476:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = slice_pattern_one_of(_2, const 2_usize) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#35}(_1: &mut [closure@ui/drop/dynamic-drop.rs:477:14: 477:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = slice_pattern_one_of(_2, const 3_usize) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#36}(_1: &mut [closure@ui/drop/dynamic-drop.rs:479:14: 479:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = subslice_pattern_from_end(_2, const true) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#37}(_1: &mut [closure@ui/drop/dynamic-drop.rs:480:14: 480:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = subslice_pattern_from_end(_2, const false) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#38}(_1: &mut [closure@ui/drop/dynamic-drop.rs:481:14: 481:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = subslice_pattern_from_end_with_drop(_2, const true, const true) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#39}(_1: &mut [closure@ui/drop/dynamic-drop.rs:482:14: 482:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = subslice_pattern_from_end_with_drop(_2, const true, const false) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#40}(_1: &mut [closure@ui/drop/dynamic-drop.rs:483:14: 483:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = subslice_pattern_from_end_with_drop(_2, const false, const true) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#41}(_1: &mut [closure@ui/drop/dynamic-drop.rs:484:14: 484:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = subslice_pattern_from_end_with_drop(_2, const false, const false) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#42}(_1: &mut [closure@ui/drop/dynamic-drop.rs:485:14: 485:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = slice_pattern_reassign(_2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#43}(_1: &mut [closure@ui/drop/dynamic-drop.rs:486:14: 486:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = subslice_pattern_reassign(_2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#44}(_1: &mut [closure@ui/drop/dynamic-drop.rs:488:14: 488:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = index_field_mixed_ends(_2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#45}(_1: &mut [closure@ui/drop/dynamic-drop.rs:489:14: 489:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = subslice_mixed_min_lengths(_2, const 0_i32) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#46}(_1: &mut [closure@ui/drop/dynamic-drop.rs:490:14: 490:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = subslice_mixed_min_lengths(_2, const 1_i32) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#47}(_1: &mut [closure@ui/drop/dynamic-drop.rs:491:14: 491:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = subslice_mixed_min_lengths(_2, const 2_i32) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#48}(_1: &mut [closure@ui/drop/dynamic-drop.rs:492:14: 492:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = subslice_mixed_min_lengths(_2, const 3_i32) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#49}(_1: &mut [closure@ui/drop/dynamic-drop.rs:493:14: 493:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = subslice_mixed_min_lengths(_2, const 4_i32) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#50}(_1: &mut [closure@ui/drop/dynamic-drop.rs:494:14: 494:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = subslice_mixed_min_lengths(_2, const 5_i32) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#51}(_1: &mut [closure@ui/drop/dynamic-drop.rs:495:14: 495:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = subslice_mixed_min_lengths(_2, const 6_i32) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#52}(_1: &mut [closure@ui/drop/dynamic-drop.rs:496:14: 496:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = subslice_mixed_min_lengths(_2, const 7_i32) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#53}(_1: &mut [closure@ui/drop/dynamic-drop.rs:498:14: 498:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = move_ref_pattern(_2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#54}(_1: &mut [closure@ui/drop/dynamic-drop.rs:500:14: 500:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();
    let _3: Ptr<'_>;

    bb0: {
        _3 = panic_after_return(_2) -> bb1;
    }

    bb1: {
        drop(_3) -> bb2;
    }

    bb2: {
        return;
    }
}

fn main::{closure#55}(_1: &mut [closure@ui/drop/dynamic-drop.rs:503:14: 503:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();
    let _3: Ptr<'_>;

    bb0: {
        _3 = panic_after_return_expr(_2) -> bb1;
    }

    bb1: {
        drop(_3) -> bb2;
    }

    bb2: {
        return;
    }
}

fn main::{closure#56}(_1: &mut [closure@ui/drop/dynamic-drop.rs:506:14: 506:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = panic_after_init(_2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#57}(_1: &mut [closure@ui/drop/dynamic-drop.rs:507:14: 507:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = panic_after_init_temp(_2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#58}(_1: &mut [closure@ui/drop/dynamic-drop.rs:508:14: 508:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = panic_after_init_by_loop(_2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#59}(_1: &mut [closure@ui/drop/dynamic-drop.rs:510:14: 510:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = bindings_after_at_dynamic_init_move(_2, const true) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#60}(_1: &mut [closure@ui/drop/dynamic-drop.rs:511:14: 511:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = bindings_after_at_dynamic_init_move(_2, const false) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#61}(_1: &mut [closure@ui/drop/dynamic-drop.rs:512:14: 512:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = bindings_after_at_dynamic_init_ref(_2, const true) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#62}(_1: &mut [closure@ui/drop/dynamic-drop.rs:513:14: 513:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = bindings_after_at_dynamic_init_ref(_2, const false) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#63}(_1: &mut [closure@ui/drop/dynamic-drop.rs:514:14: 514:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = bindings_after_at_dynamic_drop_move(_2, const true) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#64}(_1: &mut [closure@ui/drop/dynamic-drop.rs:515:14: 515:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = bindings_after_at_dynamic_drop_move(_2, const false) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#65}(_1: &mut [closure@ui/drop/dynamic-drop.rs:516:14: 516:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = bindings_after_at_dynamic_drop_ref(_2, const true) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#66}(_1: &mut [closure@ui/drop/dynamic-drop.rs:517:14: 517:17], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = bindings_after_at_dynamic_drop_ref(_2, const false) -> bb1;
    }

    bb1: {
        return;
    }
}

fn main::{closure#67}(_1: &mut [closure@ui/drop/dynamic-drop.rs:519:22: 519:25], _2: &Allocator) -> () {
    debug a => _2;
    let mut _0: ();

    bb0: {
        _0 = union1(_2) -> bb1;
    }

    bb1: {
        return;
    }
}

fn Ptr(_1: usize, _2: &Allocator) -> Ptr<'_> {
    let mut _0: Ptr<'_>;

    bb0: {
        _0 = Ptr::<'_>(move _1, move _2);
        return;
    }
}

// MIR FOR CTFE
fn Ptr(_1: usize, _2: &Allocator) -> Ptr<'_> {
    let mut _0: Ptr<'_>;

    bb0: {
        _0 = Ptr::<'_>(move _1, move _2);
        return;
    }
}

fn TwoPtrs(_1: Ptr<'_>, _2: Ptr<'_>) -> TwoPtrs<'_> {
    let mut _0: TwoPtrs<'_>;

    bb0: {
        _0 = TwoPtrs::<'_>(move _1, move _2);
        return;
    }
}

// MIR FOR CTFE
fn TwoPtrs(_1: Ptr<'_>, _2: Ptr<'_>) -> TwoPtrs<'_> {
    let mut _0: TwoPtrs<'_>;

    bb0: {
        _0 = TwoPtrs::<'_>(move _1, move _2);
        return;
    }
}
