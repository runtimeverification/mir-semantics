// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn main() -> () {
    let mut _0: ();
    let mut _1: i32;
    let mut _2: i32;
    let mut _5: [i32; 2];
    let mut _6: (&(i32, i32), &(i32, i32));
    let mut _7: &(i32, i32);
    let _8: (i32, i32);
    let mut _9: i32;
    let mut _10: i32;
    let mut _11: &(i32, i32);
    let _12: (i32, i32);
    let mut _15: bool;
    let mut _16: bool;
    let _18: !;
    let mut _19: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _24: [i32; 5];
    let mut _25: (&(i32, i32, i32), &(i32, i32, i32));
    let mut _26: &(i32, i32, i32);
    let _27: (i32, i32, i32);
    let mut _28: i32;
    let mut _29: i32;
    let mut _30: i32;
    let mut _31: &(i32, i32, i32);
    let _32: (i32, i32, i32);
    let mut _35: bool;
    let mut _36: bool;
    let _38: !;
    let mut _39: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _41: [i32; 3];
    let mut _42: (&(i32, i32), &(i32, i32));
    let mut _43: &(i32, i32);
    let _44: (i32, i32);
    let mut _45: i32;
    let mut _46: i32;
    let mut _47: &(i32, i32);
    let _48: (i32, i32);
    let mut _51: bool;
    let mut _52: bool;
    let _54: !;
    let mut _55: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _57: [i32; 3];
    let mut _58: (&i32, &i32);
    let mut _59: &i32;
    let mut _60: &i32;
    let _61: i32;
    let mut _64: bool;
    let mut _65: bool;
    let mut _66: i32;
    let mut _67: i32;
    let _69: !;
    let mut _70: std::option::Option<std::fmt::Arguments<'_>>;
    scope 1 {
        debug a => _1;
        debug b => _2;
        let _3: i32;
        let _4: i32;
        let _13: &(i32, i32);
        let _14: &(i32, i32);
        let mut _20: i32;
        scope 2 {
            debug lhs => _3;
            debug lhs => _4;
        }
        scope 3 {
            debug left_val => _13;
            debug right_val => _14;
            let _17: core::panicking::AssertKind;
            scope 4 {
                debug kind => _17;
            }
        }
        scope 5 {
            debug c => _20;
            let _21: i32;
            let _22: i32;
            let _23: i32;
            let _33: &(i32, i32, i32);
            let _34: &(i32, i32, i32);
            let _40: i32;
            let _49: &(i32, i32);
            let _50: &(i32, i32);
            let _56: i32;
            let _62: &i32;
            let _63: &i32;
            scope 6 {
                debug lhs => _21;
                debug lhs => _22;
                debug lhs => _23;
            }
            scope 7 {
                debug left_val => _33;
                debug right_val => _34;
                let _37: core::panicking::AssertKind;
                scope 8 {
                    debug kind => _37;
                }
            }
            scope 9 {
                debug lhs => _40;
            }
            scope 10 {
                debug left_val => _49;
                debug right_val => _50;
                let _53: core::panicking::AssertKind;
                scope 11 {
                    debug kind => _53;
                }
            }
            scope 12 {
            }
            scope 13 {
                debug lhs => _56;
            }
            scope 14 {
                debug left_val => _62;
                debug right_val => _63;
                let _68: core::panicking::AssertKind;
                scope 15 {
                    debug kind => _68;
                }
            }
        }
    }

    bb0: {
        _5 = [const 0_i32, const 1_i32];
        _3 = _5[0 of 2];
        _4 = _5[1 of 2];
        _1 = _3;
        _2 = _4;
        _9 = _1;
        _10 = _2;
        _8 = (move _9, move _10);
        _7 = &_8;
        _12 = (const 0_i32, const 1_i32);
        _11 = &_12;
        _6 = (move _7, move _11);
        _13 = (_6.0: &(i32, i32));
        _14 = (_6.1: &(i32, i32));
        _16 = <(i32, i32) as PartialEq>::eq(_13, _14) -> bb1;
    }

    bb1: {
        _15 = Not(move _16);
        switchInt(move _15) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _17 = core::panicking::AssertKind::Eq;
        _19 = Option::<Arguments<'_>>::None;
        _18 = core::panicking::assert_failed::<(i32, i32), (i32, i32)>(move _17, _13, _14, move _19);
    }

    bb3: {
        _24 = [const 1_i32, const 2_i32, const 3_i32, const 4_i32, const 5_i32];
        _21 = _24[0 of 5];
        _23 = _24[4 of 5];
        _22 = _24[3 of 5];
        _1 = _21;
        _2 = _22;
        _20 = _23;
        _28 = _1;
        _29 = _2;
        _30 = _20;
        _27 = (move _28, move _29, move _30);
        _26 = &_27;
        _32 = (const 1_i32, const 4_i32, const 5_i32);
        _31 = &_32;
        _25 = (move _26, move _31);
        _33 = (_25.0: &(i32, i32, i32));
        _34 = (_25.1: &(i32, i32, i32));
        _36 = <(i32, i32, i32) as PartialEq>::eq(_33, _34) -> bb4;
    }

    bb4: {
        _35 = Not(move _36);
        switchInt(move _35) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _37 = core::panicking::AssertKind::Eq;
        _39 = Option::<Arguments<'_>>::None;
        _38 = core::panicking::assert_failed::<(i32, i32, i32), (i32, i32, i32)>(move _37, _33, _34, move _39);
    }

    bb6: {
        _41 = [const 1_i32, const 2_i32, const 3_i32];
        _40 = _41[1 of 3];
        _1 = _40;
        _45 = _1;
        _46 = _2;
        _44 = (move _45, move _46);
        _43 = &_44;
        _48 = (const 2_i32, const 4_i32);
        _47 = &_48;
        _42 = (move _43, move _47);
        _49 = (_42.0: &(i32, i32));
        _50 = (_42.1: &(i32, i32));
        _52 = <(i32, i32) as PartialEq>::eq(_49, _50) -> bb7;
    }

    bb7: {
        _51 = Not(move _52);
        switchInt(move _51) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _53 = core::panicking::AssertKind::Eq;
        _55 = Option::<Arguments<'_>>::None;
        _54 = core::panicking::assert_failed::<(i32, i32), (i32, i32)>(move _53, _49, _50, move _55);
    }

    bb9: {
        _57 = [const 5_i32, const 6_i32, const 6_i32];
        _56 = _57[0 of 3];
        _20 = _56;
        _59 = &_20;
        _61 = const 5_i32;
        _60 = &_61;
        _58 = (move _59, move _60);
        _62 = (_58.0: &i32);
        _63 = (_58.1: &i32);
        _66 = (*_62);
        _67 = (*_63);
        _65 = Eq(move _66, move _67);
        _64 = Not(move _65);
        switchInt(move _64) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _68 = core::panicking::AssertKind::Eq;
        _70 = Option::<Arguments<'_>>::None;
        _69 = core::panicking::assert_failed::<i32, i32>(move _68, _62, _63, move _70);
    }

    bb11: {
        return;
    }
}
