// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn <impl at ui/overloaded/overloaded-index-autoderef.rs:13:1: 13:26>::index(_1: &Foo, _2: isize) -> &isize {
    debug self => _1;
    debug z => _2;
    let mut _0: &isize;
    let _3: &isize;
    let _4: &isize;

    bb0: {
        switchInt(move _2) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _3 = &((*_1).0: isize);
        _0 = _3;
        goto -> bb3;
    }

    bb2: {
        _4 = &((*_1).1: isize);
        _0 = _4;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

fn <impl at ui/overloaded/overloaded-index-autoderef.rs:25:1: 25:29>::index_mut(_1: &mut Foo, _2: isize) -> &mut isize {
    debug self => _1;
    debug z => _2;
    let mut _0: &mut isize;
    let mut _3: &mut isize;
    let mut _4: &mut isize;
    let mut _5: &mut isize;

    bb0: {
        switchInt(move _2) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _4 = &mut ((*_1).0: isize);
        _3 = _4;
        goto -> bb3;
    }

    bb2: {
        _5 = &mut ((*_1).1: isize);
        _3 = _5;
        goto -> bb3;
    }

    bb3: {
        _0 = _3;
        return;
    }
}

fn <impl at ui/overloaded/overloaded-index-autoderef.rs:41:1: 41:19>::get(_1: isize) -> isize {
    debug self => _1;
    let mut _0: isize;

    bb0: {
        _0 = _1;
        return;
    }
}

fn <impl at ui/overloaded/overloaded-index-autoderef.rs:41:1: 41:19>::get_from_ref(_1: &isize) -> isize {
    debug self => _1;
    let mut _0: isize;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn <impl at ui/overloaded/overloaded-index-autoderef.rs:41:1: 41:19>::inc(_1: &mut isize) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        (*_1) = Add((*_1), const 1_isize);
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let mut _1: std::boxed::Box<Foo>;
    let mut _2: Foo;
    let mut _3: (&isize, &isize);
    let mut _4: &isize;
    let _5: &isize;
    let mut _6: &Foo;
    let mut _7: &isize;
    let _8: isize;
    let mut _11: bool;
    let mut _12: bool;
    let mut _13: isize;
    let mut _14: isize;
    let _16: !;
    let mut _17: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _18: &mut isize;
    let mut _19: &mut Foo;
    let mut _20: (&isize, &isize);
    let mut _21: &isize;
    let _22: &isize;
    let mut _23: &Foo;
    let mut _24: &isize;
    let _25: isize;
    let mut _28: bool;
    let mut _29: bool;
    let mut _30: isize;
    let mut _31: isize;
    let _33: !;
    let mut _34: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _36: &mut isize;
    let mut _37: &mut Foo;
    let _39: &isize;
    let mut _40: &Foo;
    let mut _41: (&isize, &isize);
    let mut _42: &isize;
    let _43: isize;
    let mut _46: bool;
    let mut _47: bool;
    let mut _48: isize;
    let mut _49: isize;
    let _51: !;
    let mut _52: std::option::Option<std::fmt::Arguments<'_>>;
    let _53: ();
    let mut _54: &mut isize;
    let mut _55: &mut isize;
    let mut _56: &mut Foo;
    let mut _57: (&isize, &isize);
    let mut _58: &isize;
    let _59: isize;
    let mut _60: isize;
    let mut _61: &isize;
    let mut _62: &Foo;
    let mut _63: &isize;
    let _64: isize;
    let mut _67: bool;
    let mut _68: bool;
    let mut _69: isize;
    let mut _70: isize;
    let _72: !;
    let mut _73: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _74: (&isize, &isize);
    let mut _75: &isize;
    let _76: isize;
    let mut _77: &isize;
    let _78: &isize;
    let mut _79: &Foo;
    let mut _80: &isize;
    let _81: isize;
    let mut _84: bool;
    let mut _85: bool;
    let mut _86: isize;
    let mut _87: isize;
    let _89: !;
    let mut _90: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _91: *const Foo;
    let mut _92: *const Foo;
    let mut _93: *const Foo;
    let mut _94: *const Foo;
    let mut _95: *const Foo;
    let mut _96: *const Foo;
    let mut _97: *const Foo;
    let mut _98: *const Foo;
    scope 1 {
        debug f => _1;
        let _9: &isize;
        let _10: &isize;
        let _26: &isize;
        let _27: &isize;
        let _35: &mut isize;
        let _38: &isize;
        let _65: &isize;
        let _66: &isize;
        let _82: &isize;
        let _83: &isize;
        let mut _99: *const ();
        let mut _100: usize;
        let mut _101: usize;
        let mut _102: usize;
        let mut _103: usize;
        let mut _104: bool;
        let mut _105: *const ();
        let mut _106: usize;
        let mut _107: usize;
        let mut _108: usize;
        let mut _109: usize;
        let mut _110: bool;
        let mut _111: *const ();
        let mut _112: usize;
        let mut _113: usize;
        let mut _114: usize;
        let mut _115: usize;
        let mut _116: bool;
        let mut _117: *const ();
        let mut _118: usize;
        let mut _119: usize;
        let mut _120: usize;
        let mut _121: usize;
        let mut _122: bool;
        let mut _123: *const ();
        let mut _124: usize;
        let mut _125: usize;
        let mut _126: usize;
        let mut _127: usize;
        let mut _128: bool;
        let mut _129: *const ();
        let mut _130: usize;
        let mut _131: usize;
        let mut _132: usize;
        let mut _133: usize;
        let mut _134: bool;
        let mut _135: *const ();
        let mut _136: usize;
        let mut _137: usize;
        let mut _138: usize;
        let mut _139: usize;
        let mut _140: bool;
        let mut _141: *const ();
        let mut _142: usize;
        let mut _143: usize;
        let mut _144: usize;
        let mut _145: usize;
        let mut _146: bool;
        scope 2 {
            debug left_val => _9;
            debug right_val => _10;
            let _15: core::panicking::AssertKind;
            scope 3 {
                debug kind => _15;
            }
        }
        scope 4 {
            debug left_val => _26;
            debug right_val => _27;
            let _32: core::panicking::AssertKind;
            scope 5 {
                debug kind => _32;
            }
        }
        scope 6 {
            debug p => _35;
        }
        scope 7 {
            debug p => _38;
            let _44: &isize;
            let _45: &isize;
            scope 8 {
                debug left_val => _44;
                debug right_val => _45;
                let _50: core::panicking::AssertKind;
                scope 9 {
                    debug kind => _50;
                }
            }
        }
        scope 10 {
            debug left_val => _65;
            debug right_val => _66;
            let _71: core::panicking::AssertKind;
            scope 11 {
                debug kind => _71;
            }
        }
        scope 12 {
            debug left_val => _82;
            debug right_val => _83;
            let _88: core::panicking::AssertKind;
            scope 13 {
                debug kind => _88;
            }
        }
    }

    bb0: {
        _2 = Foo { x: const 1_isize, y: const 2_isize };
        _1 = Box::<Foo>::new(move _2) -> bb1;
    }

    bb1: {
        _91 = (((_1.0: std::ptr::Unique<Foo>).0: std::ptr::NonNull<Foo>).0: *const Foo);
        _141 = _91 as *const () (PtrToPtr);
        _142 = _141 as usize (Transmute);
        _143 = AlignOf(Foo);
        _144 = Sub(_143, const 1_usize);
        _145 = BitAnd(_142, _144);
        _146 = Eq(_145, const 0_usize);
        assert(_146, "misaligned pointer dereference: address must be a multiple of {} but is {}", _143, _142) -> [success: bb33, unwind unreachable];
    }

    bb2: {
        _4 = _5;
        _8 = const 2_isize;
        _7 = &_8;
        _3 = (move _4, move _7);
        _9 = (_3.0: &isize);
        _10 = (_3.1: &isize);
        _13 = (*_9);
        _14 = (*_10);
        _12 = Eq(move _13, move _14);
        _11 = Not(move _12);
        switchInt(move _11) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _15 = core::panicking::AssertKind::Eq;
        _17 = Option::<Arguments<'_>>::None;
        _16 = core::panicking::assert_failed::<isize, isize>(move _15, _9, _10, move _17) -> bb24;
    }

    bb4: {
        _92 = (((_1.0: std::ptr::Unique<Foo>).0: std::ptr::NonNull<Foo>).0: *const Foo);
        _135 = _92 as *const () (PtrToPtr);
        _136 = _135 as usize (Transmute);
        _137 = AlignOf(Foo);
        _138 = Sub(_137, const 1_usize);
        _139 = BitAnd(_136, _138);
        _140 = Eq(_139, const 0_usize);
        assert(_140, "misaligned pointer dereference: address must be a multiple of {} but is {}", _137, _136) -> [success: bb32, unwind unreachable];
    }

    bb5: {
        (*_18) = const 3_isize;
        _93 = (((_1.0: std::ptr::Unique<Foo>).0: std::ptr::NonNull<Foo>).0: *const Foo);
        _129 = _93 as *const () (PtrToPtr);
        _130 = _129 as usize (Transmute);
        _131 = AlignOf(Foo);
        _132 = Sub(_131, const 1_usize);
        _133 = BitAnd(_130, _132);
        _134 = Eq(_133, const 0_usize);
        assert(_134, "misaligned pointer dereference: address must be a multiple of {} but is {}", _131, _130) -> [success: bb31, unwind unreachable];
    }

    bb6: {
        _21 = _22;
        _25 = const 3_isize;
        _24 = &_25;
        _20 = (move _21, move _24);
        _26 = (_20.0: &isize);
        _27 = (_20.1: &isize);
        _30 = (*_26);
        _31 = (*_27);
        _29 = Eq(move _30, move _31);
        _28 = Not(move _29);
        switchInt(move _28) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _32 = core::panicking::AssertKind::Eq;
        _34 = Option::<Arguments<'_>>::None;
        _33 = core::panicking::assert_failed::<isize, isize>(move _32, _26, _27, move _34) -> bb24;
    }

    bb8: {
        _94 = (((_1.0: std::ptr::Unique<Foo>).0: std::ptr::NonNull<Foo>).0: *const Foo);
        _123 = _94 as *const () (PtrToPtr);
        _124 = _123 as usize (Transmute);
        _125 = AlignOf(Foo);
        _126 = Sub(_125, const 1_usize);
        _127 = BitAnd(_124, _126);
        _128 = Eq(_127, const 0_usize);
        assert(_128, "misaligned pointer dereference: address must be a multiple of {} but is {}", _125, _124) -> [success: bb30, unwind unreachable];
    }

    bb9: {
        _35 = _36;
        (*_35) = const 4_isize;
        _95 = (((_1.0: std::ptr::Unique<Foo>).0: std::ptr::NonNull<Foo>).0: *const Foo);
        _117 = _95 as *const () (PtrToPtr);
        _118 = _117 as usize (Transmute);
        _119 = AlignOf(Foo);
        _120 = Sub(_119, const 1_usize);
        _121 = BitAnd(_118, _120);
        _122 = Eq(_121, const 0_usize);
        assert(_122, "misaligned pointer dereference: address must be a multiple of {} but is {}", _119, _118) -> [success: bb29, unwind unreachable];
    }

    bb10: {
        _38 = _39;
        _43 = const 4_isize;
        _42 = &_43;
        _41 = (_38, move _42);
        _44 = (_41.0: &isize);
        _45 = (_41.1: &isize);
        _48 = (*_44);
        _49 = (*_45);
        _47 = Eq(move _48, move _49);
        _46 = Not(move _47);
        switchInt(move _46) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _50 = core::panicking::AssertKind::Eq;
        _52 = Option::<Arguments<'_>>::None;
        _51 = core::panicking::assert_failed::<isize, isize>(move _50, _44, _45, move _52) -> bb24;
    }

    bb12: {
        _96 = (((_1.0: std::ptr::Unique<Foo>).0: std::ptr::NonNull<Foo>).0: *const Foo);
        _111 = _96 as *const () (PtrToPtr);
        _112 = _111 as usize (Transmute);
        _113 = AlignOf(Foo);
        _114 = Sub(_113, const 1_usize);
        _115 = BitAnd(_112, _114);
        _116 = Eq(_115, const 0_usize);
        assert(_116, "misaligned pointer dereference: address must be a multiple of {} but is {}", _113, _112) -> [success: bb28, unwind unreachable];
    }

    bb13: {
        _54 = _55;
        _53 = <isize as Int>::inc(move _54) -> [return: bb14, unwind: bb24];
    }

    bb14: {
        _97 = (((_1.0: std::ptr::Unique<Foo>).0: std::ptr::NonNull<Foo>).0: *const Foo);
        _105 = _97 as *const () (PtrToPtr);
        _106 = _105 as usize (Transmute);
        _107 = AlignOf(Foo);
        _108 = Sub(_107, const 1_usize);
        _109 = BitAnd(_106, _108);
        _110 = Eq(_109, const 0_usize);
        assert(_110, "misaligned pointer dereference: address must be a multiple of {} but is {}", _107, _106) -> [success: bb27, unwind unreachable];
    }

    bb15: {
        _60 = (*_61);
        _59 = <isize as Int>::get(move _60) -> [return: bb16, unwind: bb24];
    }

    bb16: {
        _58 = &_59;
        _64 = const 5_isize;
        _63 = &_64;
        _57 = (move _58, move _63);
        _65 = (_57.0: &isize);
        _66 = (_57.1: &isize);
        _69 = (*_65);
        _70 = (*_66);
        _68 = Eq(move _69, move _70);
        _67 = Not(move _68);
        switchInt(move _67) -> [0: bb18, otherwise: bb17];
    }

    bb17: {
        _71 = core::panicking::AssertKind::Eq;
        _73 = Option::<Arguments<'_>>::None;
        _72 = core::panicking::assert_failed::<isize, isize>(move _71, _65, _66, move _73) -> bb24;
    }

    bb18: {
        _98 = (((_1.0: std::ptr::Unique<Foo>).0: std::ptr::NonNull<Foo>).0: *const Foo);
        _99 = _98 as *const () (PtrToPtr);
        _100 = _99 as usize (Transmute);
        _101 = AlignOf(Foo);
        _102 = Sub(_101, const 1_usize);
        _103 = BitAnd(_100, _102);
        _104 = Eq(_103, const 0_usize);
        assert(_104, "misaligned pointer dereference: address must be a multiple of {} but is {}", _101, _100) -> [success: bb26, unwind unreachable];
    }

    bb19: {
        _77 = _78;
        _76 = <isize as Int>::get_from_ref(move _77) -> [return: bb20, unwind: bb24];
    }

    bb20: {
        _75 = &_76;
        _81 = const 5_isize;
        _80 = &_81;
        _74 = (move _75, move _80);
        _82 = (_74.0: &isize);
        _83 = (_74.1: &isize);
        _86 = (*_82);
        _87 = (*_83);
        _85 = Eq(move _86, move _87);
        _84 = Not(move _85);
        switchInt(move _84) -> [0: bb22, otherwise: bb21];
    }

    bb21: {
        _88 = core::panicking::AssertKind::Eq;
        _90 = Option::<Arguments<'_>>::None;
        _89 = core::panicking::assert_failed::<isize, isize>(move _88, _82, _83, move _90) -> bb24;
    }

    bb22: {
        drop(_1) -> bb23;
    }

    bb23: {
        return;
    }

    bb24 (cleanup): {
        drop(_1) -> [return: bb25, unwind terminate];
    }

    bb25 (cleanup): {
        resume;
    }

    bb26: {
        _79 = &(*_98);
        _78 = <Foo as Index<isize>>::index(move _79, const 1_isize) -> [return: bb19, unwind: bb24];
    }

    bb27: {
        _62 = &(*_97);
        _61 = <Foo as Index<isize>>::index(move _62, const 1_isize) -> [return: bb15, unwind: bb24];
    }

    bb28: {
        _56 = &mut (*_96);
        _55 = <Foo as IndexMut<isize>>::index_mut(move _56, const 1_isize) -> [return: bb13, unwind: bb24];
    }

    bb29: {
        _40 = &(*_95);
        _39 = <Foo as Index<isize>>::index(move _40, const 1_isize) -> [return: bb10, unwind: bb24];
    }

    bb30: {
        _37 = &mut (*_94);
        _36 = <Foo as IndexMut<isize>>::index_mut(move _37, const 1_isize) -> [return: bb9, unwind: bb24];
    }

    bb31: {
        _23 = &(*_93);
        _22 = <Foo as Index<isize>>::index(move _23, const 0_isize) -> [return: bb6, unwind: bb24];
    }

    bb32: {
        _19 = &mut (*_92);
        _18 = <Foo as IndexMut<isize>>::index_mut(move _19, const 0_isize) -> [return: bb5, unwind: bb24];
    }

    bb33: {
        _6 = &(*_91);
        _5 = <Foo as Index<isize>>::index(move _6, const 1_isize) -> [return: bb2, unwind: bb24];
    }
}
