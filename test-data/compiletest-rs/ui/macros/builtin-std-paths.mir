// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn <impl at ui/macros/builtin-std-paths.rs:4:5: 4:23>::clone(_1: &Core) -> Core {
    debug self => _1;
    let mut _0: Core;

    bb0: {
        return;
    }
}

fn <impl at ui/macros/builtin-std-paths.rs:6:5: 6:21>::fmt(_1: &Core, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "Core";
        _0 = Formatter::<'_>::write_str(_2, _3) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/macros/builtin-std-paths.rs:7:5: 7:27>::default() -> Core {
    let mut _0: Core;

    bb0: {
        return;
    }
}

fn <impl at ui/macros/builtin-std-paths.rs:8:5: 8:18>::assert_receiver_is_total_eq(_1: &Core) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn <impl at ui/macros/builtin-std-paths.rs:9:5: 9:21>::hash(_1: &Core, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn <impl at ui/macros/builtin-std-paths.rs:10:5: 10:19>::cmp(_1: &Core, _2: &Core) -> std::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: std::cmp::Ordering;

    bb0: {
        _0 = Equal;
        return;
    }
}

fn <impl at ui/macros/builtin-std-paths.rs:11:5: 11:25>::eq(_1: &Core, _2: &Core) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;

    bb0: {
        _0 = const true;
        return;
    }
}

fn <impl at ui/macros/builtin-std-paths.rs:12:5: 12:26>::partial_cmp(_1: &Core, _2: &Core) -> Option<std::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: std::option::Option<std::cmp::Ordering>;
    let mut _3: std::cmp::Ordering;

    bb0: {
        _3 = Equal;
        _0 = Option::<std::cmp::Ordering>::Some(move _3);
        return;
    }
}

fn <impl at ui/macros/builtin-std-paths.rs:17:5: 17:22>::clone(_1: &Std) -> Std {
    debug self => _1;
    let mut _0: Std;

    bb0: {
        return;
    }
}

fn <impl at ui/macros/builtin-std-paths.rs:19:5: 19:20>::fmt(_1: &Std, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "Std";
        _0 = Formatter::<'_>::write_str(_2, _3) -> bb1;
    }

    bb1: {
        return;
    }
}

fn <impl at ui/macros/builtin-std-paths.rs:20:5: 20:26>::default() -> Std {
    let mut _0: Std;

    bb0: {
        return;
    }
}

fn <impl at ui/macros/builtin-std-paths.rs:21:5: 21:17>::assert_receiver_is_total_eq(_1: &Std) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn <impl at ui/macros/builtin-std-paths.rs:22:5: 22:20>::hash(_1: &Std, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn <impl at ui/macros/builtin-std-paths.rs:23:5: 23:18>::cmp(_1: &Std, _2: &Std) -> std::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: std::cmp::Ordering;

    bb0: {
        _0 = Equal;
        return;
    }
}

fn <impl at ui/macros/builtin-std-paths.rs:24:5: 24:24>::eq(_1: &Std, _2: &Std) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;

    bb0: {
        _0 = const true;
        return;
    }
}

fn <impl at ui/macros/builtin-std-paths.rs:25:5: 25:25>::partial_cmp(_1: &Std, _2: &Std) -> Option<std::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: std::option::Option<std::cmp::Ordering>;
    let mut _3: std::cmp::Ordering;

    bb0: {
        _3 = Equal;
        _0 = Option::<std::cmp::Ordering>::Some(move _3);
        return;
    }
}

fn main() -> () {
    let mut _0: ();

    bb0: {
        return;
    }
}
