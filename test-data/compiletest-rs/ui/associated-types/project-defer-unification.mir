// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
Luma::data::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

fn <impl at ui/associated-types/project-defer-unification.rs:11:16: 11:21>::clone(_1: &Luma<T>) -> Luma<T> {
    debug self => _1;
    let mut _0: Luma<T>;
    let mut _2: [T; 1];
    let _3: &[T; 1];

    bb0: {
        _3 = &((*_1).0: [T; 1]);
        _2 = <[T; 1] as Clone>::clone(_3) -> bb1;
    }

    bb1: {
        _0 = Luma::<T> { data: move _2 };
        return;
    }
}

fn <impl at ui/associated-types/project-defer-unification.rs:44:1: 44:45>::pixels(_1: &ImageBuffer<P, Container>) -> Pixels<'_, ImageBuffer<P, Container>> {
    debug self => _1;
    let mut _0: Pixels<'_, ImageBuffer<P, Container>>;

    bb0: {
        goto -> bb1;
    }

    bb1: {
        goto -> bb1;
    }
}

fn <impl at ui/associated-types/project-defer-unification.rs:44:1: 44:45>::pixels_mut(_1: &mut ImageBuffer<P, Container>) -> PixelsMut<'_, P> {
    debug self => _1;
    let mut _0: PixelsMut<'_, P>;

    bb0: {
        goto -> bb1;
    }

    bb1: {
        goto -> bb1;
    }
}

fn <impl at ui/associated-types/project-defer-unification.rs:66:1: 66:53>::next(_1: &mut Pixels<'_, I>) -> Option<(u32, u32, <I as GenericImage>::Pixel)> {
    debug self => _1;
    let mut _0: std::option::Option<(u32, u32, <I as GenericImage>::Pixel)>;

    bb0: {
        goto -> bb1;
    }

    bb1: {
        goto -> bb1;
    }
}

fn <impl at ui/associated-types/project-defer-unification.rs:78:1: 78:54>::next(_1: &mut PixelsMut<'_, P>) -> Option<&mut P> {
    debug self => _1;
    let mut _0: std::option::Option<&mut P>;

    bb0: {
        goto -> bb1;
    }

    bb1: {
        goto -> bb1;
    }
}

fn index_colors(_1: &ImageBuffer<Pix, Vec<u8>>) -> ImageBuffer<Luma<u8>, Vec<u8>> {
    debug image => _1;
    let mut _0: ImageBuffer<Luma<u8>, std::vec::Vec<u8>>;
    let mut _2: ImageBuffer<Luma<u8>, std::vec::Vec<u8>>;
    scope 1 {
        debug indices => _2;
        let mut _3: std::iter::Zip<Pixels<'_, ImageBuffer<Pix, std::vec::Vec<u8>>>, PixelsMut<'_, Luma<u8>>>;
        scope 2 {
            debug iter => _3;
            let _4: (u32, u32, Pix);
            let _5: &mut Luma<u8>;
            scope 3 {
                debug pixel => _4;
                debug idx => _5;
            }
        }
    }

    bb0: {
        goto -> bb1;
    }

    bb1: {
        goto -> bb1;
    }
}

fn main() -> () {
    let mut _0: ();

    bb0: {
        return;
    }
}
