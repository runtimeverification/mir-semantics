// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn main() -> () {
    let mut _0: ();
    let mut _1: std::ops::Range<i32>;
    let mut _2: std::ops::Range<i32>;
    let mut _3: std::ops::Range<i32>;
    let mut _4: std::option::Option<i32>;
    let mut _5: &mut std::ops::Range<i32>;
    let mut _6: isize;
    let mut _8: (&u8, &u8);
    let mut _9: &u8;
    let _10: u8;
    let mut _11: u8;
    let mut _12: &u8;
    let _13: u8;
    let mut _16: bool;
    let mut _17: bool;
    let mut _18: u8;
    let mut _19: u8;
    let _21: !;
    let mut _22: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _23: (&u16, &u16);
    let mut _24: &u16;
    let _25: u16;
    let mut _26: u16;
    let mut _27: u16;
    let mut _28: &u16;
    let _29: u16;
    let _30: &u16;
    let _31: &u16;
    let mut _32: bool;
    let mut _33: bool;
    let mut _34: u16;
    let mut _35: u16;
    let _37: !;
    let mut _38: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _39: (&u32, &u32);
    let mut _40: &u32;
    let _41: u32;
    let mut _42: u32;
    let mut _43: u32;
    let mut _44: &u32;
    let _45: u32;
    let _46: &u32;
    let _47: &u32;
    let mut _48: bool;
    let mut _49: bool;
    let mut _50: u32;
    let mut _51: u32;
    let _53: !;
    let mut _54: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _55: (&u64, &u64);
    let mut _56: &u64;
    let _57: u64;
    let mut _58: u64;
    let mut _59: u64;
    let mut _60: &u64;
    let _61: u64;
    let _62: &u64;
    let _63: &u64;
    let mut _64: bool;
    let mut _65: bool;
    let mut _66: u64;
    let mut _67: u64;
    let _69: !;
    let mut _70: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _71: (&u128, &u128);
    let mut _72: &u128;
    let _73: u128;
    let mut _74: u128;
    let mut _75: u128;
    let mut _76: &u128;
    let _77: u128;
    let _78: &u128;
    let _79: &u128;
    let mut _80: bool;
    let mut _81: bool;
    let mut _82: u128;
    let mut _83: u128;
    let _85: !;
    let mut _86: std::option::Option<std::fmt::Arguments<'_>>;
    scope 1 {
        debug iter => _3;
        let _7: i32;
        scope 2 {
            debug i => _7;
            let _14: &u8;
            let _15: &u8;
            scope 3 {
                debug left_val => _14;
                debug right_val => _15;
                let _20: core::panicking::AssertKind;
                scope 4 {
                    debug kind => _20;
                }
            }
        }
    }
    scope 5 {
        debug left_val => _30;
        debug right_val => _31;
        let _36: core::panicking::AssertKind;
        scope 6 {
            debug kind => _36;
        }
    }
    scope 7 {
        debug left_val => _46;
        debug right_val => _47;
        let _52: core::panicking::AssertKind;
        scope 8 {
            debug kind => _52;
        }
    }
    scope 9 {
        debug left_val => _62;
        debug right_val => _63;
        let _68: core::panicking::AssertKind;
        scope 10 {
            debug kind => _68;
        }
    }
    scope 11 {
        debug left_val => _78;
        debug right_val => _79;
        let _84: core::panicking::AssertKind;
        scope 12 {
            debug kind => _84;
        }
    }

    bb0: {
        _2 = std::ops::Range::<i32> { start: const 129_i32, end: const 256_i32 };
        _1 = <std::ops::Range<i32> as IntoIterator>::into_iter(move _2) -> bb1;
    }

    bb1: {
        _3 = move _1;
        goto -> bb2;
    }

    bb2: {
        _5 = &mut _3;
        _4 = <std::ops::Range<i32> as Iterator>::next(_5) -> bb3;
    }

    bb3: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [0: bb6, 1: bb4, otherwise: bb5];
    }

    bb4: {
        _7 = ((_4 as Some).0: i32);
        _11 = _7 as u8 (IntToInt);
        _10 = core::num::<impl u8>::next_power_of_two(move _11) -> bb7;
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _27 = Shl(const 1_u16, const 15_i32);
        _26 = Add(move _27, const 1_u16);
        _25 = core::num::<impl u16>::next_power_of_two(move _26) -> bb9;
    }

    bb7: {
        _9 = &_10;
        _13 = const 0_u8;
        _12 = &_13;
        _8 = (move _9, move _12);
        _14 = (_8.0: &u8);
        _15 = (_8.1: &u8);
        _18 = (*_14);
        _19 = (*_15);
        _17 = Eq(move _18, move _19);
        _16 = Not(move _17);
        switchInt(move _16) -> [0: bb2, otherwise: bb8];
    }

    bb8: {
        _20 = core::panicking::AssertKind::Eq;
        _22 = Option::<Arguments<'_>>::None;
        _21 = core::panicking::assert_failed::<u8, u8>(move _20, _14, _15, move _22);
    }

    bb9: {
        _24 = &_25;
        _29 = const 0_u16;
        _28 = &_29;
        _23 = (move _24, move _28);
        _30 = (_23.0: &u16);
        _31 = (_23.1: &u16);
        _34 = (*_30);
        _35 = (*_31);
        _33 = Eq(move _34, move _35);
        _32 = Not(move _33);
        switchInt(move _32) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _36 = core::panicking::AssertKind::Eq;
        _38 = Option::<Arguments<'_>>::None;
        _37 = core::panicking::assert_failed::<u16, u16>(move _36, _30, _31, move _38);
    }

    bb11: {
        _43 = Shl(const 1_u32, const 31_i32);
        _42 = Add(move _43, const 1_u32);
        _41 = core::num::<impl u32>::next_power_of_two(move _42) -> bb12;
    }

    bb12: {
        _40 = &_41;
        _45 = const 0_u32;
        _44 = &_45;
        _39 = (move _40, move _44);
        _46 = (_39.0: &u32);
        _47 = (_39.1: &u32);
        _50 = (*_46);
        _51 = (*_47);
        _49 = Eq(move _50, move _51);
        _48 = Not(move _49);
        switchInt(move _48) -> [0: bb14, otherwise: bb13];
    }

    bb13: {
        _52 = core::panicking::AssertKind::Eq;
        _54 = Option::<Arguments<'_>>::None;
        _53 = core::panicking::assert_failed::<u32, u32>(move _52, _46, _47, move _54);
    }

    bb14: {
        _59 = Shl(const 1_u64, const 63_i32);
        _58 = Add(move _59, const 1_u64);
        _57 = core::num::<impl u64>::next_power_of_two(move _58) -> bb15;
    }

    bb15: {
        _56 = &_57;
        _61 = const 0_u64;
        _60 = &_61;
        _55 = (move _56, move _60);
        _62 = (_55.0: &u64);
        _63 = (_55.1: &u64);
        _66 = (*_62);
        _67 = (*_63);
        _65 = Eq(move _66, move _67);
        _64 = Not(move _65);
        switchInt(move _64) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _68 = core::panicking::AssertKind::Eq;
        _70 = Option::<Arguments<'_>>::None;
        _69 = core::panicking::assert_failed::<u64, u64>(move _68, _62, _63, move _70);
    }

    bb17: {
        _75 = Shl(const 1_u128, const 127_i32);
        _74 = Add(move _75, const 1_u128);
        _73 = core::num::<impl u128>::next_power_of_two(move _74) -> bb18;
    }

    bb18: {
        _72 = &_73;
        _77 = const 0_u128;
        _76 = &_77;
        _71 = (move _72, move _76);
        _78 = (_71.0: &u128);
        _79 = (_71.1: &u128);
        _82 = (*_78);
        _83 = (*_79);
        _81 = Eq(move _82, move _83);
        _80 = Not(move _81);
        switchInt(move _80) -> [0: bb20, otherwise: bb19];
    }

    bb19: {
        _84 = core::panicking::AssertKind::Eq;
        _86 = Option::<Arguments<'_>>::None;
        _85 = core::panicking::assert_failed::<u128, u128>(move _84, _78, _79, move _86);
    }

    bb20: {
        return;
    }
}
