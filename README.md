KMIR &mdash; [MIR](https://rustc-dev-guide.rust-lang.org/mir/index.html)'s Operational Semantics in [K](http://github.com/kframework)
=============================================================

üõ†Ô∏è**Work in progress**üõ†Ô∏è

[MIR](https://rustc-dev-guide.rust-lang.org/mir/index.html) is the mid-level internal representation of Rust program in rust compiler.

The `KMIR` project defines MIR semantics formally in K and attempts build a scalable testing and verification tool for real world Rust programs. 

## Quick Start 

### Installation

- Install the `kup` package manager:
  ```sh
  bash <(curl https://kframework.org/install)
  ```
- install the latest version of KMIR.
  ```sh
  kup install kmir
  ```

You can refer to `kup -h` for more options. For example,
-   `kup list kmir`: list available KMIR versions.
-   `kup install kmir --version 366f8fb`: install a paricular version of KMIR.

### Using `KMIR`

At the current stage, `KMIR` is to be used as a command-line tool. We list the main functions in the following, while users are recommended to explore the latest options using `kmir -h` or more options of a command using `kmir {cmd} -h`.

  ```bash
  usage: kmir [-h] {parse,run,prove,show-kcfg,view-kcfg} ...

  KMIR command line tool

  positional arguments:
    {parse,run,prove,show-kcfg,view-kcfg}
                          Command to execute
      parse               Parse a MIR file
      run                 Run a MIR program
      prove               Prove a MIR specification WARN: EXPERIMENTAL AND WORK IN PROGRESS
      show-kcfg           Display tree show of CFG
      view-kcfg           Display tree view of CFG

  options:
    -h, --help            show this help message and exit
  ```

#### Parsing a MIR file
The `kmir parse` command invokes the parser generated by K and outputs a KAST representation of MIR abstract syntax parsed from a MIR file. 

For example, 
  ```sh
  kmir parse demo/assert-true.mir
  ```

The output of this command is going to look intimidating, but it is, in fact, just a K-friendly representation of the program's abstract-syntax tree. `kmir parse` can *unparse* this representation to make it look more like the original MIR source (note the `--output pretty` at the end).

```sh
kmir parse demo/assert-true.mir --output pretty
```

Furthermore, users can explore more options by running `kmir parse -h`.

#### Execute a MIR program
The `kmir run` command will interpret a MIR program according to the predefined operational rules of `MIR`. This command invokes the LLVM interpreter generated by K and execute the MIR code in the file. 

For example,
```sh
kmir run demo/assert-true.mir --output pretty
```

#### Prove a MIR program 
**(Under development, command interface unstable )**

Use the following commands from the `kmir` directory to manually prove `k` specification files for MIR.
```sh
kmir prove --spec-file kmir/src/tests/integration/test-data/prove-rs/simple-spec.k
```

#### Display KCFG
```sh
kmir show-kcfg --spec-file kmir/src/tests/integration/test-data/prove-rs/simple-spec.k --save-directory <path to folder>
```

In order to save `kcfgs` the flag `--save-directory` can be added with a path to the directory to save the kcfgs to (this dir must already be created).

## Build from source

### Getting source code
Using the following command to clone this repository, including its submodules:
```sh
git clone --recurse-submodules git@github.com:runtimeverification/mir-semantics.git
```

### Build `KMIR`

Prerequsites: `python 3.8.*`, `pip >= 20.0.2`, `poetry >= 1.3.2`.
Users are referred to the tool's installation page for more details:
- [Installing Python](https://www.python.org/downloads/)
- [Installing `pip`](https://pip.pypa.io/en/stable/installation/): It usually comes with Python installation.
- [Installing `poetry`](https://python-poetry.org/docs/)

The build system of `KMIR` is a mixture of `poetry` + `kbuild` + `make`:
* `poetry` handles Python dependencies, see [pyproject.toml](`pyproject.toml`) for Python-related configuration
* `kbuild` handles K dependencies and build targets, see [kbuild.toml](`kbuild.toml`)
* `make build` ties the two together

```sh
cd kmir
make build
```

### Global Installation of `KMIR` with `pip`
```sh
source set_env.sh
pip install dist/*.whl
```

### Local Installation of `KMIR` with `poetry`
Alternatively, you can also install `kmir` locally and running it with `poetry`.
```sh
poetry install
```

In a local installation, we suggest calling `kmir` via Poetry's `poetry run` command. This ensures that you are calling the feshly built `kmir`. For example:

```sh
poetry run kmir parse --definition-dir $(kbuild which llvm) ../demo/assert-true.mir --output pretty
```

Alternative, you can spawn a one-off shell that will allow you to interact with `kmir` directly by executing the command

```sh
poetry shell
```

In the shell, execute kmir as 
```sh
kmir parse --definition-dir $(kbuild which llvm) ../demo/assert-true.mir --output pretty
```

Additionally, the `Haskell` build needs to be supplied when calling `kmir prove`. For example,
```sh
poetry run kmir prove --definition-dir $(kbuild which llvm) --haskell-dir $(kbuild which haskell) --spec-file src/tests/integration/test-data/prove-rs/simple-spec.k
```

> Note: Since `kmir` is just a thin Python script and does not do any heavy-lifting itself, it needs access the K definition of MIR. The `kbuild` tool handles compiling the K code and provides a `which` command to output the path to the compiled definition, which we give to `kmir`. We also provide a script, [`set_env.sh`](kmir/src/set_env.sh) to set the path to the definitions, `KMIR_LLVM_DIR` and `KMIR_HASKELL_DIR`, globally. Consequently, the `--definition-dir` can be omitted. Run the script as 
```sh
source set_env.sh
```

## Working with Docker
We provide a Docker image for isolated testing, locally and in CI.
NOTE: Mac Silicon hardware not supported.

From the root of the repository:
  - Build the docker image (the `./deps/k_release` file pins the K version):
    ```sh
    docker build . --tag kmir-tests --build-arg K_COMMIT=$(cat deps/k_release) --file .github/workflows/Dockerfile
    ```
   - Run the integration tests in a container:
    ```
    docker run --name kmir-container --rm --interactive --tty --detach --workdir /home/user kmir-tests &&
    docker cp . kmir-container:/home/user &&
    docker exec kmir-container chown -R user:user /home/user &&
    docker exec --user user kmir-container make -C kmir test-integration
    ```

Note: you may need to run the `docker` commands with `sudo`, or start a superuser shell with `sudo -s`.

We use a similar workflow in CI actions defined in the `.github/` directory.

# Working with KMIR
`kmir` is a Python package and CLI tool that leverages the [`pyk`](https://github.com/runtimeverification/pyk) library to provide a Python interface for the K semantics. While the K semantics can be also used directly with K framework, the `kmir` tool makes it more accessible for people not familiar with K.

## Working on the Python files

The Python source code of the `kmir` tool and library resides in [`kmir/src/`](src). The entry point to the tool is [`src/kmir/__main__.py`](src/kmir/__main__.py).

Use `make` to run common tasks (see the [Makefile](Makefile) for a complete list of available targets).

* `make build`: Build wheel
* `make check`: Check code style
* `make format`: Format code
* `make test-unit`: Run unit tests
* `make test-integration`: Run integration tests

## Working on the K files
The K source code of the semantics resides in [`k-src`](k-src).

Working on the semantics roughly comprises the following steps:

0. Pick a MIR/Rust program as a running example, or a several of them
1. Modify K files
2. Rebuild the K definition
3. Testout the new definition on the running example
4. Running integration tests

However, from step 3, the following alternative steps avoids rebuilding from scratch:
1. Run `poetry run kbuild kompile llvm` to re-kompile the semantics
2. Run `poetry run kbuild kompile haskell` additionally if you are working on a proof
2. Test the running example with a targetted `kmir <command> <path to example.mir>` 
3. Once happy with the step 3 goes, run a part of the integration tests by calling:
   ```
   TEST_ARGS="-k test_handwritten" make test-integration-{parse, run, prove etc.}
   ```
   Modify the command as necessary to include the tests you want. 
4. Once happy with the step 4 goes, run the complete integration test suite:
   ```
   make test-integration-run
   ```
   This time, do not include the `--kbuild-dir` option to re-kompile everything in a temporary directory.

## Submitting a PR
Make sure the manual is updated with your new feature, the integration tests passed and the nix tests output updated in case there is K definition changes.

### Update `nix` tests output 
When there are changes to the K definition of MIR, the `nix` tests should be re-executed to update the expected output. We provide a `Makefile` to `make` this update easy. 

Before running the tests, it would expect a latest built kmir and `kbuild` DIR's being updated (see the note above on the `set_env.sh` script).

```sh
cd src/tests/nix
make
```

## References
- You may refer to [K tutorial](https://kframework.org/k-distribution/k-tutorial/) to learn more about using K.
- [MIR language reference](https://kframework.org/k-distribution/k-tutorial/)

