KMIR &mdash; [MIR](https://rustc-dev-guide.rust-lang.org/mir/index.html)'s Operational Semantics in [K](http://github.com/kframework)
=============================================================

üõ†Ô∏è**Work in progress**üõ†Ô∏è

[MIR](https://rustc-dev-guide.rust-lang.org/mir/index.html) is the mid-level internal representation of Rust program in rust compiler.

The `KMIR` project defines MIR semantics formally in K and attempts build a scalable testing and verification tool for real world Rust programs. 

## Quick Start 

### Installation

-   `bash <(curl https://kframework.org/install)`: install [kup package manager].
-   `kup install kmir`: install the latest version of KMIR.

You can refer to `kup -h` for more options. For example,
-   `kup list kmir`: list available KMIR versions.
-   `kup install kmir --version 366f8fb`: install a paricular version of KMIR.

**NOTE**: The first run will take longer to fetch all the libraries and compile sources.

### Using `KMIR`

At the current stage, `KMIR` is to be used as a command-line tool. We list the main functions in the following, while users are recommended to explore the latest options using `kmir -h`or more options of a command using `kmir {cmd} -h`.

```bash
usage: kmir [-h] {parse,run,prove,show-kcfg,view-kcfg} ...

KMIR command line tool

positional arguments:
  {parse,run,prove,show-kcfg,view-kcfg}
                        Command to execute
    parse               Parse a MIR file
    run                 Run a MIR program
    prove               Prove a MIR specification WARN: EXPERIMENTAL AND WORK IN PROGRESS
    show-kcfg           Display tree show of CFG
    view-kcfg           Display tree view of CFG

options:
  -h, --help            show this help message and exit
```


#### Parsing a MIR file
The `kmir parse` command invokes the parser generated by K and outputs a KAST representation of MIR abstract syntax parsed from a file. 

```
kmir parse -h
usage: kmir parse [-h] [--verbose] [--debug] [--definition-dir DEFINITION_DIR]
                  [--input {program,binary,json,kast,kore}]
                  [--output {pretty,program,json,kore,kast,none}]
                  input_file

positional arguments:
  input_file            Path to .mir file

options:
  -h, --help            show this help message and exit
  --verbose, -v         Verbose output.
  --debug               Debug output.
  --definition-dir DEFINITION_DIR
                        Path to LLVM definition to use.
  --input {program,binary,json,kast,kore}
                        Input mode
  --output {pretty,program,json,kore,kast,none}
                        Output mode

```

For example, 
```sh
kmir parse demo/assert-true.mir
```

The output of this command is going to look intimidating, but it is, in fact, just a K-friendly representation of the programs abstract-syntax tree. `kmir parse` can *unparse* this representation to make it look more like the original MIR source (note the `--output pretty` at the end).

```sh
kmir parse demo/assert-true.mir --output pretty
```

#### Execute a MIR program
The `kmir run` command will interpret a MIR program according to the predefined operatonal rules of `MIR`. This command invokes the LLVM interpreter generated by K and execute the MIR code in the file. 

For example,
```sh
kmir run  <path to your mir file> --output pretty
```

#### Prove a MIR program 
**(Under development, command interface unstable )**
Use the following commands from the `kmir` directory to manually prove `k` specification files for MIR.
```sh
kmir prove --spec-file <path to your spec file>
```

#### Display KCFG
```sh
kmir show-kcfg --spec-file kmir/src/tests/integration/test-data/prove-rs/simple-spec.k --save-directory <path to folder>
```

In order to save `kcfgs` the flag `--save-directory` can be added with a path to the directory to save the kcfgs to (this dir must already be created).

## Build from source

### Getting source code
Using the following command to clone this repository, including its submodules:
```sh
git clone --recurse-submodules git@github.com:runtimeverification/mir-semantics.git
```

### Build `KMIR`
The build system of `KMIR` is a mixture of `poetry` + `kbuild` + `make`:
* `poetry` handles Python dependencies, see [pyproject.toml](`pyproject.toml`) for Python-related configuration;
* `kbuild` handles K dependencies and build targets, see [kbuild.toml](`kbuild.toml`);
* `make build` ties the two together.

```sh
cd kmir
make build
```

### Global Installation of `KMIR` with `pip`
```sh
source set_env.sh
pip install dist/*.whl
```

### Local Installation of `KMIR` with `poetry`
Alternatively, you can also install `kmir` locally and running it with `poetry`.
```sh
poetry install
```

In a local installation, we suggest calling `kmir` via Poetry's `poetry run` command. This ensures that you are calling the feshly built `kmir`. For example:

```sh
poetry run kmir parse --definition-dir $(kbuild which llvm) ../demo/assert-true.mir --output pretty
```

Alternative, you can spawn a one-off shell that will allow you to interact with `kmir` directly by executing the command

```sh
poetry shell
```

In the shell, execute kmir as 
```sh
kmir parse --definition-dir $(kbuild which llvm) ../demo/assert-true.mir --output pretty
```

Additionally, the `Haskell` build needs to be supplied when calling `kmir prove`. For example,
```sh
poetry run kmir prove --definition-dir $(kbuild which llvm) --haskell-dir $(kbuild which haskell) --spec-file src/tests/integration/test-data/prove-rs/simple-spec.k
```

> Note: Since `kmir` is just a thin Python script and does not do any heavy-lifting itself, it needs access the the K definition of MIR. The `kbuild` tool handles compiling the K code and provides a `which` command to output the path to the compiled definition, which we give to `kmir`. We also provide a script, [`set_env.sh`](kmir/src/set_env.sh) to set the path to the definitions, `KMIR_LLVM_DIR` and `KMIR_HASKELL_DIR`, globally. Consequently, the `--definition-dir` can be omitted. Run the script as 
```sh
source set_env.sh
```

## Working with Docker
We provide a Docker image for isolated testing, locally and in CI.

- From the root of the repository:
    - Build the docker image (the `./deps/k_release` file pins the K version):
    ```
    $ docker build . --build-arg K_COMMIT=$(cat ./deps/k_release) --tag mir-semantics:$(cat ./deps/k_release)
    ```
    - Run the integration tests in a container:
    ```
    $ docker run --name mir-semantics --rm -it -u user --workdir /home/user mir-semantics:$(cat ./deps/k_release) make -C kmir test-integration
    ```

Note: you may need to run the `docker` commands with `sudo`.

We use a similar workflow in CI actions defined in the `.github/` directory.

# Working with KMIR
`kmir` is a Python package and CLI tool that leverages the [`pyk`](https://github.com/runtimeverification/pyk) library to provide a Python interface for the K semantics. While the K semantics can be also used directly with K framework, the `kmir` tool makes it more accessible for people not familiar with K.

## Working on the Python files

The Python source code of the `kmir` tool and library resides in [`kmir/src/`](src). The entry point to the tool is [`src/kmir/__main__.py`](src/kmir/__main__.py).

Use `make` to run common tasks (see the [Makefile](Makefile) for a complete list of available targets).

* `make build`: Build wheel
* `make check`: Check code style
* `make format`: Format code
* `make test-unit`: Run unit tests
* `make test-integration`: Run integration tests

## Working on the K files
The K source code of the semantics resides in [`k-src`](k-src).

Working on the semantics roughly comprises the following steps:
0. Pick a MIR/Rust program as a running example, or a several of them
1. Modify K files
2. Run `poetry run kbuild kompile llvm` to re-kompile the semantics
3. Test the running example with a targetted `kmir <command> <path to example.mir>` 
4. Once happy with the step 3 goes, run a part of the integration tests by calling:
   ```
   TEST_ARGS=`--kbuild-dir ~/.kbuild -k test_handwritten` make test-integration-run
   ```
   Modify the command as necessary to include the tests you want. Use `TEST_ARGS='--kbuild-dir ~/.kbuild'` to use your transient `kbuild` artifacts (the kompiled definition) to avoid rebuilding from scratch.
5. Once happy with the step 4 goes, run the complete integration test suite:
   ```
   make test-integration-run
   ```
   This time, do not include the `--kbuild-dir` option to re-kompile everything in a temporary directory.

## Submitting a PR
Make sure the manual is updated with your new feature, pass the integration tests and update the nix tests output.

### Update `nix` tests output 
When there are changes to the K definition of MIR, the `nix` tests should be re-executed to update the expected output. We provide a `Makefile` to `make` this update easy. 

Before runnning the tests, it would expect a latest built kmir and `kbuild` DIR's being updated (see the note above on the `set_env.sh` script).

```sh
cd src/tests/nix
make
```

## References
- You may refer to [K tutorial](https://kframework.org/k-distribution/k-tutorial/) to learn more about using K.
- [MIR language reference](https://kframework.org/k-distribution/k-tutorial/)

